
<!DOCTYPE html>
<html>
<head>
  <title>Figma Exporter v2.1 - BUILD 20260110-FIX1</title>
  <style>
    /* ============================================
       GENKI Design System - Figma Exporter UI
       Brand DNA: 科技极客风（青色系）
       Layout: Left Viewport + Right Panel
    ============================================ */

    :root {
      /* Base Colors - Primary (Cyan) */
      --color-primary-50: #ecfeff;
      --color-primary-100: #cffafe;
      --color-primary-200: #a5f3fc;
      --color-primary-300: #67e8f9;
      --color-primary-400: #22d3ee;
      --color-primary-500: #06b6d4;
      --color-primary-600: #0891b2;
      --color-primary-700: #0e7490;
      --color-primary-800: #155e75;
      --color-primary-900: #164e63;

      /* Secondary (Blue) */
      --color-secondary-400: #60a5fa;
      --color-secondary-500: #3b82f6;
      --color-secondary-600: #2563eb;

      /* Accent (Indigo) */
      --color-accent-400: #818cf8;
      --color-accent-500: #6366f1;
      --color-accent-600: #4f46e5;

      /* Neutral */
      --color-neutral-50: #fafafa;
      --color-neutral-100: #f4f4f5;
      --color-neutral-200: #e4e4e7;
      --color-neutral-300: #d4d4d8;
      --color-neutral-400: #a1a1aa;
      --color-neutral-500: #71717a;
      --color-neutral-600: #52525b;
      --color-neutral-700: #3f3f46;
      --color-neutral-800: #27272a;
      --color-neutral-900: #18181b;

      /* Semantic Colors */
      --color-success: #10b981;
      --color-warning: #f59e0b;
      --color-error: #ef4444;
      --color-info: #3b82f6;

      /* Craft Colors */
      --craft-gold: #d4a853;
      --craft-silver: #c0c0c0;
      --craft-uv: #18A0FB;
      --craft-emboss: #a78bfa;
      --craft-normal: #4ade80;
      --craft-displacement: #fa8c4a;

      /* Spacing */
      --space-xxs: 2px;
      --space-xs: 4px;
      --space-sm: 8px;
      --space-md: 12px;
      --space-lg: 16px;
      --space-xl: 20px;
      --space-2xl: 24px;
      --space-3xl: 32px;

      /* Radius */
      --radius-sm: 4px;
      --radius-md: 6px;
      --radius-lg: 8px;
      --radius-xl: 12px;

      /* Typography */
      --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      --font-size-micro: 9px;
      --font-size-xs: 10px;
      --font-size-sm: 11px;
      --font-size-md: 12px;
      --font-size-lg: 13px;
      --font-size-xl: 14px;
      --font-size-2xl: 16px;
      --font-size-3xl: 18px;

      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.3);
      --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.3);

      /* Layout */
      --panel-width: 280px;
      --header-height: 48px;
      --footer-height: 56px;

      /* Glass (shadcn-like, derived from base tokens) */
      --glass-surface: color-mix(in srgb, var(--color-neutral-900) 72%, transparent);
      --glass-surface-strong: color-mix(in srgb, var(--color-neutral-900) 86%, transparent);
      --glass-tint: color-mix(in srgb, var(--color-primary-500) 16%, transparent);
      --glass-tint-strong: color-mix(in srgb, var(--color-primary-500) 26%, transparent);
      --glass-border: color-mix(in srgb, var(--color-primary-400) 22%, transparent);
      --glass-border-strong: color-mix(in srgb, var(--color-primary-400) 32%, transparent);
      --glass-shadow: 0 10px 30px color-mix(in srgb, var(--color-neutral-900) 65%, transparent);
      --glass-glow: 0 0 0 1px color-mix(in srgb, var(--color-primary-400) 20%, transparent), 0 0 18px color-mix(in srgb, var(--color-primary-400) 14%, transparent);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* ============================================
       GENKI Scrollbar - 简洁大气
    ============================================ */
    ::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 2px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(6, 182, 212, 0.4);
    }

    ::-webkit-scrollbar-corner {
      background: transparent;
    }

    body {
      font-family: var(--font-family);
      background: var(--color-neutral-900);
      color: var(--color-neutral-100);
      height: 100vh;
      overflow: hidden;
    }

    /* ============================================
       Main Layout: Left Viewport + Right Panel
    ============================================ */
    .app-container {
      display: flex;
      height: 100vh;
      width: 100%;
    }

    /* Left: Viewport Area */
    .viewport {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--color-neutral-900);
      position: relative;
      overflow: hidden;
      /* 确保子元素按列排列：header -> content -> thumbnails */
    }

    .viewport-header {
      height: var(--header-height);
      padding: 0 var(--space-lg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(20, 20, 25, 0.75);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
    }

    .logo-section {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .logo-icon {
      width: 28px;
      height: 28px;
      border-radius: var(--radius-md);
      background: linear-gradient(135deg, var(--color-primary-500), var(--color-secondary-500));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .logo-text {
      display: flex;
      flex-direction: column;
    }

    .logo-title {
      font-size: var(--font-size-lg);
      font-weight: 700;
      color: var(--color-primary-400);
      letter-spacing: 0.5px;
    }

    .logo-subtitle {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-500);
    }

    .viewport-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at 50% 50%, rgba(6, 182, 212, 0.03) 0%, transparent 50%),
        repeating-linear-gradient(0deg, transparent, transparent 19px, rgba(255, 255, 255, 0.02) 19px, rgba(255, 255, 255, 0.02) 20px),
        repeating-linear-gradient(90deg, transparent, transparent 19px, rgba(255, 255, 255, 0.02) 19px, rgba(255, 255, 255, 0.02) 20px);
      position: relative;
      overflow: auto; /* 允许内容滚动 */
    }

    .viewport-placeholder {
      text-align: center;
      color: var(--color-neutral-500);
    }

    .viewport-placeholder-icon {
      font-size: 48px;
      margin-bottom: var(--space-md);
      opacity: 0.5;
    }

    .viewport-placeholder-text {
      font-size: var(--font-size-sm);
      max-width: 200px;
      line-height: 1.5;
    }

    /* ============================================
       Vector Preview Grid - 空间布局预览
    ============================================ */
    .vector-preview-container {
      width: 100%;
      height: 100%;
      padding: var(--space-md);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .vector-preview-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-sm);
      flex-shrink: 0;
    }

    .vector-preview-title {
      font-size: var(--font-size-sm);
      font-weight: 600;
      color: var(--color-neutral-300);
    }

    .vector-preview-hint {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-500);
    }

    .auto-name-btn {
      padding: var(--space-xxs) var(--space-sm);
      background: rgba(6, 182, 212, 0.1);
      border: 1px solid rgba(6, 182, 212, 0.3);
      border-radius: var(--radius-sm);
      color: var(--color-primary-400);
      font-size: var(--font-size-micro);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .auto-name-btn:hover {
      background: rgba(6, 182, 212, 0.2);
      border-color: var(--color-primary-400);
      color: var(--color-primary-300);
    }

    /* 空间布局画布 */
    .spatial-canvas {
      flex: 1;
      position: relative;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: var(--radius-lg);
      overflow: hidden;
    }

    .spatial-viewport {
      position: absolute;
      top: 50%;
      left: 50%;
      transform-origin: center center;
    }

    /* Vector 卡片 - 绝对定位 */
    .vector-card {
      position: absolute;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .vector-card:hover {
      border-color: rgba(6, 182, 212, 0.4);
      background: rgba(6, 182, 212, 0.06);
      z-index: 10;
    }

    .vector-card.selected {
      border-color: var(--color-primary-500);
      background: rgba(6, 182, 212, 0.1);
      z-index: 20;
    }

    .vector-card-name {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-400);
      text-align: center;
      padding: 2px 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .vector-card.selected .vector-card-name {
      color: var(--color-primary-300);
    }

    /* SVG 预览 - 解决 Union 节点居中问题 */
    .vector-svg-preview {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      opacity: 0.3;
      pointer-events: none;
      z-index: 1;
    }

    .vector-card:hover .vector-svg-preview {
      opacity: 0.5;
    }

    .vector-card.selected .vector-svg-preview {
      opacity: 0.6;
    }

    /* 序号徽章 */
    .vector-order-badge {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: transparent;
      border: 1px solid var(--color-primary-500);
      color: var(--color-primary-500);
      font-size: 8px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.9;
    }

    /* 幽灵序号（hover时显示下一个数字） */
    .vector-ghost-badge {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: transparent;
      border: 1px dashed var(--color-neutral-500);
      color: var(--color-neutral-500);
      font-size: 8px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .vector-card:hover .vector-ghost-badge {
      opacity: 1;
    }

    .vector-card.selected .vector-ghost-badge {
      display: none;
    }

    /* 根面板样式 */
    .vector-card.root-panel {
      border-color: var(--color-primary-400);
      background: rgba(6, 182, 212, 0.2);
    }

    /* Ghost 折叠边（预览） */
    .fold-edge-ghost {
      position: absolute;
      cursor: pointer;
      z-index: 45;
      opacity: 0.5;
      border: 1px dashed #f472b6;
      background: transparent;
    }

    .fold-edge-ghost:hover {
      opacity: 0.8;
      border-width: 2px;
      box-shadow: 0 0 6px rgba(244, 114, 182, 0.5);
    }

    .root-badge {
      position: absolute;
      top: var(--space-xs);
      left: var(--space-xs);
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--color-primary-500);
      color: white;
      font-size: 10px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .h-badge {
      position: absolute;
      top: var(--space-xs);
      right: var(--space-xs);
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #f59e0b;
      color: white;
      font-size: 10px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .vector-card.h-panel {
      border-color: #f59e0b;
      box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
    }

    /* ============================================
       折叠边样式 - Fold Edge Styles
    ============================================ */
    .fold-edge {
      position: absolute;
      cursor: pointer;
      transition: all 0.15s ease;
      z-index: 50;
    }

    /* 横向折叠边（粉色实线） */
    .fold-edge.horizontal {
      height: 2px;
      border: none;
      background: #ec4899;
      box-shadow: 0 0 4px rgba(236, 72, 153, 0.5);
    }

    .fold-edge.horizontal:hover {
      height: 3px;
      background: #f472b6;
      box-shadow: 0 0 6px rgba(236, 72, 153, 0.8);
    }

    /* 竖向折叠边（绿色实线） */
    .fold-edge.vertical {
      width: 2px;
      border: none;
      background: #10b981;
      box-shadow: 0 0 4px rgba(16, 185, 129, 0.5);
    }

    .fold-edge.vertical:hover {
      width: 3px;
      background: #34d399;
      box-shadow: 0 0 6px rgba(16, 185, 129, 0.8);
    }

    /* 选中状态 */
    .fold-edge.selected {
      z-index: 60;
    }

    .fold-edge.horizontal.selected {
      height: 4px;
      background: #f472b6;
      box-shadow: 0 0 8px rgba(236, 72, 153, 0.9);
    }

    .fold-edge.vertical.selected {
      width: 4px;
      background: #34d399;
      box-shadow: 0 0 8px rgba(16, 185, 129, 0.9);
    }

    /* 折叠边序号徽章 */
    .fold-edge-badge {
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      font-size: 9px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      pointer-events: none;
      opacity: 0.75;
    }

    .fold-edge.horizontal .fold-edge-badge {
      background: #ec4899;
      top: -16px;
      left: 50%;
      transform: translateX(-50%);
    }

    .fold-edge.vertical .fold-edge-badge {
      background: #10b981;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
    }

    /* 排序预览条 - 展开状态（原始位置，不浮动） */
    .order-preview-bar {
      display: none !important; /* 隐藏折叠顺序预览栏 */
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm);
      position: fixed;
      bottom: var(--space-xl);
      left: var(--space-xl);
      z-index: 2000;
      pointer-events: auto;
      background: rgba(10, 15, 20, 0.72);
      backdrop-filter: blur(18px) saturate(160%);
      -webkit-backdrop-filter: blur(18px) saturate(160%);
      border: 1px solid rgba(6, 182, 212, 0.28);
      border-radius: var(--radius-md);
      min-height: 40px;
      max-height: 80px;
      overflow-y: auto;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(6, 182, 212, 0.18), 0 0 18px rgba(6, 182, 212, 0.12);
    }

    @supports (background: color-mix(in srgb, white 50%, transparent)) {
      .order-preview-bar {
        background:
          linear-gradient(180deg, var(--glass-tint), transparent),
          var(--glass-surface);
        border: 1px solid var(--glass-border);
        box-shadow: var(--glass-shadow), var(--glass-glow);
      }
    }

    /* 最小化状态 - 精致小图标（和canvas-btn完全一致） */
    .order-preview-bar.minimized {
      bottom: var(--space-xl);
      left: var(--space-xl);
      transform: none;
      width: auto;
      height: auto;
      min-height: auto;
      max-height: auto;
      margin: 0;
      padding: var(--space-xxs) var(--space-sm);
      border-radius: var(--radius-sm);
      overflow: visible;
      justify-content: center;
      align-items: center;
      background: rgba(10, 15, 20, 0.82);
      backdrop-filter: blur(18px) saturate(160%);
      -webkit-backdrop-filter: blur(18px) saturate(160%);
      border: 1px solid rgba(6, 182, 212, 0.34);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(6, 182, 212, 0.22), 0 0 16px rgba(6, 182, 212, 0.14);
      z-index: 2000;
      cursor: pointer;
      transition: all 0.15s;
      font-size: 9px;
      font-weight: 700;
      color: var(--color-neutral-400);
    }

    @supports (background: color-mix(in srgb, white 50%, transparent)) {
      .order-preview-bar.minimized {
        background:
          linear-gradient(180deg, var(--glass-tint-strong), transparent),
          var(--glass-surface-strong);
        border: 1px solid var(--glass-border-strong);
        box-shadow: var(--shadow-sm);
      }
    }

    .order-preview-bar.minimized:hover {
      transform: translateY(-1px);
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-primary-400);
    }

    /* 最小化时隐藏所有内容，只显示按钮 */
    .order-preview-bar.minimized #orderLabel,
    .order-preview-bar.minimized #orderItems,
    .order-preview-bar.minimized #orderClearBtn,
    .order-preview-bar.minimized .order-preview-item,
    .order-preview-bar.minimized .order-preview-arrow {
      display: none !important;
    }

    .order-preview-bar.minimized .canvas-btn {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      font-size: 16px;
      color: var(--color-primary-500);
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
    }

    .order-preview-label {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-500);
      margin-right: var(--space-sm);
      flex-shrink: 0;
      white-space: nowrap;
    }

    .order-preview-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: linear-gradient(135deg, rgba(6, 182, 212, 0.08), rgba(14, 165, 233, 0.08));
      border: 1px solid rgba(6, 182, 212, 0.25);
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      color: var(--color-primary-400);
      transition: all 0.2s ease;
      cursor: default;
    }

    .order-preview-item:hover {
      background: linear-gradient(135deg, rgba(6, 182, 212, 0.12), rgba(14, 165, 233, 0.12));
      border-color: rgba(6, 182, 212, 0.4);
      transform: translateY(-1px);
    }

    .order-preview-num {
      font-weight: 700;
      color: var(--color-primary-400);
    }

    .order-preview-arrow {
      color: var(--color-neutral-600);
      font-size: 10px;
    }

    /* ============================================
       工艺预览缩略图 - 类似 C4D 材质球
       固定在左侧视口底部（刀版图预览下方）
    ============================================ */
    .craft-preview-thumbnails {
      width: 100%;
      padding: var(--space-sm) var(--space-md);
      background: rgba(0, 0, 0, 0.3);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
      /* 固定在底部，不随内容滚动 */
      position: relative;
      z-index: 10;
    }

    .craft-thumbnails-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-xs);
    }

    .craft-thumbnails-title {
      font-size: var(--font-size-xs);
      font-weight: 600;
      color: var(--color-neutral-300);
    }

    /* 切换按钮 */
    .craft-thumbnails-toggle {
      background: transparent;
      border: none;
      color: var(--color-neutral-400);
      cursor: pointer;
      padding: 4px 8px;
      border-radius: var(--radius-sm);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .craft-thumbnails-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-neutral-200);
    }

    .craft-thumbnails-toggle .toggle-icon {
      font-size: 12px;
      transition: transform 0.2s ease;
    }

    .craft-preview-thumbnails.collapsed .toggle-icon {
      transform: rotate(-90deg);
    }

    .craft-preview-thumbnails.collapsed .craft-thumbnails-grid {
      display: none;
    }

    .craft-thumbnails-grid {
      display: flex;
      gap: var(--space-xs);
      overflow-x: auto;
      overflow-y: hidden;
      padding: var(--space-xxs) 0;
    }

    /* 隐藏滚动条但保持可滚动 */
    .craft-thumbnails-grid::-webkit-scrollbar {
      height: 4px;
    }

    .craft-thumbnails-grid::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 2px;
    }

    .craft-thumbnails-grid::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
    }

    .craft-thumbnails-grid::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* 缩略图卡片 - 类似 C4D 材质球 */
    .craft-thumbnail-card {
      flex-shrink: 0;
      width: 50px;
      display: flex;
      flex-direction: column;
      gap: var(--space-xxs);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .craft-thumbnail-card:hover {
      transform: translateY(-2px);
    }

    .craft-thumbnail-preview {
      width: 50px;
      height: 50px;
      border-radius: var(--radius-md);
      background: rgba(0, 0, 0, 0.4);
      border: 2px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      position: relative;
      overflow: hidden;
      transition: all 0.2s ease;
    }

    .craft-thumbnail-card:hover .craft-thumbnail-preview {
      border-color: rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .craft-thumbnail-card.active .craft-thumbnail-preview {
      border-color: var(--color-primary-400);
      box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.2);
      background: rgba(6, 182, 212, 0.1);
    }

    .craft-thumbnail-label {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-400);
      text-align: center;
      font-weight: 500;
      transition: color 0.2s ease;
    }

    .craft-thumbnail-card:hover .craft-thumbnail-label {
      color: var(--color-neutral-200);
    }

    /* Canvas 材质预览球 */
    .craft-thumbnail-canvas {
      width: 100%;
      height: 100%;
      border-radius: var(--radius-md);
      display: block;
    }

    .craft-thumbnail-card.active .craft-thumbnail-label {
      color: var(--color-primary-400);
      font-weight: 600;
    }

    /* ============================================
       工艺贴图大图预览区域
    ============================================ */
    .craft-large-preview {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      border-radius: 0;
      border: none;
      overflow: hidden;
      display: none; /* 默认隐藏 */
      z-index: 1000;
    }

    .craft-large-preview.active {
      display: flex;
      flex-direction: column;
      padding: 20px;
    }

    /* WebGPU Canvas */
    #webgpuCanvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: contain;
      z-index: 50;
      display: none;
    }

    .craft-large-preview-canvas {
      flex: 1;
      width: calc(100% - 40px);
      height: calc(100% - 40px);
      margin: 20px;
      object-fit: contain;
      background: rgba(0, 0, 0, 0.3);
    }

    .craft-large-preview-header {
      position: absolute;
      top: var(--space-sm);
      left: var(--space-sm);
      right: var(--space-sm);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
    }

    .craft-large-preview-title {
      font-size: var(--font-size-sm);
      color: var(--color-neutral-200);
      font-weight: 600;
      background: rgba(0, 0, 0, 0.6);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-md);
      backdrop-filter: blur(8px);
    }

    .craft-large-preview-close {
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--color-neutral-300);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: var(--font-size-sm);
      backdrop-filter: blur(8px);
      transition: all 0.2s ease;
    }

    .craft-large-preview-close:hover {
      background: rgba(0, 0, 0, 0.8);
      border-color: rgba(255, 255, 255, 0.2);
      color: var(--color-neutral-100);
    }

    /* 画布控制工具栏 - 左上角浮动版本 */
    .canvas-controls-floating {
      position: absolute;
      top: var(--space-sm);
      left: var(--space-sm);
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 2px 4px;
      background: rgba(20, 20, 25, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-md);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 10;
    }

    /* 画布控制工具栏 - 左下角磨砂面板（紧凑版） */
    .canvas-controls {
      position: absolute;
      bottom: var(--space-sm);
      left: var(--space-sm);
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 2px 4px;
      background: rgba(20, 20, 25, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-md);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 10;
    }

    .canvas-btn {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      color: var(--color-neutral-400);
      cursor: pointer;
      font-size: 11px;
      transition: all 0.15s;
    }

    .canvas-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--color-primary-400);
    }

    .canvas-zoom-display {
      font-size: 9px;
      font-family: var(--font-mono);
      color: var(--color-neutral-500);
      min-width: 28px;
      text-align: center;
    }

    .viewport-footer {
      height: var(--footer-height);
      padding: 0 var(--space-lg);
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(0, 0, 0, 0.3);
    }

    .status-bar {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }

    .status-indicator {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--color-success);
    }

    .status-indicator.warning { background: var(--color-warning); }
    .status-indicator.error { background: var(--color-error); }

    #status {
      font-size: var(--font-size-xs);
      color: var(--color-neutral-400);
    }

    #status.success { color: var(--color-success); }
    #status.error { color: var(--color-error); }

    .viewport-info {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-600);
    }

    /* ============================================
       Right: Control Panel (可折叠)
    ============================================ */
    .control-panel {
      width: var(--panel-width);
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: rgba(20, 20, 25, 0.4);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(40px) saturate(180%);
      -webkit-backdrop-filter: blur(40px) saturate(180%);
      box-shadow: -4px 0 24px rgba(0, 0, 0, 0.3);
      transition: width 0.3s ease, transform 0.3s ease;
      position: relative;
    }

    .control-panel.collapsed {
      width: 0;
      min-width: 0;
      border-left: none;
    }

    .control-panel.collapsed .panel-content,
    .control-panel.collapsed .panel-header,
    .control-panel.collapsed .panel-footer,
    .control-panel.collapsed .panel-tabs,
    .control-panel.collapsed .panel-tab-content {
      display: none;
    }

    /* 折叠切换按钮 */
    .panel-toggle {
      position: absolute;
      left: -32px;
      top: 50%;
      transform: translateY(-50%);
      width: 28px;
      height: 56px;
      background: rgba(20, 20, 25, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-right: none;
      border-radius: var(--radius-md) 0 0 var(--radius-md);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--color-neutral-400);
      font-size: 12px;
      transition: all 0.2s;
      z-index: 10;
    }

    .panel-toggle:hover {
      background: rgba(6, 182, 212, 0.1);
      color: var(--color-primary-400);
    }

    .control-panel.collapsed .panel-toggle {
      left: -28px;
    }

    .panel-header {
      padding: var(--space-md) var(--space-lg);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .panel-title {
      font-size: var(--font-size-sm);
      font-weight: 600;
      color: var(--color-neutral-300);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* N面板 Tab 切换 */
    .panel-tabs {
      display: flex;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(0, 0, 0, 0.2);
    }

    .panel-tab {
      flex: 1;
      padding: var(--space-sm) var(--space-md);
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: rgba(255, 255, 255, 0.5);
      font-size: var(--font-size-xs);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-xs);
    }

    .panel-tab:hover {
      color: rgba(255, 255, 255, 0.8);
      background: rgba(255, 255, 255, 0.03);
    }

    .panel-tab.active {
      color: var(--color-primary-400);
      border-bottom-color: var(--color-primary-500);
      background: rgba(6, 182, 212, 0.08);
    }

    .panel-tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
      padding: var(--space-md);
    }

    .panel-tab-content.active {
      display: block;
    }

    /* 折叠组列表样式 */
    .fold-group-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
      max-height: 300px;
      overflow-y: auto;
    }

    .fold-group-item {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-md);
      cursor: grab;
      transition: all 0.15s ease;
    }

    .fold-group-item:hover {
      border-color: rgba(6, 182, 212, 0.3);
      background: rgba(6, 182, 212, 0.05);
    }

    .fold-group-item.selected {
      border-color: var(--color-primary-500);
      background: rgba(6, 182, 212, 0.1);
    }

    .fold-group-item.dragging {
      opacity: 0.5;
    }

    .fold-group-item.drag-over {
      border-color: var(--color-primary-400);
      border-style: dashed;
    }

    .fold-group-header {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm);
    }

    .fold-group-expand {
      width: 16px;
      height: 16px;
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      cursor: pointer;
      font-size: 8px;
      padding: 0;
      transition: transform 0.15s;
    }

    .fold-group-expand.expanded {
      transform: rotate(90deg);
    }

    .fold-group-name {
      flex: 1;
      font-size: var(--font-size-sm);
      color: var(--color-neutral-200);
    }

    .fold-group-order {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--color-primary-500);
      color: white;
      font-size: 10px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fold-group-content {
      padding: 0 var(--space-sm) var(--space-sm) 28px;
      display: none;
    }

    .fold-group-content.expanded {
      display: block;
    }

    .fold-group-angle {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-sm);
    }

    .fold-group-angle label {
      font-size: var(--font-size-xs);
      color: rgba(255, 255, 255, 0.6);
    }

    .fold-group-angle input {
      flex: 1;
      height: 4px;
    }

    .fold-group-angle span {
      font-size: var(--font-size-xs);
      color: var(--color-primary-400);
      font-family: var(--font-mono);
      min-width: 36px;
    }

    .fold-group-panels {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .fold-panel-item {
      padding: var(--space-xs) var(--space-sm);
      background: rgba(255, 255, 255, 0.05);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-xs);
      color: rgba(255, 255, 255, 0.7);
      cursor: grab;
    }

    .fold-group-empty {
      font-size: var(--font-size-xs);
      color: rgba(255, 255, 255, 0.4);
      font-style: italic;
    }

    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-md);
    }

    /* Section */
    .section {
      margin-bottom: var(--space-lg);
    }

    .section-title {
      font-size: var(--font-size-xs);
      font-weight: 600;
      color: var(--color-neutral-500);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--space-sm);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .section-title::before {
      content: '';
      width: 3px;
      height: 12px;
      background: var(--color-primary-500);
      border-radius: 2px;
    }

    /* Toggle Row */
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: var(--radius-md);
      margin-bottom: var(--space-sm);
      cursor: pointer;
      transition: all 0.15s;
    }

    .toggle-row:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.1);
    }

    .toggle-row.active {
      background: rgba(6, 182, 212, 0.1);
      border-color: var(--color-primary-500);
    }

    .toggle-label {
      font-size: var(--font-size-sm);
      color: var(--color-neutral-200);
    }

    .toggle-hint {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-500);
      margin-top: 2px;
    }

    /* Custom Toggle Switch */
    .toggle-switch {
      position: relative;
      width: 36px;
      height: 20px;
      background: var(--color-neutral-700);
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .toggle-switch.active {
      background: var(--color-primary-500);
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background: white;
      border-radius: 50%;
      transition: transform 0.2s;
    }

    .toggle-switch.active::after {
      transform: translateX(16px);
    }

    /* Craft Buttons */
    .craft-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .craft-btn {
      padding: var(--space-sm) var(--space-md);
      font-size: var(--font-size-sm);
      font-weight: 500;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-neutral-300);
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .craft-btn:hover {
      background: rgba(255, 255, 255, 0.06);
      transform: translateY(-1px);
    }

    .craft-btn.gold { border-color: var(--craft-gold); color: var(--craft-gold); }
    .craft-btn.silver { border-color: var(--craft-silver); color: var(--craft-silver); }
    .craft-btn.uv { border-color: var(--craft-uv); color: var(--craft-uv); }
    .craft-btn.emboss { border-color: var(--craft-emboss); color: var(--craft-emboss); }
    .craft-btn.normal { border-color: var(--craft-normal); color: var(--craft-normal); }
    .craft-btn.displacement { border-color: var(--craft-displacement); color: var(--craft-displacement); }

    .craft-btn.gold:hover { background: rgba(212, 168, 83, 0.15); }
    .craft-btn.silver:hover { background: rgba(192, 192, 192, 0.15); }
    .craft-btn.uv:hover { background: rgba(24, 160, 251, 0.15); }
    .craft-btn.emboss:hover { background: rgba(167, 139, 250, 0.15); }
    .craft-btn.normal:hover { background: rgba(74, 222, 128, 0.15); }
    .craft-btn.displacement:hover { background: rgba(250, 140, 74, 0.15); }

    .craft-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }

    /* Slider */
    .slider-row {
      margin-bottom: var(--space-md);
    }

    .slider-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xs);
    }

    .slider-label {
      font-size: var(--font-size-xs);
      color: var(--color-neutral-400);
    }

    .slider-value {
      font-size: var(--font-size-xs);
      font-family: var(--font-mono);
      color: var(--color-primary-400);
      background: rgba(6, 182, 212, 0.1);
      padding: 2px 6px;
    }

    .slider-track {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: var(--color-neutral-700);
      border-radius: 2px;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
    }

    .slider-track::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: var(--color-primary-500);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--color-neutral-900);
    }

    /* Marked Layers List */
    .marked-list {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    /* 工艺分组样式 */
    .craft-group {
      margin-bottom: var(--space-sm);
    }
    .craft-group:last-child {
      margin-bottom: 0;
    }
    .craft-group-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-xs) var(--space-md);
      background: rgba(255, 255, 255, 0.03);
      border-radius: var(--radius-sm);
      margin-bottom: 2px;
      cursor: pointer;
      user-select: none;
      transition: background 0.15s;
    }
    .craft-group-header:hover {
      background: rgba(255, 255, 255, 0.06);
    }
    .craft-group-header-left {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
    }
    .craft-group-arrow {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: var(--color-neutral-400);
      transition: transform 0.2s;
    }
    .craft-group.collapsed .craft-group-arrow {
      transform: rotate(-90deg);
    }
    .craft-group.collapsed .craft-group-items {
      display: none;
    }
    .craft-group-header.gold {
      background: rgba(212, 168, 83, 0.15);
      border-left: 3px solid var(--craft-gold);
    }
    .craft-group-header.silver {
      background: rgba(192, 192, 192, 0.15);
      border-left: 3px solid var(--craft-silver);
    }
    .craft-group-header.uv {
      background: rgba(24, 160, 251, 0.15);
      border-left: 3px solid var(--craft-uv);
    }
    .craft-group-header.emboss {
      background: rgba(167, 139, 250, 0.15);
      border-left: 3px solid var(--craft-emboss);
    }
    .craft-group-header.normal {
      background: rgba(74, 222, 128, 0.15);
      border-left: 3px solid var(--craft-normal);
    }
    .craft-group-header.displacement {
      background: rgba(250, 140, 74, 0.15);
      border-left: 3px solid var(--craft-displacement);
    }
    .craft-group-title {
      font-size: var(--font-size-xs);
      font-weight: 500;
      color: var(--color-neutral-200);
    }
    .craft-group-count {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-400);
      background: rgba(0, 0, 0, 0.2);
      padding: 1px 6px;
      border-radius: 10px;
    }
    .craft-group-items {
      padding-left: var(--space-sm);
      border-left: 1px solid rgba(255, 255, 255, 0.06);
      margin-left: var(--space-sm);
    }

    /* 展开箭头 - 多层工艺 */
    .expand-arrow {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      color: var(--color-neutral-400);
      transition: transform 0.2s;
      flex-shrink: 0;
    }
    .expand-arrow:hover {
      color: var(--color-neutral-200);
    }
    .expand-arrow.expanded {
      transform: rotate(180deg);
    }

    /* 多层工艺小圆点标记 */
    .multi-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 16px;
      height: 16px;
      padding: 0 5px;
      margin-left: 6px;
      font-size: 10px;
      font-weight: 500;
      color: var(--color-neutral-300);
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      vertical-align: middle;
    }

    /* 多层工艺展开面板 */
    .craft-expand-panel {
      background: rgba(0, 0, 0, 0.3);
      border-radius: var(--radius-sm);
      margin: 2px 0 var(--space-xs) var(--space-md);
      padding: var(--space-xs);
    }
    .craft-expand-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: 4px var(--space-sm);
      border-radius: var(--radius-xs);
    }
    .craft-expand-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }
    .craft-expand-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .craft-expand-dot.gold { background: var(--craft-gold); }
    .craft-expand-dot.silver { background: var(--craft-silver); }
    .craft-expand-dot.uv { background: var(--craft-uv); }
    .craft-expand-dot.emboss { background: var(--craft-emboss); }
    .craft-expand-dot.normal { background: var(--craft-normal); }
    .craft-expand-name {
      flex: 1;
      font-size: var(--font-size-xs);
      color: var(--color-neutral-300);
    }
    .craft-expand-delete {
      background: none;
      border: none;
      color: var(--color-neutral-500);
      cursor: pointer;
      font-size: 14px;
      padding: 0 4px;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .craft-expand-item:hover .craft-expand-delete {
      opacity: 1;
    }
    .craft-expand-delete:hover {
      color: var(--color-error);
    }

    .marked-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm) var(--space-md);
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
      cursor: pointer;
      transition: background 0.15s;
    }

    .marked-item:last-child { border-bottom: none; }
    .marked-item:hover { background: rgba(255, 255, 255, 0.03); }
    .marked-item.selected { background: rgba(6, 182, 212, 0.1); }

    .marked-item-name {
      flex: 1;
      font-size: var(--font-size-xs);
      color: var(--color-neutral-300);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .marked-item-tag {
      font-size: var(--font-size-micro);
      padding: 2px 6px;
      border-radius: var(--radius-sm);
    }

    .marked-item-tag.gold { background: rgba(212, 168, 83, 0.2); color: var(--craft-gold); }
    .marked-item-tag.silver { background: rgba(192, 192, 192, 0.2); color: var(--craft-silver); }
    .marked-item-tag.uv { background: rgba(24, 160, 251, 0.2); color: var(--craft-uv); }
    .marked-item-tag.emboss { background: rgba(167, 139, 250, 0.2); color: var(--craft-emboss); }
    .marked-item-tag.normal { background: rgba(74, 222, 128, 0.2); color: var(--craft-normal); }

    /* 多层工艺标签 - 斜线栅格样式 */
    .marked-item-tag.multi {
      position: relative;
      background: linear-gradient(135deg,
        rgba(212, 168, 83, 0.3) 0%,
        rgba(74, 222, 128, 0.3) 50%,
        rgba(167, 139, 250, 0.3) 100%);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
      overflow: hidden;
    }

    .marked-item-tag.multi::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        45deg,
        transparent,
        transparent 2px,
        rgba(255,255,255,0.1) 2px,
        rgba(255,255,255,0.1) 4px
      );
      pointer-events: none;
    }

    .craft-icons {
      display: flex;
      gap: 2px;
      margin-left: 4px;
    }

    .craft-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    .craft-dot.gold { background: var(--craft-gold); }
    .craft-dot.silver { background: var(--craft-silver); }
    .craft-dot.uv { background: var(--craft-uv); }
    .craft-dot.emboss { background: var(--craft-emboss); }
    .craft-dot.normal { background: var(--craft-normal); }
    .craft-dot.displacement { background: var(--craft-displacement); }

    /* Normal Map Preview Styles */
    .normal-preview-container {
      background: rgba(0, 0, 0, 0.3);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .normal-preview-split {
      display: flex;
      gap: var(--space-md);
      justify-content: center;
    }

    .preview-pane {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-xs);
    }

    .preview-pane canvas {
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: repeating-conic-gradient(
        rgba(255,255,255,0.03) 0% 25%,
        rgba(0,0,0,0.2) 0% 50%
      ) 50% / 12px 12px;
      max-width: 120px;
      max-height: 120px;
      object-fit: contain;
    }

    .preview-label {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-500);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .algorithm-selector {
      display: flex;
      gap: var(--space-xs);
      margin-bottom: var(--space-xs);
    }

    .algo-btn {
      flex: 1;
      padding: var(--space-sm) var(--space-md);
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-md);
      color: var(--color-neutral-400);
      font-size: var(--font-size-xs);
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .algo-btn:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.12);
    }

    .algo-btn.active {
      background: rgba(6, 182, 212, 0.15);
      border-color: var(--color-primary-500);
      color: var(--color-primary-400);
    }

    .algo-hint {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-600);
      text-align: center;
    }

    /* ============================================
       工艺调节面板 - 四列布局
       ============================================ */
    .craft-panel-container {
      display: flex;
      gap: var(--space-sm);
      overflow-x: auto;
      padding-bottom: var(--space-sm);
    }

    .craft-column {
      flex: 1;
      min-width: 200px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: var(--space-sm);
    }

    .craft-column-header {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding-bottom: var(--space-sm);
      margin-bottom: var(--space-sm);
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .craft-column-icon {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .craft-column-icon.normal { background: rgba(74, 222, 128, 0.2); }
    .craft-column-icon.emboss { background: rgba(167, 139, 250, 0.2); }
    .craft-column-icon.metal { background: rgba(212, 168, 83, 0.2); }
    .craft-column-icon.uv { background: rgba(24, 160, 251, 0.2); }

    .craft-column-title {
      font-size: var(--font-size-xs);
      font-weight: 500;
      color: var(--color-neutral-200);
    }

    .craft-column-preview {
      width: 100%;
      aspect-ratio: 1;
      background: repeating-conic-gradient(
        rgba(255,255,255,0.03) 0% 25%,
        rgba(0,0,0,0.2) 0% 50%
      ) 50% / 12px 12px;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin-bottom: var(--space-sm);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .craft-column-preview canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    /* 工艺列内的滑块样式 */
    .craft-slider-row {
      margin-bottom: var(--space-sm);
    }

    .craft-slider-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .craft-slider-label {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-400);
    }

    .craft-slider-value {
      font-size: var(--font-size-micro);
      color: var(--color-primary-400);
      font-family: monospace;
    }

    .craft-slider-track {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      outline: none;
    }

    .craft-slider-track::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: var(--color-primary-500);
      border-radius: 50%;
      cursor: pointer;
    }

    /* 工艺列内的选择器样式 */
    .craft-select {
      width: 100%;
      padding: 6px 8px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      color: var(--color-neutral-300);
      font-size: var(--font-size-micro);
      cursor: pointer;
      margin-bottom: var(--space-sm);
    }

    .craft-select:focus {
      outline: none;
      border-color: var(--color-primary-500);
    }

    /* 工艺列内的小按钮组 */
    .craft-btn-group {
      display: flex;
      gap: 4px;
      margin-bottom: var(--space-sm);
    }

    .craft-mini-btn {
      flex: 1;
      padding: 4px 6px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      color: var(--color-neutral-400);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .craft-mini-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .craft-mini-btn.active {
      background: rgba(6, 182, 212, 0.2);
      border-color: var(--color-primary-500);
      color: var(--color-primary-400);
    }

    /* ============================================
       新工艺面板样式 - N Panel Layout
    ============================================ */
    .craft-type-selector {
      margin-bottom: var(--space-md);
    }

    /* 工艺类型按钮组 */
    .craft-type-buttons {
      display: flex;
      gap: var(--space-xs);
      flex-wrap: wrap;
      margin-top: var(--space-sm);
      padding: var(--space-sm);
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .craft-type-btn {
      flex: 1;
      min-width: 80px;
      padding: var(--space-xs) var(--space-sm);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      color: var(--color-neutral-300);
      font-size: var(--font-size-xs);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .craft-type-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .craft-type-btn.active {
      background: rgba(6, 182, 212, 0.2);
      border-color: var(--color-primary-500);
      color: var(--color-primary-400);
    }

    /* UV 区域网格 */
    .uv-regions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: var(--space-xs);
      max-height: 300px;
      overflow-y: auto;
    }

    .uv-region-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .uv-region-item:hover {
      border-color: var(--color-primary-500);
      transform: scale(1.05);
    }

    .uv-region-item canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .uv-region-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 9px;
      padding: 2px 4px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* 批量标记选项 */
    .batch-mark-options {
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: var(--space-sm);
    }

    .batch-option-row {
      margin-bottom: var(--space-xs);
    }

    .batch-checkbox {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      cursor: pointer;
      padding: var(--space-xs);
      border-radius: var(--radius-sm);
      transition: background 0.2s ease;
    }

    .batch-checkbox:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .batch-checkbox input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .batch-checkbox span {
      font-size: var(--font-size-xs);
      color: var(--color-neutral-300);
    }

    .craft-type-select {
      width: 100%;
      padding: var(--space-sm);
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-neutral-200);
      font-size: var(--font-size-sm);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .craft-type-select:hover {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(0, 0, 0, 0.4);
    }

    .craft-type-select:focus {
      outline: none;
      border-color: var(--color-primary-500);
      box-shadow: 0 0 0 2px rgba(6, 182, 212, 0.1);
    }

    /* 工艺参数面板容器 */
    .craft-params-container {
      flex: 1;
      overflow-y: scroll;
      min-height: 0;
    }

    .craft-param-panel {
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      min-height: calc(100% + 1px);
    }

    .param-section {
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: var(--space-md);
    }

    .section-title {
      font-size: var(--font-size-xs);
      font-weight: 600;
      color: var(--color-neutral-300);
      margin-bottom: var(--space-sm);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .normal-layer-selector {
      display: flex;
      gap: var(--space-xs);
      margin-bottom: var(--space-md);
    }

    .normal-layer-selector select {
      flex: 1;
      padding: var(--space-sm);
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-neutral-300);
      font-size: var(--font-size-xs);
      cursor: pointer;
    }

    .normal-layer-selector select:focus {
      outline: none;
      border-color: var(--color-primary-500);
    }

    /* 预览区域样式 */
    .preview-split {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--space-sm);
    }

    .preview-single {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: var(--space-sm);
    }

    .preview-pane {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }

    .preview-label {
      font-size: 10px;
      color: var(--color-neutral-400);
      text-align: center;
      font-weight: 500;
    }

    .preview-pane canvas,
    .preview-single canvas {
      width: 100%;
      height: auto;
      border-radius: var(--radius-sm);
      background: repeating-conic-gradient(
        rgba(255, 255, 255, 0.03) 0% 25%,
        rgba(0, 0, 0, 0.03) 0% 50%
      ) 50% / 12px 12px;
    }

    .refresh-btn {
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-neutral-400);
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s;
    }

    .refresh-btn:hover {
      background: rgba(6, 182, 212, 0.1);
      border-color: var(--color-primary-500);
      color: var(--color-primary-400);
    }

    .preset-selector {
      display: flex;
      gap: var(--space-xs);
      margin-bottom: var(--space-sm);
    }

    .preset-selector select {
      flex: 1;
      padding: var(--space-sm);
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-neutral-300);
      font-size: var(--font-size-xs);
    }

    .preset-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-xs);
      margin-bottom: var(--space-sm);
    }

    .preset-btn-item {
      padding: var(--space-xs) var(--space-sm);
      font-size: var(--font-size-xs);
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-neutral-400);
      cursor: pointer;
      transition: all 0.15s;
    }

    .preset-btn-item:hover {
      background: rgba(6, 182, 212, 0.1);
      border-color: rgba(6, 182, 212, 0.3);
      color: var(--color-neutral-300);
    }

    .preset-btn-item.active {
      background: rgba(6, 182, 212, 0.15);
      border-color: var(--color-primary-500);
      color: var(--color-primary-400);
    }

    .custom-presets-header {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-500);
      margin: var(--space-sm) 0 var(--space-xs);
      padding-bottom: var(--space-xs);
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .preset-btn {
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.15s;
    }

    .preset-btn:hover {
      background: rgba(6, 182, 212, 0.1);
      border-color: var(--color-primary-500);
    }

    .mode-toggle {
      display: flex;
      background: rgba(0, 0, 0, 0.3);
      border-radius: var(--radius-md);
      padding: 2px;
      margin-bottom: var(--space-xs);
    }

    .mode-btn {
      flex: 1;
      padding: var(--space-xs) var(--space-sm);
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      color: var(--color-neutral-500);
      font-size: var(--font-size-xs);
      cursor: pointer;
      transition: all 0.15s;
    }

    .mode-btn.active {
      background: var(--color-primary-500);
      color: white;
    }

    .mode-hint {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-600);
      text-align: center;
    }

    .delete-btn {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--color-neutral-500);
      cursor: pointer;
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
      transition: all 0.15s;
    }

    .delete-btn:hover {
      background: rgba(239, 68, 68, 0.2);
      color: var(--color-error);
    }

    /* ============================================
       折叠顺序面板 - Fold Order Panel
    ============================================ */
    .fold-order-panel {
      position: fixed;
      top: var(--space-md);
      right: var(--space-md);
      width: 220px;
      background: rgba(10, 15, 20, 0.82);
      border: 1px solid rgba(6, 182, 212, 0.34);
      border-radius: var(--radius-lg);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(6, 182, 212, 0.2), 0 0 22px rgba(6, 182, 212, 0.14);
      z-index: 2000;
      pointer-events: auto;
      overflow: hidden;
    }

    @supports (background: color-mix(in srgb, white 50%, transparent)) {
      .fold-order-panel {
        background:
          linear-gradient(180deg, var(--glass-tint-strong), transparent),
          var(--glass-surface-strong);
        border: 1px solid var(--glass-border-strong);
        box-shadow: var(--glass-shadow), var(--glass-glow);
      }
    }

    .fold-order-panel.minimized {
      width: auto;
    }

    .fold-order-panel.minimized .fold-order-title,
    .fold-order-panel.minimized .fold-order-content {
      display: none;
    }

    .fold-order-header {
      padding: var(--space-sm) var(--space-md);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .fold-order-actions {
      display: flex;
      gap: var(--space-xs);
    }

    .canvas-btn-danger {
      color: var(--color-error);
    }

    .fold-order-title {
      font-size: var(--font-size-sm);
      font-weight: 600;
      color: var(--color-neutral-200);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .fold-order-content {
      padding: var(--space-sm);
      max-height: 300px;
      overflow-y: auto;
    }

    /* 折叠边列表项 */
    .fold-edge-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.15s;
      margin-bottom: var(--space-xxs);
    }

    .fold-edge-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .fold-edge-item.selected {
      background: rgba(6, 182, 212, 0.15);
      border: 1px solid var(--color-primary-500);
    }

    /* 方向指示器 */
    .fold-direction-icon {
      width: 20px;
      height: 20px;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }

    .fold-direction-icon.horizontal {
      background: var(--color-primary-500);
    }

    .fold-direction-icon.vertical {
      background: #ec4899;
    }

    /* 边信息 */
    .fold-edge-info {
      flex: 1;
      min-width: 0;
    }

    .fold-edge-name {
      font-size: var(--font-size-xs);
      color: var(--color-neutral-200);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .fold-edge-type {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-500);
    }

    /* 带动关系标签 */
    .driven-label {
      font-size: var(--font-size-micro);
      color: var(--color-neutral-500);
      padding-left: 28px;
      margin-top: 2px;
      display: flex;
      align-items: center;
      gap: var(--space-xxs);
    }

    .driven-label span {
      color: var(--color-primary-400);
    }

    /* Panel Footer */
    .panel-footer {
      padding: var(--space-md);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(0, 0, 0, 0.3);
    }

    /* 参数行样式 */
    .param-row {
      margin-bottom: var(--space-md);
    }

    .param-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-xs);
    }

    .param-label {
      font-size: var(--font-size-xs);
      color: var(--color-neutral-300);
      font-weight: 500;
    }

    .param-value {
      font-size: var(--font-size-xs);
      color: var(--color-primary-400);
      font-weight: 600;
      min-width: 40px;
      text-align: right;
    }

    .param-slider {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }

    .param-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--color-primary-500);
      border-radius: 50%;
      cursor: pointer;
    }

    /* 按钮组样式 */
    .param-btn-group {
      display: flex;
      gap: var(--space-xs);
      margin-bottom: var(--space-sm);
    }

    .param-btn {
      flex: 1;
      padding: var(--space-xs) var(--space-sm);
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      color: var(--color-neutral-300);
      font-size: var(--font-size-xs);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .param-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* UV预设按钮样式 */
    .uv-preset-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .uv-preset-btn {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: var(--color-neutral-300);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .uv-preset-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .uv-preset-btn.active {
      background: rgba(59, 130, 246, 0.2);
      border-color: rgba(59, 130, 246, 0.5);
      color: #60a5fa;
    }

    .param-btn.active {
      background: rgba(6, 182, 212, 0.2);
      border-color: var(--color-primary-500);
      color: var(--color-primary-400);
    }

    /* 开关样式 */
    .param-toggle {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-sm);
      background: rgba(255, 255, 255, 0.03);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .param-toggle:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .toggle-label {
      font-size: var(--font-size-xs);
      color: var(--color-neutral-200);
      font-weight: 500;
    }

    .toggle-hint {
      font-size: 10px;
      color: var(--color-neutral-400);
      margin-top: 2px;
    }

    .toggle-switch {
      width: 40px;
      height: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      position: relative;
      transition: background 0.3s ease;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: transform 0.3s ease;
    }

    .toggle-switch.active {
      background: var(--color-primary-500);
    }

    .toggle-switch.active::after {
      transform: translateX(20px);
    }

    /* 下拉选择器样式 */
    .param-select {
      width: 100%;
      padding: var(--space-sm);
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      color: var(--color-neutral-300);
      font-size: var(--font-size-xs);
      cursor: pointer;
      margin-bottom: var(--space-sm);
    }

    .param-select:hover {
      border-color: rgba(255, 255, 255, 0.2);
    }

    .param-select:focus {
      outline: none;
      border-color: var(--color-primary-500);
    }

    /* 提示文本样式 */
    .algo-hint {
      font-size: 10px;
      color: var(--color-neutral-400);
      margin-top: var(--space-xs);
    }

    .export-btn {
      width: 100%;
      padding: var(--space-md);
      font-size: var(--font-size-md);
      font-weight: 600;
      background: linear-gradient(135deg, var(--color-primary-500), var(--color-secondary-500));
      border: none;
      border-radius: var(--radius-md);
      color: white;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
    }

    .export-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
    }

    .export-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .secondary-btn {
      width: 100%;
      padding: var(--space-sm);
      font-size: var(--font-size-sm);
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--color-neutral-300);
      cursor: pointer;
      transition: all 0.15s;
      margin-top: var(--space-sm);
    }

    .secondary-btn:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .secondary-btn.danger {
      border-color: rgba(239, 68, 68, 0.3);
      color: var(--color-error);
    }

    .secondary-btn.danger:hover {
      background: rgba(239, 68, 68, 0.1);
    }

    /* ============================================
       折叠边列表样式 - Fold Edge List
    ============================================ */
    .fold-edge-list {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
      max-height: 280px;
      overflow-y: auto;
    }

    .fold-edge-list-item {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm);
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-md);
      cursor: grab;
      transition: all 0.15s ease;
    }

    .fold-edge-list-item:hover {
      border-color: rgba(6, 182, 212, 0.3);
      background: rgba(6, 182, 212, 0.05);
    }

    .fold-edge-list-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .fold-edge-list-item.drag-over {
      border-color: var(--color-primary-400);
      border-style: dashed;
      background: rgba(6, 182, 212, 0.1);
    }

    .fold-edge-order {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--color-primary-500);
      color: white;
      font-size: 11px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .fold-edge-order.horizontal {
      background: #ec4899;
    }

    .fold-edge-order.vertical {
      background: #10b981;
    }

    .fold-edge-panels {
      flex: 1;
      font-size: var(--font-size-sm);
      color: var(--color-neutral-200);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .fold-edge-arrow {
      color: var(--color-neutral-500);
      font-size: 10px;
    }

    .fold-edge-delete {
      width: 20px;
      height: 20px;
      background: none;
      border: none;
      color: var(--color-neutral-500);
      cursor: pointer;
      border-radius: var(--radius-sm);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .fold-edge-delete:hover {
      background: rgba(239, 68, 68, 0.2);
      color: var(--color-error);
    }

    .fold-edge-empty {
      padding: var(--space-lg);
      text-align: center;
      color: var(--color-neutral-500);
      font-size: var(--font-size-xs);
    }

    /* 折叠顺序列表（一行紧凑显示） */
    .fold-sequence-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
    }

    .fold-sequence-item {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 6px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-sm);
      cursor: grab;
    }

    .fold-sequence-item:hover {
      border-color: rgba(6, 182, 212, 0.3);
    }

    .fold-sequence-item.dragging {
      opacity: 0.5;
    }

    .fold-sequence-item.drag-over {
      border-color: var(--color-primary-400);
      border-style: dashed;
    }

    .fold-seq-num {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--color-primary-500);
      color: white;
      font-size: 9px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .fold-seq-parent {
      font-size: 10px;
      font-weight: 500;
      color: var(--color-neutral-200);
      padding: 1px 4px;
      background: rgba(6, 182, 212, 0.15);
      border-radius: 2px;
    }

    .fold-seq-arrow {
      font-size: 9px;
      color: var(--color-neutral-600);
    }

    .fold-seq-children {
      display: flex;
      gap: 3px;
      flex-wrap: wrap;
      flex: 1;
    }

    .fold-seq-child {
      font-size: 9px;
      color: var(--color-neutral-400);
      padding: 1px 4px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 2px;
    }

    .fold-sequence-empty {
      padding: 8px;
      text-align: center;
      color: var(--color-neutral-600);
      font-size: 9px;
    }

    /* PS图层形式的折叠顺序 */
    .fold-layer-tree {
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-md);
      padding: var(--space-xs);
      max-height: 300px;
      overflow-y: auto;
    }

    .fold-layer-item {
      display: flex;
      align-items: center;
      padding: 4px 6px;
      border-radius: 3px;
      cursor: grab;
      transition: background 0.1s;
      user-select: none;
    }

    .fold-layer-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .fold-layer-item.root {
      background: rgba(6, 182, 212, 0.1);
    }

    .fold-layer-item.dragging {
      opacity: 0.5;
    }

    .fold-layer-item.drag-over {
      background: rgba(6, 182, 212, 0.2);
    }

    .fold-layer-indent {
      color: var(--color-neutral-600);
      font-family: var(--font-mono);
      font-size: 11px;
      white-space: pre;
    }

    .fold-layer-icon {
      margin-right: 4px;
      font-size: 10px;
    }

    .fold-layer-name {
      flex: 1;
      font-size: 11px;
      font-family: var(--font-mono);
    }

    .fold-layer-name.root {
      color: var(--color-primary-400);
      font-weight: 500;
    }

    .fold-layer-badge {
      font-size: 9px;
      color: var(--color-neutral-500);
      margin-left: 4px;
    }

    .fold-layer-empty {
      padding: 12px;
      text-align: center;
      color: var(--color-neutral-600);
      font-size: 10px;
    }

    .fold-layer-num {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--color-primary-500);
      color: white;
      font-size: 9px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-right: 6px;
    }

    .fold-layer-arrow {
      font-size: 9px;
      color: var(--color-neutral-600);
      margin: 0 4px;
    }

    .fold-layer-child {
      font-size: 9px;
      color: var(--color-neutral-400);
      padding: 1px 4px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 2px;
      margin-right: 2px;
    }

    /* 带动关系树样式 */
    .driven-tree-container {
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-md);
      padding: var(--space-sm);
      max-height: 200px;
      overflow-y: auto;
    }

    .driven-tree-node {
      font-family: var(--font-mono);
      font-size: 11px;
      line-height: 1.8;
      color: var(--color-neutral-300);
    }

    .driven-tree-node.root {
      color: var(--color-primary-400);
      font-weight: 600;
    }

    .driven-tree-indent {
      color: var(--color-neutral-600);
    }

    .driven-tree-icon {
      margin-right: 4px;
    }

    /* 带动关系编辑器样式 */
    .driven-editor {
      display: flex;
      align-items: flex-start;
      gap: var(--space-xs);
    }

    .driven-select {
      flex: 1;
      min-width: 60px;
      padding: var(--space-xs) var(--space-sm);
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      color: var(--color-neutral-200);
      font-size: var(--font-size-xs);
      cursor: pointer;
    }

    .driven-select[multiple] {
      height: auto;
      min-height: 54px;
    }

    .driven-select option {
      padding: 4px 8px;
    }

    .driven-select option:checked {
      background: rgba(6, 182, 212, 0.3);
    }

    .driven-select:focus {
      outline: none;
      border-color: var(--color-primary-500);
    }

    .driven-arrow {
      font-size: var(--font-size-xs);
      color: var(--color-neutral-500);
      padding-top: 6px;
    }

    .driven-add-btn {
      width: 24px;
      height: 24px;
      background: var(--color-primary-500);
      border: none;
      border-radius: var(--radius-sm);
      color: white;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      flex-shrink: 0;
    }

    .driven-add-btn:hover {
      background: var(--color-primary-400);
    }

    .driven-hint {
      font-size: 9px;
      color: var(--color-neutral-600);
      margin-top: 4px;
    }

    /* 子面板可点击标签 */
    .driven-child-tags {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      padding: 4px;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: var(--radius-sm);
      min-height: 28px;
      max-height: 60px;
      overflow-y: auto;
    }

    .driven-child-tag {
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      font-size: 10px;
      color: var(--color-neutral-400);
      cursor: pointer;
      transition: all 0.1s;
      user-select: none;
    }

    .driven-child-tag:hover {
      border-color: rgba(6, 182, 212, 0.4);
    }

    .driven-child-tag.selected {
      background: rgba(6, 182, 212, 0.25);
      border-color: var(--color-primary-500);
      color: var(--color-primary-300);
    }

    /* 可编辑的带动关系树节点 */
    .driven-tree-node-editable {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding: 4px 6px;
      margin: 2px 0;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.15s;
    }

    .driven-tree-node-editable:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .driven-tree-node-editable.root {
      background: rgba(6, 182, 212, 0.1);
    }

    .driven-node-name {
      flex: 1;
      font-size: 11px;
      font-family: var(--font-mono);
    }

    .driven-node-delete {
      width: 16px;
      height: 16px;
      background: none;
      border: none;
      color: var(--color-neutral-600);
      cursor: pointer;
      font-size: 12px;
      opacity: 0;
      transition: all 0.15s;
    }

    .driven-tree-node-editable:hover .driven-node-delete {
      opacity: 1;
    }

    .driven-node-delete:hover {
      color: var(--color-error);
    }

    /* PS风格组列表 */
    .driven-group {
      margin-bottom: 4px;
    }

    .driven-group-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: rgba(6, 182, 212, 0.1);
      border: 1px solid rgba(6, 182, 212, 0.3);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .driven-group-header:hover {
      background: rgba(6, 182, 212, 0.15);
    }

    .driven-group-arrow {
      background: none;
      border: none;
      padding: 0;
      cursor: pointer;
      line-height: 1;
    }

    .driven-group-header {
      background: rgba(10, 15, 20, 0.65);
      border: 1px solid rgba(6, 182, 212, 0.22);
      backdrop-filter: blur(14px) saturate(160%);
      -webkit-backdrop-filter: blur(14px) saturate(160%);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(6, 182, 212, 0.12);
    }

    .driven-group-header:hover {
      background: rgba(10, 15, 20, 0.72);
      border-color: rgba(6, 182, 212, 0.3);
    }

    .driven-group-header.drag-over {
      border-color: rgba(6, 182, 212, 0.42);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.32), 0 0 0 1px rgba(6, 182, 212, 0.22), 0 0 14px rgba(6, 182, 212, 0.12);
    }

    .driven-group-header.dragging {
      opacity: 0.75;
    }

    .driven-group-arrow {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-sm);
      color: var(--color-neutral-300);
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
      font-size: 12px;
      font-weight: 700;
    }

    .driven-group-arrow:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(6, 182, 212, 0.22);
      color: var(--color-primary-300);
    }

    .driven-group-arrow.expanded {
      transform: rotate(90deg);
    }

    .driven-group-icon {
      font-size: 12px;
    }

    .driven-group-name {
      flex: 1;
      font-size: 11px;
      font-weight: 500;
      color: var(--color-primary-400);
    }

    .driven-group-count {
      font-size: 9px;
      color: var(--color-neutral-500);
      background: rgba(0,0,0,0.3);
      padding: 1px 5px;
      border-radius: 8px;
    }

    .driven-group-delete {
      background: none;
      border: none;
      color: var(--color-neutral-500);
      cursor: pointer;
      font-size: 12px;
      padding: 2px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .driven-group-header:hover .driven-group-delete {
      opacity: 1;
    }

    .driven-group-delete:hover {
      color: var(--color-error);
    }

    .driven-group-content {
      margin-left: 16px;
      border-left: 1px solid rgba(255,255,255,0.1);
    }

    .driven-group-content {
      padding-left: var(--space-xs);
      margin-top: var(--space-xxs);
      border-left: 1px solid rgba(6, 182, 212, 0.18);
    }

    .driven-group-content-glass {
      padding: var(--space-xs);
      border-radius: var(--radius-md);
      background: rgba(10, 15, 20, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(14px) saturate(160%);
      -webkit-backdrop-filter: blur(14px) saturate(160%);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(6, 182, 212, 0.1);
    }

    .driven-select {
      display: none;
    }

    .driven-dropdown {
      position: relative;
      flex: 1;
      min-width: 0;
    }

    .driven-dropdown-trigger {
      width: 100%;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-xs);
      padding: 0 var(--space-sm);
      border-radius: var(--radius-md);
      background: rgba(10, 15, 20, 0.78);
      border: 1px solid rgba(6, 182, 212, 0.22);
      color: var(--color-neutral-200);
      cursor: pointer;
      backdrop-filter: blur(14px) saturate(160%);
      -webkit-backdrop-filter: blur(14px) saturate(160%);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.32), 0 0 0 1px rgba(6, 182, 212, 0.1);
      transition: border-color 0.15s ease, background 0.15s ease;
      font-size: 11px;
    }

    .driven-dropdown-trigger:hover {
      background: rgba(10, 15, 20, 0.84);
      border-color: rgba(6, 182, 212, 0.28);
    }

    .driven-dropdown-trigger[aria-expanded="true"] {
      border-color: rgba(6, 182, 212, 0.34);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.36), 0 0 0 1px rgba(6, 182, 212, 0.16), 0 0 14px rgba(6, 182, 212, 0.1);
    }

    .driven-dropdown-label {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--color-neutral-200);
    }

    .driven-dropdown-label.placeholder {
      color: var(--color-neutral-500);
    }

    .driven-dropdown-icon {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--color-neutral-300);
      font-weight: 700;
      transition: transform 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }

    .driven-dropdown-trigger[aria-expanded="true"] .driven-dropdown-icon {
      transform: rotate(180deg);
      border-color: rgba(6, 182, 212, 0.22);
      color: var(--color-primary-300);
    }

    .driven-dropdown-menu {
      position: absolute;
      top: calc(100% + var(--space-xs));
      left: 0;
      right: 0;
      z-index: 5000;
      padding: var(--space-xs);
      border-radius: var(--radius-md);
      background: rgba(10, 15, 20, 0.88);
      border: 1px solid rgba(6, 182, 212, 0.22);
      backdrop-filter: blur(18px) saturate(170%);
      -webkit-backdrop-filter: blur(18px) saturate(170%);
      box-shadow: 0 18px 44px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(6, 182, 212, 0.12);
      display: none;
      max-height: 220px;
      overflow: auto;
    }

    .driven-dropdown-menu.open {
      display: block;
    }

    .driven-dropdown-item {
      height: 26px;
      display: flex;
      align-items: center;
      padding: 0 var(--space-sm);
      border-radius: var(--radius-sm);
      cursor: pointer;
      color: var(--color-neutral-200);
      font-size: 11px;
      border: 1px solid transparent;
      transition: background 0.12s ease, border-color 0.12s ease, color 0.12s ease;
    }

    .driven-dropdown-item:hover {
      background: rgba(255, 255, 255, 0.04);
      border-color: rgba(6, 182, 212, 0.14);
      color: var(--color-neutral-100);
    }

    .driven-dropdown-item.selected {
      background: rgba(6, 182, 212, 0.14);
      border-color: rgba(6, 182, 212, 0.22);
      color: var(--color-neutral-50);
    }

    .driven-dropdown-item.disabled {
      color: var(--color-neutral-600);
      cursor: not-allowed;
      pointer-events: none;
    }

    .driven-child-item {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      cursor: grab;
      transition: background 0.1s;
    }

    .driven-child-item:hover {
      background: rgba(255,255,255,0.05);
    }

    .driven-child-item.dragging {
      opacity: 0.5;
    }

    .driven-child-item.drag-over {
      background: rgba(6, 182, 212, 0.15);
    }

    .driven-child-indent {
      font-size: 10px;
      color: var(--color-neutral-600);
      font-family: var(--font-mono);
    }

    .driven-child-name {
      flex: 1;
      font-size: 10px;
      color: var(--color-neutral-300);
    }

    .driven-child-delete {
      background: none;
      border: none;
      color: var(--color-neutral-600);
      cursor: pointer;
      font-size: 10px;
      padding: 2px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .driven-child-item:hover .driven-child-delete {
      opacity: 1;
    }

    .driven-child-delete:hover {
      color: var(--color-error);
    }

    .driven-child-item.has-children {
      background: rgba(6, 182, 212, 0.05);
    }

    .driven-child-item.has-children .driven-child-name {
      color: var(--color-primary-400);
      font-weight: 500;
    }

    .driven-child-badge {
      font-size: 8px;
      color: var(--color-neutral-500);
      background: rgba(0,0,0,0.3);
      padding: 1px 4px;
      border-radius: 6px;
      margin-left: 4px;
    }

    .driven-nested-content {
      border-left: 1px dashed rgba(6, 182, 212, 0.3);
    }

    .driven-child-item.nested {
      font-size: 9px;
    }

    .driven-child-item.nested .driven-child-name {
      font-size: 9px;
    }
</style>
<script>
    // ============================================================================
    // 专业级法线贴图生成器 - Materialize 级别质量
    // 使用 Scharr 算法，支持强度、模糊、锐度调节
    // ============================================================================

    // 默认预设 - 包含所有参数的完整定义
    const NORMAL_PRESETS = {
      'default': {
        name: '默认', strength: 2.0, blurRadius: 0, sharpness: 1.0, contrast: 1.0, brightness: 0, edgeSoftness: 0.0,
        invertY: false, useGrayscale: false, algorithm: 'scharr',
        weightR: 0.299, weightG: 0.587, weightB: 0.114, weightC: 0.0, weightM: 0.0, weightY: 0.0
      },
      'subtle': {
        name: '细腻', strength: 1.0, blurRadius: 1, sharpness: 0.8, contrast: 1.0, brightness: 0, edgeSoftness: 0.5,
        invertY: false, useGrayscale: false, algorithm: 'scharr',
        weightR: 0.299, weightG: 0.587, weightB: 0.114, weightC: 0.0, weightM: 0.0, weightY: 0.0
      },
      'medium': {
        name: '中等', strength: 3.0, blurRadius: 0, sharpness: 1.2, contrast: 1.1, brightness: 0, edgeSoftness: 0.0,
        invertY: false, useGrayscale: false, algorithm: 'scharr',
        weightR: 0.299, weightG: 0.587, weightB: 0.114, weightC: 0.0, weightM: 0.0, weightY: 0.0
      },
      'strong': {
        name: '强烈', strength: 8.0, blurRadius: 0, sharpness: 1.5, contrast: 1.2, brightness: 0, edgeSoftness: 0.0,
        invertY: false, useGrayscale: false, algorithm: 'scharr',
        weightR: 0.299, weightG: 0.587, weightB: 0.114, weightC: 0.0, weightM: 0.0, weightY: 0.0
      },
      'emboss': {
        name: '浮雕', strength: 4.0, blurRadius: 1, sharpness: 2.0, contrast: 1.5, brightness: 0, edgeSoftness: 1.0,
        invertY: false, useGrayscale: false, algorithm: 'sobel',
        weightR: 0.299, weightG: 0.587, weightB: 0.114, weightC: 0.0, weightM: 0.0, weightY: 0.0
      },
      'photo': {
        name: '照片转法线', strength: 5.0, blurRadius: 1, sharpness: 1.2, contrast: 1.0, brightness: 0, edgeSoftness: 0.0,
        invertY: false, useGrayscale: true, algorithm: 'scharr',
        weightR: 0.299, weightG: 0.587, weightB: 0.114, weightC: 0.0, weightM: 0.0, weightY: 0.0
      }
    };

    // 全局法线生成参数
    let normalMapSettings = {
      strength: 2.0,
      blurRadius: 0,
      sharpness: 1.0,
      contrast: 1.0,
      brightness: 0,
      edgeSoftness: 0.0,
      invertY: true,  // 改为 true，保持图像法线的原始方向
      useGrayscale: false, // 新增：是否使用灰度作为高度
      algorithm: 'scharr',
      // Advanced Grayscale Weights (Default: Standard Luminance)
      weightR: 0.299,
      weightG: 0.587,
      weightB: 0.114,
      weightC: 0.0,
      weightM: 0.0,
      weightY: 0.0
    };

    // 每个图层的独立设置 { layerId: { ...settings } }
    let layerNormalSettings = {};

    // 当前模式: 'global' 或 'individual'
    let normalSettingsMode = 'global';

    // 当前选中的预设
    let currentPreset = 'default';

    // 用户自定义预设
    let customPresets = {};

    // Scharr 算子 - 比 Sobel 更精确，更好的旋转对称性
    const SCHARR_X = [[-3, 0, 3], [-10, 0, 10], [-3, 0, 3]];
    const SCHARR_Y = [[-3, -10, -3], [0, 0, 0], [3, 10, 3]];

    // ============================================
    // Perlin Noise - 世界级噪声算法
    // ============================================
    class PerlinNoise {
      constructor(seed = 0) {
        this.permutation = [];
        for (let i = 0; i < 256; i++) {
          this.permutation[i] = i;
        }
        // Fisher-Yates shuffle with seed
        let random = seed;
        for (let i = 255; i > 0; i--) {
          random = (random * 9301 + 49297) % 233280;
          const j = Math.floor((random / 233280) * (i + 1));
          [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
        }
        this.p = [...this.permutation, ...this.permutation];
      }

      fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }

      lerp(t, a, b) {
        return a + t * (b - a);
      }

      grad(hash, x, y) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
      }

      noise(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = this.fade(x);
        const v = this.fade(y);
        const a = this.p[X] + Y;
        const b = this.p[X + 1] + Y;
        return this.lerp(v,
          this.lerp(u, this.grad(this.p[a], x, y), this.grad(this.p[b], x - 1, y)),
          this.lerp(u, this.grad(this.p[a + 1], x, y - 1), this.grad(this.p[b + 1], x - 1, y - 1))
        );
      }

      octaveNoise(x, y, octaves, persistence) {
        let total = 0;
        let frequency = 1;
        let amplitude = 1;
        let maxValue = 0;
        for (let i = 0; i < octaves; i++) {
          total += this.noise(x * frequency, y * frequency) * amplitude;
          maxValue += amplitude;
          amplitude *= persistence;
          frequency *= 2;
        }
        return total / maxValue;
      }
    }

    const perlin = new PerlinNoise(12345);

    // ============================================
    // 高斯模糊函数
    // ============================================
    function gaussianBlur(data, width, height, radius) {
      // 生成高斯核
      const kernelSize = radius * 2 + 1;
      const kernel = new Float32Array(kernelSize);
      const sigma = radius / 3.0;
      let sum = 0;

      for (let i = 0; i < kernelSize; i++) {
        const x = i - radius;
        kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
        sum += kernel[i];
      }

      // 归一化核
      for (let i = 0; i < kernelSize; i++) {
        kernel[i] /= sum;
      }

      // 水平模糊
      const temp = new Float32Array(width * height);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let value = 0;
          for (let k = 0; k < kernelSize; k++) {
            const sx = x + k - radius;
            if (sx >= 0 && sx < width) {
              value += data[y * width + sx] * kernel[k];
            }
          }
          temp[y * width + x] = value;
        }
      }

      // 垂直模糊
      const result = new Float32Array(width * height);
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let value = 0;
          for (let k = 0; k < kernelSize; k++) {
            const sy = y + k - radius;
            if (sy >= 0 && sy < height) {
              value += temp[sy * width + x] * kernel[k];
            }
          }
          result[y * width + x] = value;
        }
      }

      return result;
    }

    // ============================================
    // SDF (Signed Distance Field) 生成器
    // ============================================
    const SDF_INF = 1e9;

    // 欧几里得距离变换 - 两遍扫描法
    function generateSDF(imageData, width, height, config) {
      // 生成凹凸贴图 - 保持原图形边界不变
      const spread = config.spread || 10.0;
      const threshold = config.threshold || 128;
      const mode = config.mode || 'shrink';
      const profile = config.profile || 'smoothstep';
      const softness = config.softness || 1.0;
      const rippleCount = config.rippleCount || 3;
      const rippleWidth = config.rippleWidth || 0.5;
      const rippleDash = config.rippleDash || 0;

      // 1. 提取 Alpha 通道并计算距离场
      const grid = new Float32Array(width * height);
      const INF = 1e9;

      // 初始化：根据模式设置起点
      for (let i = 0; i < width * height; i++) {
        const alpha = imageData[i * 4 + 3];
        const isObject = alpha > threshold;

        if (mode === 'expand') {
          // Expand 模式：从物体向外扩展
          grid[i] = isObject ? 0 : INF;
        } else {
          // Shrink 模式：从边缘向内收缩
          grid[i] = isObject ? INF : 0;
        }
      }

      // 前向扫描
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (grid[idx] === 0) continue;
          let minDist = grid[idx];
          if (x > 0) minDist = Math.min(minDist, grid[idx - 1] + 1);
          if (y > 0) minDist = Math.min(minDist, grid[idx - width] + 1);
          if (x > 0 && y > 0) minDist = Math.min(minDist, grid[idx - width - 1] + 1.414);
          if (x < width - 1 && y > 0) minDist = Math.min(minDist, grid[idx - width + 1] + 1.414);
          grid[idx] = minDist;
        }
      }

      // 后向扫描
      for (let y = height - 1; y >= 0; y--) {
        for (let x = width - 1; x >= 0; x--) {
          const idx = y * width + x;
          let minDist = grid[idx];
          if (x < width - 1) minDist = Math.min(minDist, grid[idx + 1] + 1);
          if (y < height - 1) minDist = Math.min(minDist, grid[idx + width] + 1);
          if (x < width - 1 && y < height - 1) minDist = Math.min(minDist, grid[idx + width + 1] + 1.414);
          if (x > 0 && y < height - 1) minDist = Math.min(minDist, grid[idx + width - 1] + 1.414);
          grid[idx] = minDist;
        }
      }

      // 2. 对距离场应用多次模糊（极致平滑，消除尖刺）
      const blurRadius = Math.max(2, Math.floor(softness * 5));
      let blurred = gaussianBlur(grid, width, height, blurRadius);
      // 二次模糊，进一步平滑
      blurred = gaussianBlur(blurred, width, height, Math.floor(blurRadius * 0.5));

      // 3. 生成高度图 - 根据模式处理
      const output = new Uint8ClampedArray(width * height * 4);
      for (let i = 0; i < width * height; i++) {
        const alpha = imageData[i * 4 + 3];
        const isObject = alpha > threshold;

        // 计算距离（需要在使用前声明）
        const dist = blurred[i];

        // 根据模式决定是否渲染
        let shouldRender = false;
        if (mode === 'expand') {
          // Expand 模式：只渲染物体内部和扩展区域
          shouldRender = isObject || (dist < spread);
        } else {
          // Shrink 模式：只渲染物体内部
          shouldRender = isObject;
        }

        if (!shouldRender) {
          // 不渲染的区域：完全透明
          output[i * 4] = 0;
          output[i * 4 + 1] = 0;
          output[i * 4 + 2] = 0;
          output[i * 4 + 3] = 0; // 透明！
          continue;
        }

        // 计算高度
        let t;

        if (mode === 'expand') {
          // Expand 模式：从物体向外扩展
          if (dist >= spread) {
            // 超出扩展范围：完全透明
            t = 0.0;
          } else {
            // 物体内部和扩展区域：都有渐变
            t = 1.0 - (dist / spread);
          }
        } else {
          // Shrink 模式：从边缘向内收缩
          if (dist >= spread) {
            t = 1.0; // 中心平坦区域：最大高度
          } else {
            t = dist / spread; // 边缘=0，向内递增
          }
        }

        // 应用 Profile 曲线
        let z = t;
        if (profile === 'smoothstep') {
          z = t * t * (3 - 2 * t);
        } else if (profile === 'linear') {
          z = t;
        } else if (profile === 'pillow') {
          // 多层枕状浮雕：一圈一圈的波纹效果
          // 使用 t (0-1) 来控制波纹，确保波纹数量正确
          
          // 基础高度：平滑上升
          const baseHeight = t * t * (3 - 2 * t);
          
          // 波纹分量：使用归一化的 t 生成波纹
          // 这样波纹数量就只跟 rippleCount 有关，跟 spread 无关
          // phase = t * rippleCount * 2PI
          const phase = t * rippleCount * Math.PI * 2;
          
          // 计算正弦波，映射到 [0, 1]
          let wave = (Math.sin(phase) + 1) / 2;
          
          // 应用波纹粗细
          const exponent = 1.0 / Math.max(0.1, rippleWidth);
          wave = Math.pow(wave, exponent);
          
          // 虚线效果 (Beads/Dash)
          if (rippleDash > 0) {
             const x = i % width;
             const y = Math.floor(i / width);
             
             // 简单的网格图案作为虚线遮罩
             const dashSize = 5 + rippleDash * 20;
             const dashMask = (Math.sin(x / dashSize) * Math.sin(y / dashSize) + 1) / 2;
             
             // 阈值化
             if (dashMask < 0.5) wave = 0;
          }
          
          // 最终高度：基础高度 * 波纹
          // 这样保证了 t=0 时 z=0，形状边缘不会变形
          // 同时波纹会在整个高度范围内分布
          z = baseHeight * (0.2 + 0.8 * wave);
        }

        const value = Math.floor(z * 255);
        output[i * 4] = value;
        output[i * 4 + 1] = value;
        output[i * 4 + 2] = value;
        output[i * 4 + 3] = value > 0 ? 255 : 0; // 修复：value=0 时透明
      }
      return output;
    }

    // ============================================
    // 金属纹理生成器
    // ============================================
    function generateMetalTexture(data, width, height, settings) {
      const texture = settings.texture;
      const intensity = settings.intensity;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          let value = 128; // 基础粗糙度

          if (texture === 'mirror') {
            value = 30; // 低粗糙度 = 高光泽
          } else if (texture === 'matte') {
            // 磨砂：使用 Perlin Noise 生成细腻噪点
            const noise = perlin.octaveNoise(x * 0.1, y * 0.1, 3, 0.5);
            value = 150 + noise * intensity * 100;
          } else if (texture === 'brushed') {
            // 拉丝：使用 Perlin Noise + 各向异性滤波
            // 模拟真实的金属拉丝纹理
            const scale = 0.05; // 噪声缩放
            const anisotropy = 20; // 各向异性比例（水平拉伸）

            // 使用 Perlin Noise 生成基础纹理
            const noise = perlin.octaveNoise(x * scale, y * scale * anisotropy, 4, 0.5);

            // 添加细微的水平条纹
            const stripe = Math.sin(y * 0.1) * 0.1;

            // 混合噪声和条纹
            const combined = (noise * 0.7 + stripe * 0.3) * intensity;
            value = 100 + combined * 100;
          } else if (texture === 'satin') {
            // 缎面：使用多层 Perlin Noise 生成细腻纹理
            const noise = perlin.octaveNoise(x * 0.15, y * 0.15, 5, 0.6);
            value = 120 + noise * intensity * 80;
          }

          value = Math.max(0, Math.min(255, value));
          data[idx] = data[idx + 1] = data[idx + 2] = value;
          data[idx + 3] = 255;
        }
      }
    }

    // ============================================
    // 高级纹理生成器 - 支持多种噪点效果
    // ============================================
    function generateAdvancedTexture(width, height, settings) {
      const output = new Uint8ClampedArray(width * height * 4);
      const {
        type = 'none',
        intensity = 0.5,
        scaleX = 1.0,
        scaleY = 1.0,
        rotation = 0,
        frequency = 1.0,
        stripeCount = 10,
        distortion = 0.0,
        centerX = 0.5,
        centerY = 0.5
      } = settings;

      const cx = width * centerX;
      const cy = height * centerY;
      const rad = (rotation * Math.PI) / 180;
      const cosR = Math.cos(rad);
      const sinR = Math.sin(rad);

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;

          // 应用旋转和独立缩放
          const dx = x - cx;
          const dy = y - cy;
          const rx = (dx * cosR - dy * sinR) * scaleX + cx;
          const ry = (dx * sinR + dy * cosR) * scaleY + cy;

          let value = 128;

          if (type === 'none' || intensity === 0) {
            value = 128;
          } else if (type === 'matte') {
            // 磨砂效果
            const noise = perlin.octaveNoise(rx * frequency * 0.05, ry * frequency * 0.05, 4, 0.5);
            value = 128 + noise * intensity * 127;
          } else if (type === 'brushed-h') {
            // 水平拉丝 - 应用条纹数量和扭曲
            const distortNoise = perlin.octaveNoise(rx * 0.01, ry * 0.01, 2, 0.5) * distortion;
            const noise = perlin.octaveNoise(rx * frequency * 0.02, (ry + distortNoise * 50) * frequency * 0.5, 3, 0.5);
            const stripe = Math.sin((ry + distortNoise * 50) * stripeCount * 0.1) * 0.2;
            value = 128 + (noise * 0.8 + stripe * 0.2) * intensity * 127;
          } else if (type === 'brushed-v') {
            // 垂直拉丝 - 应用条纹数量和扭曲
            const distortNoise = perlin.octaveNoise(rx * 0.01, ry * 0.01, 2, 0.5) * distortion;
            const noise = perlin.octaveNoise((rx + distortNoise * 50) * frequency * 0.5, ry * frequency * 0.02, 3, 0.5);
            const stripe = Math.sin((rx + distortNoise * 50) * stripeCount * 0.1) * 0.2;
            value = 128 + (noise * 0.8 + stripe * 0.2) * intensity * 127;
          } else if (type === 'brushed-radial') {
            // 径向拉丝（从中心向外）
            const rdx = rx - cx;
            const rdy = ry - cy;
            const angle = Math.atan2(rdy, rdx);
            const dist = Math.sqrt(rdx * rdx + rdy * rdy);

            const radialNoise = perlin.octaveNoise(
              Math.cos(angle) * dist * scale * frequency * 0.02,
              Math.sin(angle) * dist * scale * frequency * 0.02,
              3, 0.5
            );
            const angularNoise = perlin.octaveNoise(angle * 5 * frequency, dist * 0.01, 2, 0.5);
            value = 128 + (radialNoise * 0.7 + angularNoise * 0.3) * intensity * 127;
          } else if (type === 'circular') {
            // 圆环拉丝 - 应用条纹数量
            const rdx = rx - cx;
            const rdy = ry - cy;
            const dist = Math.sqrt(rdx * rdx + rdy * rdy);
            const angle = Math.atan2(rdy, rdx);

            const circularNoise = perlin.octaveNoise(angle * 10 * frequency, dist * frequency * 0.05, 3, 0.5);
            const radialStripe = Math.sin(dist * stripeCount * 0.05) * 0.15;
            value = 128 + (circularNoise * 0.85 + radialStripe * 0.15) * intensity * 127;
          } else if (type === 'noise') {
            // 纯噪点（细腻）
            const noise = perlin.octaveNoise(rx * frequency * 0.1, ry * frequency * 0.1, 5, 0.6);
            value = 128 + noise * intensity * 127;
          }

          value = Math.max(0, Math.min(255, value));
          output[idx] = value;
          output[idx + 1] = value;
          output[idx + 2] = value;
          output[idx + 3] = 255;
        }
      }

      return output;
    }

    // ============================================
    // 图像 Y 轴翻转函数（用于法线贴图）
    // ============================================
    function flipImageY(imageData, width, height) {
      const flipped = new Uint8ClampedArray(imageData.length);

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcIdx = (y * width + x) * 4;
          const dstIdx = ((height - 1 - y) * width + x) * 4;

          flipped[dstIdx] = imageData[srcIdx];
          flipped[dstIdx + 1] = imageData[srcIdx + 1];
          flipped[dstIdx + 2] = imageData[srcIdx + 2];
          flipped[dstIdx + 3] = imageData[srcIdx + 3];
        }
      }

      return flipped;
    }

    // ============================================
    // 边缘处理函数 - 柔和度和渐变
    // ============================================
    function applyEdgeSoftness(imageData, width, height, softness) {
      // 创建副本以避免修改原始数据
      const output = new Uint8ClampedArray(imageData);

      // 如果 softness 为 0，不修改 Alpha 通道，直接返回副本
      if (softness === 0) {
        return output;
      }

      // 将红色通道复制到 Alpha 通道 (假设红色通道包含形状/遮罩)
      for (let i = 0; i < width * height; i++) {
        output[i * 4 + 3] = output[i * 4];
      }

      return applyEdgeEffects(output, width, height, softness, 0);
    }

    function applyEdgeEffects(imageData, width, height, edgeSoftness, edgeFade) {
      if (edgeSoftness === 0 && edgeFade === 0) return imageData;

      const output = new Uint8ClampedArray(imageData);

      // 应用边缘柔和度（高斯模糊alpha通道）
      if (edgeSoftness > 0) {
        const radius = Math.floor(edgeSoftness);
        const alphaChannel = new Float32Array(width * height);

        // 提取alpha通道
        for (let i = 0; i < width * height; i++) {
          alphaChannel[i] = imageData[i * 4 + 3];
        }

        // 模糊alpha通道
        const blurred = gaussianBlur(alphaChannel, width, height, radius);

        // 写回alpha通道
        for (let i = 0; i < width * height; i++) {
          output[i * 4 + 3] = Math.min(255, Math.max(0, blurred[i]));
        }
      }

      return output;
    }

    // 应用高斯模糊到 ImageData（用于置换贴图等）
    function applyGaussianBlur(imgData, width, height, radius) {
      if (radius <= 0) return;

      const r = Math.floor(radius);

      // 对 RGB 三个通道分别应用模糊
      for (let channel = 0; channel < 3; channel++) {
        const channelData = new Float32Array(width * height);

        // 提取通道数据
        for (let i = 0; i < width * height; i++) {
          channelData[i] = imgData.data[i * 4 + channel];
        }

        // 应用高斯模糊
        const blurred = gaussianBlur(channelData, width, height, r);

        // 写回通道数据
        for (let i = 0; i < width * height; i++) {
          imgData.data[i * 4 + channel] = Math.min(255, Math.max(0, blurred[i]));
        }
      }
    }

    // 💎 碎片UV效果（车漆效果）- 使用Voronoi分型
    function applyFragmentUV(imgData, heightData, width, height, intensity) {
      const fragmentSize = uvSettings.fragmentSize || 8;
      const variation = uvSettings.fragmentVariation || 60;
      // 🔥 高级参数
      const rotation = (uvSettings.fragmentRotation || 0) * Math.PI / 180;
      const radial = (uvSettings.fragmentRadial || 0) / 10;
      const twist = (uvSettings.fragmentTwist || 0) * Math.PI / 180;

      const cx = width / 2;
      const cy = height / 2;
      const maxDist = Math.max(cx, cy);

      const maskMode = uvSettings.maskMode || 'alpha';
      const maskInvert = uvSettings.maskInvert || false;
      for (let i = 0; i < heightData.length; i += 4) {
        const alpha = getPixelIntensity(heightData, i, maskMode, maskInvert);
        if (alpha > 0) {
          let x = (i / 4) % width;
          let y = Math.floor((i / 4) / width);

          // 应用旋转
          if (rotation !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            x = cx + dx * Math.cos(rotation) - dy * Math.sin(rotation);
            y = cy + dx * Math.sin(rotation) + dy * Math.cos(rotation);
          }

          // 应用放射变形（指数级缩放 - 统一算法）
          if (radial !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // 统一使用指数映射：pow(2, -radial)
            // radial > 0: 中心放大 (Exponent < 1)
            // radial < 0: 中心缩小 (Exponent > 1)
            const normDist = dist / maxDist;
            const exponent = Math.pow(2, -radial);
            
            // Clamp normDist to avoid singularities
            const safeNormDist = Math.min(1, Math.max(0.0001, normDist));
            const newDist = Math.pow(safeNormDist, exponent) * maxDist;

            const angle = Math.atan2(dy, dx);
            x = cx + newDist * Math.cos(angle);
            y = cy + newDist * Math.sin(angle);
          }

          // 应用扭曲变形
          if (twist !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // 扭曲量随距离中心远近而变化，形成漩涡效果
            // 使用正弦波叠加增强扭曲感
            const angle = Math.atan2(dy, dx);
            const distortion = Math.sin(angle * 3 + dist * 0.02) * twist * 20;
            
            // 扭曲改变采样位置
            const newDist = dist + distortion;
            x = cx + newDist * Math.cos(angle);
            y = cy + newDist * Math.sin(angle);
          }

          const fx = Math.floor(x / fragmentSize);
          const fy = Math.floor(y / fragmentSize);
          const hash = (fx * 73856093) ^ (fy * 19349663);
          const noise = ((hash % 256) / 255.0 - 0.5) * variation;
          const fragment = Math.max(0, Math.min(255, intensity + noise));
          imgData.data[i] = fragment;
          imgData.data[i + 1] = fragment;
          imgData.data[i + 2] = fragment;
          imgData.data[i + 3] = alpha;
        }
      }
    }

    // 💠 钻石UV效果 - 使用多层闪光模拟钻石
    function applyDiamondUV(imgData, heightData, width, height, intensity) {
      const sparkleIntensity = uvSettings.sparkleIntensity || 40;
      const sparkleFrequency = uvSettings.sparkleFrequency || 0.5;
      // 🔥 高级参数
      const rotation = (uvSettings.diamondRotation || 0) * Math.PI / 180;
      const radial = (uvSettings.diamondRadial || 0) / 10;
      const twist = (uvSettings.diamondTwist || 0) * Math.PI / 180;

      const cx = width / 2;
      const cy = height / 2;
      const maxDist = Math.max(cx, cy);

      const maskMode = uvSettings.maskMode || 'alpha';
      const maskInvert = uvSettings.maskInvert || false;
      for (let i = 0; i < heightData.length; i += 4) {
        const alpha = getPixelIntensity(heightData, i, maskMode, maskInvert);
        if (alpha > 0) {
          let x = (i / 4) % width;
          let y = Math.floor((i / 4) / width);

          // 应用旋转
          if (rotation !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            x = cx + dx * Math.cos(rotation) - dy * Math.sin(rotation);
            y = cy + dx * Math.sin(rotation) + dy * Math.cos(rotation);
          }

          // 应用放射变形（指数级缩放 - 统一算法）
          if (radial !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // 统一使用指数映射：pow(2, -radial)
            const normDist = dist / maxDist;
            const exponent = Math.pow(2, -radial);
            
            const safeNormDist = Math.min(1, Math.max(0.0001, normDist));
            const newDist = Math.pow(safeNormDist, exponent) * maxDist;

            const angle = Math.atan2(dy, dx);
            x = cx + newDist * Math.cos(angle);
            y = cy + newDist * Math.sin(angle);
          }

          // 应用扭曲变形
          if (twist !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            const angle = Math.atan2(dy, dx);
            const distortion = Math.sin(angle * 3 + dist * 0.02) * twist * 20;
            
            const newDist = dist + distortion;
            x = cx + newDist * Math.cos(angle);
            y = cy + newDist * Math.sin(angle);
          }

          const sparkle1 = Math.sin(x * sparkleFrequency * 0.6) * Math.cos(y * sparkleFrequency * 0.6);
          const sparkle2 = Math.sin(x * sparkleFrequency * 1.4 + 1.5) * Math.cos(y * sparkleFrequency * 1.4 + 1.5);
          const sparkle = (sparkle1 + sparkle2) * sparkleIntensity;
          const diamond = Math.max(0, Math.min(255, intensity + sparkle));
          imgData.data[i] = diamond;
          imgData.data[i + 1] = diamond;
          imgData.data[i + 2] = diamond;
          imgData.data[i + 3] = alpha;
        }
      }
    }

    // 🔷 马赛克UV效果 - 使用分型算法模拟马赛克碎片
    function applyMosaicUV(imgData, heightData, width, height, intensity) {
      const mosaicSize = uvSettings.mosaicSize || 6;
      const variation = uvSettings.mosaicVariation || 80;
      // 🔥 高级参数
      const rotation = (uvSettings.mosaicRotation || 0) * Math.PI / 180;
      const radial = (uvSettings.mosaicRadial || 0) / 10;
      const twist = (uvSettings.mosaicTwist || 0) * Math.PI / 180;

      const cx = width / 2;
      const cy = height / 2;
      const maxDist = Math.max(cx, cy);

      const maskMode = uvSettings.maskMode || 'alpha';
      const maskInvert = uvSettings.maskInvert || false;
      for (let i = 0; i < heightData.length; i += 4) {
        const alpha = getPixelIntensity(heightData, i, maskMode, maskInvert);
        if (alpha > 0) {
          let x = (i / 4) % width;
          let y = Math.floor((i / 4) / width);

          // 应用旋转
          if (rotation !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            x = cx + dx * Math.cos(rotation) - dy * Math.sin(rotation);
            y = cy + dx * Math.sin(rotation) + dy * Math.cos(rotation);
          }

          // 应用放射变形（指数级缩放 - 统一算法）
          if (radial !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // 统一使用指数映射：pow(2, -radial)
            const normDist = dist / maxDist;
            const exponent = Math.pow(2, -radial);
            
            const safeNormDist = Math.min(1, Math.max(0.0001, normDist));
            const newDist = Math.pow(safeNormDist, exponent) * maxDist;

            const angle = Math.atan2(dy, dx);
            x = cx + newDist * Math.cos(angle);
            y = cy + newDist * Math.sin(angle);
          }

          // 应用扭曲变形
          if (twist !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            const angle = Math.atan2(dy, dx);
            const distortion = Math.sin(angle * 3 + dist * 0.02) * twist * 20;
            
            const newDist = dist + distortion;
            x = cx + newDist * Math.cos(angle);
            y = cy + newDist * Math.sin(angle);
          }

          const mx = Math.floor(x / mosaicSize);
          const my = Math.floor(y / mosaicSize);
          const hash = (mx * 2654435761) ^ (my * 2246822519);
          const noise = ((hash % 256) / 255.0 - 0.5) * variation;
          const mosaic = Math.max(0, Math.min(255, intensity + noise));
          imgData.data[i] = mosaic;
          imgData.data[i + 1] = mosaic;
          imgData.data[i + 2] = mosaic;
          imgData.data[i + 3] = alpha;
        }
      }
    }

    // ❄️ 磨砂UV效果 - 支持高级参数
    function applyFrostedUV(imgData, heightData, width, height, intensity) {
      const frostIntensity = uvSettings.frostIntensity || 30;
      // 🔥 高级参数
      const rotation = (uvSettings.frostedRotation || 0) * Math.PI / 180;
      const radial = (uvSettings.frostedRadial || 0) / 10;
      const twist = (uvSettings.frostedTwist || 0) * Math.PI / 180;

      const cx = width / 2;
      const cy = height / 2;
      const maxDist = Math.max(cx, cy);

      const maskMode = uvSettings.maskMode || 'alpha';
      const maskInvert = uvSettings.maskInvert || false;
      for (let i = 0; i < heightData.length; i += 4) {
        const alpha = getPixelIntensity(heightData, i, maskMode, maskInvert);
        if (alpha > 0) {
          let x = (i / 4) % width;
          let y = Math.floor((i / 4) / width);

          // 应用旋转
          if (rotation !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            x = cx + dx * Math.cos(rotation) - dy * Math.sin(rotation);
            y = cy + dx * Math.sin(rotation) + dy * Math.cos(rotation);
          }

          // 应用放射变形（指数级缩放 - 统一算法）
          if (radial !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // 统一使用指数映射：pow(2, -radial)
            const normDist = dist / maxDist;
            const exponent = Math.pow(2, -radial);
            
            const safeNormDist = Math.min(1, Math.max(0.0001, normDist));
            const newDist = Math.pow(safeNormDist, exponent) * maxDist;

            const angle = Math.atan2(dy, dx);
            x = cx + newDist * Math.cos(angle);
            y = cy + newDist * Math.sin(angle);
          }

          // 应用扭曲变形
          if (twist !== 0) {
            const dx = x - cx;
            const dy = y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            const angle = Math.atan2(dy, dx);
            const distortion = Math.sin(angle * 3 + dist * 0.02) * twist * 20;
            
            const newDist = dist + distortion;
            x = cx + newDist * Math.cos(angle);
            y = cy + newDist * Math.sin(angle);
          }

          // 🔥 使用简单的伪随机噪声（避免网格图案）
          const fx = Math.floor(x * 0.1);
          const fy = Math.floor(y * 0.1);
          const seed = (fx * 12.9898 + fy * 78.233);
          const noise = (Math.sin(seed) * 43758.5453 % 1.0 - 0.5) * frostIntensity * 2;
          const frosted = Math.max(0, Math.min(255, intensity + noise));
          imgData.data[i] = frosted;
          imgData.data[i + 1] = frosted;
          imgData.data[i + 2] = frosted;
          imgData.data[i + 3] = alpha;
        }
      }
    }

    // ⭕ 同心圆UV效果 - 支持形状模式和放射变形
    function applyConcentricUV(imgData, heightData, width, height, intensity) {
      const mode = uvSettings.concentricMode || 'circle';
      const style = uvSettings.concentricStyle || 'ring';
      let ringSpacing = uvSettings.ringSpacing || 20;
      const ringCount = uvSettings.ringCount || 10;
      const lineWidth = uvSettings.lineWidth || 3;
      const gradient = uvSettings.gradient || 50;
      const dotSpacing = uvSettings.dotSpacing || 15;
      // Radial: -100 to 100.
      // > 0: Center magnify (Edge collapse)
      // < 0: Center shrink (Edge magnify)
      // Increased range for extreme effects (up to +/- 10)
      const radial = (uvSettings.concentricRadial || 0) / 10;
      const twist = (uvSettings.concentricTwist || 0) * Math.PI / 180;

      let distMap = new Float32Array(width * height);
      let maxDist = 0;
      let cx = width / 2;
      let cy = height / 2;

      // 1. 计算距离场 (Distance Field)
      if (mode === 'shape') {
        // --- 基于形状 (SDF) ---
        const INF = 1e9;
        // 初始化
        const maskMode = uvSettings.maskMode || 'alpha';
        const maskInvert = uvSettings.maskInvert || false;
        for (let i = 0; i < width * height; i++) {
          const alpha = getPixelIntensity(heightData, i * 4, maskMode, maskInvert);
          distMap[i] = alpha > 10 ? INF : 0; // 降低阈值以捕捉半透明边缘
        }

        // 1. 第一次扫描 (Top-Left to Bottom-Right)
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            if (distMap[idx] === 0) continue;
            
            let d = distMap[idx];
            if (x > 0) d = Math.min(d, distMap[idx - 1] + 1);
            if (y > 0) d = Math.min(d, distMap[idx - width] + 1);
            if (x > 0 && y > 0) d = Math.min(d, distMap[idx - width - 1] + 1.414);
            if (x < width - 1 && y > 0) d = Math.min(d, distMap[idx - width + 1] + 1.414);
            
            distMap[idx] = d;
          }
        }

        // 2. 第二次扫描 (Bottom-Right to Top-Left)
        for (let y = height - 1; y >= 0; y--) {
          for (let x = width - 1; x >= 0; x--) {
            const idx = y * width + x;
            if (distMap[idx] === 0) continue;

            let d = distMap[idx];
            if (x < width - 1) d = Math.min(d, distMap[idx + 1] + 1);
            if (y < height - 1) d = Math.min(d, distMap[idx + width] + 1);
            if (x < width - 1 && y < height - 1) d = Math.min(d, distMap[idx + width + 1] + 1.414);
            if (x > 0 && y < height - 1) d = Math.min(d, distMap[idx + width - 1] + 1.414);
            
            distMap[idx] = d;
            if (d < INF && d > maxDist) maxDist = d;
          }
        }
      } else {
        // --- 基于圆心 (Circle) ---
        let minX = width, maxX = 0, minY = height, maxY = 0;
        let hasContent = false;
        const maskMode = uvSettings.maskMode || 'alpha';
        const maskInvert = uvSettings.maskInvert || false;
        for (let i = 0; i < heightData.length; i += 4) {
          if (getPixelIntensity(heightData, i, maskMode, maskInvert) > 0) {
            const x = (i / 4) % width;
            const y = Math.floor((i / 4) / width);
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
            hasContent = true;
          }
        }
        
        if (!hasContent) return;

        cx = (minX + maxX) / 2;
        cy = (minY + maxY) / 2;
        
        // 计算最大半径
        maxDist = Math.sqrt(Math.max(
          (cx - minX)**2 + (cy - minY)**2,
          (cx - maxX)**2 + (cy - maxY)**2,
          (cx - minX)**2 + (cy - maxY)**2,
          (cx - maxX)**2 + (cy - minY)**2
        ));

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const dx = x - cx;
            const dy = y - cy;
            distMap[y * width + x] = Math.sqrt(dx * dx + dy * dy);
          }
        }
      }

      // 优先使用 Ring Count 计算间距 (如果 maxDist 有效)
      if (maxDist > 0 && ringCount > 0) {
        ringSpacing = maxDist / ringCount;
      }

      // 2. 渲染
      const maskMode = uvSettings.maskMode || 'alpha';
      const maskInvert = uvSettings.maskInvert || false;
      for (let i = 0; i < heightData.length; i += 4) {
        const alpha = getPixelIntensity(heightData, i, maskMode, maskInvert);
        if (alpha > 0) {
          const idx = i / 4;
          let dist = distMap[idx];
          
          if (dist >= 1e9) dist = 0;

          // 应用 Radial 变形
          // 移除线宽修正，以允许线条在中心放大时变得极宽（空心效果），在边缘缩小时变得极细（坍缩效果）
          // 这样可以模拟玻璃材质的折射变形特性

          if (radial !== 0 && maxDist > 0) {
            let normDist = dist / maxDist;
            let t = normDist;
            let exponent = 1.0;
            
            if (mode === 'shape') {
               // Shape: 0=Edge, 1=Center
               // Positive Radial -> Center Magnify -> Exponent < 1
               exponent = Math.pow(2, -radial);
            } else {
               // Circle: 0=Center, 1=Edge
               exponent = Math.pow(2, radial);
            }

            // Clamp normDist to avoid singularities
            let safeNormDist = Math.min(1, Math.max(0.0001, normDist));
            t = Math.pow(safeNormDist, exponent);
            dist = t * maxDist;
          }

          // 应用 Twist 变形
          // 扭曲量随距离中心远近而变化，形成漩涡效果
          if (twist !== 0) {
             const x = (i / 4) % width;
             const y = Math.floor((i / 4) / width);
             const dx = x - cx;
             const dy = y - cy;
             const angle = Math.atan2(dy, dx);
             
             // 螺旋扰动：距离随角度变化 (Swirl effect)
             // dist += Math.sin(angle * 5 + dist * 0.05) * twist * 10;
             
             // 更自然的玻璃扭曲：
             // 扭曲不应改变距离场本身的值域，而是改变采样位置
             // 但我们这里是直接生成纹理，所以直接修改 dist 值来模拟
             
             // 使用 Perlin Noise 来增加不规则扭曲?
             // 暂时用简单的正弦波叠加
             const distortion = Math.sin(angle * 3 + dist * 0.02) * twist * 20;
             dist += distortion;
          }

          let value = 0;
          
          if (style === 'ring') {
            // --- 圆环样式 ---
            const ringPos = dist % ringSpacing;
            // 线条居中
            let distToLine = ringPos;
            if (ringPos > ringSpacing / 2) distToLine = ringSpacing - ringPos;
            
            if (distToLine < lineWidth / 2) {
              const edgeDist = lineWidth / 2 - distToLine;
              let antiAlias = Math.min(1.0, edgeDist);
              
              const centerFactor = 1 - (distToLine / (lineWidth / 2));
              const gradientFactor = gradient / 100;
              const brightness = 1 - (1 - centerFactor) * gradientFactor;
              
              value = Math.max(0, Math.min(255, intensity * brightness * antiAlias));
            }
          } else {
            // --- 圆点样式 ---
            // 在环的位置上打点
            const ringPos = dist % ringSpacing;
            let distToLine = ringPos;
            if (ringPos > ringSpacing / 2) distToLine = ringSpacing - ringPos;

            if (distToLine < lineWidth / 2) {
               let cut = false;
               if (mode === 'circle') {
                  const x = (i / 4) % width;
                  const y = Math.floor((i / 4) / width);
                  const dx = x - cx;
                  const dy = y - cy;
                  const angle = Math.atan2(dy, dx);
                  const circumference = 2 * Math.PI * dist;
                  const dotsCount = Math.floor(circumference / dotSpacing);
                  
                  if (dotsCount > 0) {
                    const angleStep = (2 * Math.PI) / dotsCount;
                    // 归一化角度
                    let angleNorm = (angle + Math.PI) / (2 * Math.PI); // 0-1
                    let dotPos = (angleNorm * dotsCount) % 1;
                    // dotPos 0.5 is center.
                    if (Math.abs(dotPos - 0.5) > 0.25) cut = true;
                  }
               } else {
                  // Shape 模式虚线
                  const x = (i / 4) % width;
                  const y = Math.floor((i / 4) / width);
                  if (((x + y) % dotSpacing) < dotSpacing / 2) cut = true;
               }
               
               if (!cut) value = intensity;
            }
          }

          imgData.data[i] = value;
          imgData.data[i + 1] = value;
          imgData.data[i + 2] = value;
          imgData.data[i + 3] = alpha;
        }
      }
    }

    // Sobel 算子 - 经典算法
    const SOBEL_X = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
    const SOBEL_Y = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];

    // 高斯模糊核生成
    function createGaussianKernel(radius) {
      if (radius <= 0) return null;
      const size = radius * 2 + 1;
      const kernel = [];
      const sigma = radius / 2;
      let sum = 0;
      for (let y = 0; y < size; y++) {
        kernel[y] = [];
        for (let x = 0; x < size; x++) {
          const dx = x - radius, dy = y - radius;
          const val = Math.exp(-(dx*dx + dy*dy) / (2*sigma*sigma));
          kernel[y][x] = val;
          sum += val;
        }
      }
      for (let y = 0; y < size; y++)
        for (let x = 0; x < size; x++)
          kernel[y][x] /= sum;
      return kernel;
    }

    // 🔥 锐化滤镜 - 消除模糊效果（增强版）
    function applySharpenFilter(imgData, width, height, strength) {
      if (strength <= 0) return;

      const data = imgData.data;
      const tempData = new Uint8ClampedArray(data);

      // 增强的锐化核心算法：更强的边缘增强
      const centerWeight = 1 + strength * 2; // 中心权重更大
      const edgeWeight = -strength * 0.5; // 边缘权重更强

      const kernel = [
        [0, edgeWeight, 0],
        [edgeWeight, centerWeight, edgeWeight],
        [0, edgeWeight, 0]
      ];

      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          let r = 0, g = 0, b = 0;

          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx = ((y + ky) * width + (x + kx)) * 4;
              const weight = kernel[ky + 1][kx + 1];
              r += tempData[idx] * weight;
              g += tempData[idx + 1] * weight;
              b += tempData[idx + 2] * weight;
            }
          }

          const idx = (y * width + x) * 4;
          data[idx] = Math.max(0, Math.min(255, r));
          data[idx + 1] = Math.max(0, Math.min(255, g));
          data[idx + 2] = Math.max(0, Math.min(255, b));
        }
      }
    }

    // 专业级法线生成
    function jsGenerateNormalMap(data, width, height, strength) {
      const opts = { ...normalMapSettings, strength };
      const output = new Uint8Array(data.length);
      const w = width, h = height;

      // 预处理高度数据
      let heightData = new Float32Array(w * h);
      for (let i = 0; i < w * h; i++) {
        const r = data[i * 4] / 255.0;
        const g = data[i * 4 + 1] / 255.0;
        const b = data[i * 4 + 2] / 255.0;
        const a = data[i * 4 + 3] / 255.0;

        let gray;
        if (opts.useGrayscale) {
          // Oklab 感知亮度 - 世界最先进的感知均匀色彩空间
          // sRGB -> Linear RGB
          const toLinear = (c) => c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
          const lr = toLinear(r), lg = toLinear(g), lb = toLinear(b);

          // Linear RGB -> Oklab L (感知亮度)
          const l = Math.cbrt(0.4122214708 * lr + 0.5363325363 * lg + 0.0514459929 * lb);
          const m = Math.cbrt(0.2119034982 * lr + 0.6806995451 * lg + 0.1073969566 * lb);
          const s = Math.cbrt(0.0883024619 * lr + 0.2817188376 * lg + 0.6299787005 * lb);

          gray = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
        } else {
          // 默认：标准亮度公式
          gray = 0.299 * r + 0.587 * g + 0.114 * b;
        }

        // 应用 contrast 和 brightness
        gray = (gray - 0.5) * opts.contrast + 0.5 + (opts.brightness / 255.0);
        gray = Math.max(0, Math.min(1, gray));

        heightData[i] = gray * a;
      }

      // 可选高斯模糊 - 使用分离式卷积优化性能
      if (opts.blurRadius > 0) {
        const radius = opts.blurRadius;
        const sigma = radius / 2.0;

        // 生成 1D 高斯核
        const kSize = radius * 2 + 1;
        const kernel1D = new Float32Array(kSize);
        let kSum = 0;
        for (let i = 0; i < kSize; i++) {
          const x = i - radius;
          kernel1D[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
          kSum += kernel1D[i];
        }
        for (let i = 0; i < kSize; i++) kernel1D[i] /= kSum;

        // 水平模糊
        const temp = new Float32Array(w * h);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let sum = 0;
            for (let k = 0; k < kSize; k++) {
              const sx = Math.max(0, Math.min(w - 1, x + k - radius));
              sum += heightData[y * w + sx] * kernel1D[k];
            }
            temp[y * w + x] = sum;
          }
        }

        // 垂直模糊
        const blurred = new Float32Array(w * h);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let sum = 0;
            for (let k = 0; k < kSize; k++) {
              const sy = Math.max(0, Math.min(h - 1, y + k - radius));
              sum += temp[sy * w + x] * kernel1D[k];
            }
            blurred[y * w + x] = sum;
          }
        }
        heightData = blurred;
      }

      const getH = (x, y) => heightData[Math.max(0,Math.min(h-1,y)) * w + Math.max(0,Math.min(w-1,x))];

      // 选择算子
      const kernelX = opts.algorithm === 'sobel' ? SOBEL_X : SCHARR_X;
      const kernelY = opts.algorithm === 'sobel' ? SOBEL_Y : SCHARR_Y;
      const divisor = opts.algorithm === 'sobel' ? 8.0 : 32.0;

      // 卷积生成法线
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          let gx = 0, gy = 0;
          for (let ky = 0; ky < 3; ky++) {
            for (let kx = 0; kx < 3; kx++) {
              const hVal = getH(x + kx - 1, y + ky - 1);
              gx += hVal * kernelX[ky][kx];
              gy += hVal * kernelY[ky][kx];
            }
          }

          // 应用强度和锐度
          const s = opts.strength * opts.sharpness;
          let nx = -gx / divisor * s;
          let ny = (opts.invertY ? 1 : -1) * gy / divisor * s;
          let nz = 1.0;

          // 归一化
          const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
          nx /= len; ny /= len; nz /= len;

          // 编码 RGB
          const idx = (y * w + x) * 4;
          output[idx] = Math.max(0, Math.min(255, Math.round((nx * 0.5 + 0.5) * 255)));
          output[idx+1] = Math.max(0, Math.min(255, Math.round((ny * 0.5 + 0.5) * 255)));
          output[idx+2] = Math.max(0, Math.min(255, Math.round((nz * 0.5 + 0.5) * 255)));
          output[idx+3] = 255;
        }
      }
      return output;
    }

    // Generate Normal Map using JS (Reliable Fallback)
    async function generateNormalMap(imageDataBase64, strength = 2.0) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          
          const imageData = ctx.getImageData(0, 0, img.width, img.height);
          const { width, height, data } = imageData;
          
          // Use JS implementation directly
          const normalData = jsGenerateNormalMap(data, width, height, strength);
          
          const outputImageData = ctx.createImageData(width, height);
          for (let i = 0; i < normalData.length; i++) {
            outputImageData.data[i] = normalData[i];
          }
          ctx.putImageData(outputImageData, 0, 0);
          resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = () => {
            console.error("Failed to load image for normal map conversion");
            resolve(imageDataBase64); // Fallback to original if load fails
        };
        img.src = imageDataBase64;
      });
    }

    let wasmInstance = null;

    // Initialize WASM
    async function initWasm() {
      if (wasmInstance) return wasmInstance;
      try {
        // Decode Base64 to ArrayBuffer
        const binaryString = window.atob(WASM_BASE64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        
        // Instantiate WASM
        const { instance } = await WebAssembly.instantiate(bytes, {
          // Add any required imports here if needed by wasm-bindgen
          // For simple functions, this might be empty or minimal
          './figma_pbr_core_bg.js': {
             // Mock imports if needed
             __wbindgen_throw: (ptr, len) => {
                console.error("WASM Error:", ptr, len);
             }
          }
        });
        wasmInstance = instance;
        console.log('✅ WASM Module Initialized');
        return instance;
      } catch (e) {
        console.error('❌ WASM Initialization Failed:', e);
      }
    }

    // Generate Normal Map using WASM (with JS fallback)
    async function generateNormalMap(imageDataBase64, strength = 2.0) {
      // Try to init WASM, but don't block if it fails
      if (!wasmInstance) {
          try {
              await initWasm();
          } catch (e) {
              console.warn("WASM init failed, using JS fallback");
          }
      }

      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          
          const imageData = ctx.getImageData(0, 0, img.width, img.height);
          const { width, height, data } = imageData;
          
          // Always use JS implementation for now to ensure reliability in this single-file context
          // passing raw memory to WASM without the bindgen wrapper is error-prone
          const normalData = jsGenerateNormalMap(data, width, height, strength);
          
          const outputImageData = ctx.createImageData(width, height);
          for (let i = 0; i < normalData.length; i++) {
            outputImageData.data[i] = normalData[i];
          }
          ctx.putImageData(outputImageData, 0, 0);
          resolve(canvas.toDataURL('image/png'));
        };
        img.src = imageDataBase64;
      });
    }


    // Helper: Get pixel intensity (Alpha or Luminance)
    function getPixelIntensity(data, i, mode, invert) {
      const a = data[i + 3];
      let val = a;
      if (mode === 'luminance') {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        // Standard luminance
        const lum = 0.299 * r + 0.587 * g + 0.114 * b;
        val = (lum * a) / 255;
      }
      if (invert) {
          return 255 - val;
      }
      return val;
    }

    // 生成当前 UV 纹理数据 (Helper)
    function generateCurrentUVTexture(imgData, heightData, width, height, uvType, intensity) {
      // 应用边缘柔和度
      const edgeSoftness = uvSettings.edgeSoftness || 0;
      const processedHeightData = applyEdgeSoftness(heightData, width, height, edgeSoftness);
      const maskMode = uvSettings.maskMode || 'alpha';
      const maskInvert = uvSettings.maskInvert || false;

      if (uvType === 'reverse') {
        for (let i = 0; i < processedHeightData.length; i += 4) {
          const alpha = getPixelIntensity(processedHeightData, i, maskMode, maskInvert);
          if (alpha > 0) {
            const reversed = 255 - intensity;
            imgData.data[i] = reversed;
            imgData.data[i + 1] = reversed;
            imgData.data[i + 2] = reversed;
            imgData.data[i + 3] = alpha;
          }
        }
      } else if (uvType === 'frosted') {
        applyFrostedUV(imgData, processedHeightData, width, height, intensity);
      } else if (uvType === 'fragment') {
        applyFragmentUV(imgData, processedHeightData, width, height, intensity);
      } else if (uvType === 'diamond') {
        applyDiamondUV(imgData, processedHeightData, width, height, intensity);
      } else if (uvType === 'mosaic') {
        applyMosaicUV(imgData, processedHeightData, width, height, intensity);
      } else if (uvType === 'concentric') {
        applyConcentricUV(imgData, processedHeightData, width, height, intensity);
      } else {
        // Standard UV
        for (let i = 0; i < processedHeightData.length; i += 4) {
          const alpha = getPixelIntensity(processedHeightData, i, maskMode, maskInvert);
          if (alpha > 0) {
            imgData.data[i] = intensity;
            imgData.data[i + 1] = intensity;
            imgData.data[i + 2] = intensity;
            imgData.data[i + 3] = alpha;
          }
        }
      }
      
      // 应用滤镜
      const sharpenStrength = uvSettings.sharpen || 0;
      if (sharpenStrength > 0) {
        applySharpenFilter(imgData, width, height, sharpenStrength);
      }
      const blurStrength = uvSettings.blur || 0;
      if (blurStrength > 0) {
        applyGaussianBlur(imgData, width, height, blurStrength);
      }
    }

    // 存储生成的贴图数据 (Key: layerId_craftType)
    let generatedMapsCache = new Map();

    // 应用生成的贴图到预览（不下载）
    function applyGeneratedMapToPreview(targetType) {
      if (!previewHeightData) {
        setStatus('No data to generate', 'error');
        return;
      }

      const width = previewWidth;
      const height = previewHeight;
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = width;
      tempCanvas.height = height;
      const ctx = tempCanvas.getContext('2d');
      const imgData = ctx.createImageData(width, height);

      // 1. 生成当前 UV 纹理
      const uvType = uvSettings.type || 'gloss';
      const intensity = Math.round(uvSettings.gloss * 255);
      
      generateCurrentUVTexture(imgData, previewHeightData, width, height, uvType, intensity);

      // 2. 转换为目标类型并应用预览
      if (targetType === 'normal') {
         // 🔥 修复：在生成法线前应用微量高斯模糊，防止锯齿
         applyGaussianBlur(imgData, width, height, 1.0);

         // 🔥 实时预览更新：将生成的UV纹理作为法线贴图的输入源
         overrideNormalInput = new Uint8ClampedArray(imgData.data);
         
         // 切换到法线面板并更新预览
         switchCraftType('normal');
         
         // 自动打开大图预览
         if (window.showCraftLargePreview) {
             window.showCraftLargePreview('normal');
         }
         
         updateNormalPreview();
         
         // 缓存生成的法线贴图（用于导出）
         // 注意：我们需要缓存的是最终的法线贴图，不仅仅是输入源
         const normalData = jsGenerateNormalMap(imgData.data, width, height, normalMapSettings.strength || 2.0);
         const finalData = ctx.createImageData(width, height);
         finalData.data.set(normalData);
         ctx.putImageData(finalData, 0, 0);
         
         if (selectedLayerId) {
             generatedMapsCache.set(`${selectedLayerId}_normal`, tempCanvas.toDataURL('image/png'));
         }

         setStatus('已应用到法线预览', 'success');

      } else if (targetType === 'displacement') {
         // 置换/凹凸 (直接输出灰度图)
         ctx.putImageData(imgData, 0, 0);
         
         // 切换到置换面板（如果有）
         switchCraftType('displacement');
         
         // 自动打开大图预览
         if (window.showCraftLargePreview) {
             window.showCraftLargePreview('displacement');
         }
         
         // TODO: 设置置换预览的 override
         
         if (selectedLayerId) {
             generatedMapsCache.set(`${selectedLayerId}_displacement`, tempCanvas.toDataURL('image/png'));
         }
         
         setStatus('已应用到置换预览', 'success');
      }
    }

    // 辅助函数：调整图像数据大小
    function resizeImageData(data, width, height, newWidth, newHeight) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        const imgData = new ImageData(data, width, height);
        ctx.putImageData(imgData, 0, 0);
        
        const newCanvas = document.createElement('canvas');
        newCanvas.width = newWidth;
        newCanvas.height = newHeight;
        const newCtx = newCanvas.getContext('2d');
        newCtx.imageSmoothingEnabled = true;
        newCtx.imageSmoothingQuality = 'high';
        newCtx.drawImage(canvas, 0, 0, newWidth, newHeight);
        
        return newCtx.getImageData(0, 0, newWidth, newHeight);
    }

    // 下载当前生成的贴图 (High Quality Export)
    function downloadCurrentMap(targetType) {
        if (!previewHeightData) return;
        
        // 🚀 极致优化：强制使用 2048px 最小分辨率导出
        const minSize = 2048;
        // 计算缩放比例 (保持长宽比)
        const scale = Math.max(1, Math.min(minSize / previewWidth, minSize / previewHeight));
        // 如果原图已经很大，保持原图大小；否则放大到至少 2048
        // 这里逻辑修正：如果是预览图(800px)，放大到2048。如果是原图(4096)，保持4096。
        // scale >= 1
        const exportScale = (previewWidth < minSize || previewHeight < minSize) ?
                           Math.max(minSize / previewWidth, minSize / previewHeight) : 1;
                           
        const width = Math.round(previewWidth * exportScale);
        const height = Math.round(previewHeight * exportScale);
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const ctx = tempCanvas.getContext('2d');
        const imgData = ctx.createImageData(width, height);
        
        // 1. 将输入的遮罩/高度数据放大到导出分辨率
        const resizedInput = resizeImageData(previewHeightData, previewWidth, previewHeight, width, height);
        
        // 2. 在高分辨率下重新生成程序化纹理
        const uvType = uvSettings.type || 'gloss';
        const intensity = Math.round(uvSettings.gloss * 255);
        generateCurrentUVTexture(imgData, resizedInput.data, width, height, uvType, intensity);
        
        if (targetType === 'normal') {
            // 应用模糊以消除放大后的锯齿
            applyGaussianBlur(imgData, width, height, 2.0 * exportScale);
            
            const normalData = jsGenerateNormalMap(imgData.data, width, height, normalMapSettings.strength || 2.0);
            const finalData = ctx.createImageData(width, height);
            finalData.data.set(normalData);
            ctx.putImageData(finalData, 0, 0);
        } else {
            // 置换贴图优化：填充背景为黑色，Alpha为不透明
            for (let i = 0; i < imgData.data.length; i += 4) {
                if (imgData.data[i+3] === 0) {
                    imgData.data[i] = 0;
                    imgData.data[i+1] = 0;
                    imgData.data[i+2] = 0;
                }
                imgData.data[i+3] = 255; // 强制不透明
            }
            ctx.putImageData(imgData, 0, 0);
        }
        
        const filename = `export_${targetType}_${width}x${height}_${Date.now()}.png`;
        downloadDataUrl(tempCanvas.toDataURL('image/png'), filename);
        setStatus(`已下载 ${width}x${height} 高清贴图`, 'success');
    }

    function downloadAllGeneratedMaps() {
      downloadCurrentMap('normal');
      setTimeout(() => downloadCurrentMap('displacement'), 500);
    }

    // Process result before download
    async function processAndDownloadJSON(data) {
        console.log('📦 processAndDownloadJSON called');
        console.log('📦 masks count:', data.masks?.length || 0);

        let normalMapDataUrl = null;
        if (data.masks && data.masks.length > 0) {
            for (let mask of data.masks) {
                console.log('📦 Processing mask:', mask.craftType);
                if (mask.craftType === '法线' || mask.craftType === 'Normal') {
                    console.log('🔄 Converting Normal Map with user settings');
                    
                    // 🔥 Check if we have a generated/cached map for this layer
                    if (generatedMapsCache.has(`${mask.id}_normal`)) {
                        console.log('✅ Using cached generated Normal Map');
                        const cachedMap = generatedMapsCache.get(`${mask.id}_normal`);
                        mask.normalTexture = cachedMap;
                        normalMapDataUrl = cachedMap;
                    } else {
                        // Fallback to generating from texture
                        console.log('🔄 Settings:', normalMapSettings);
                        try {
                            const normalTexture = await generateNormalMap(
                                mask.texture,
                                normalMapSettings.strength
                            );
                            console.log('✅ Normal map generated');
                            mask.normalTexture = normalTexture;
                            normalMapDataUrl = normalTexture;
                        } catch (e) {
                            console.error('❌ Normal map generation failed:', e);
                        }
                    }
                }
            }
        }

        if (normalMapDataUrl) {
            const baseName = (data.name || 'export').replace(/[^a-zA-Z0-9]/g, '_');
            downloadDataUrl(normalMapDataUrl, baseName + '_normal.png');
        }
        downloadJSON(data);
    }
  </script>
</head>
<body>
  <div class="app-container">
    <!-- Left: Viewport -->
    <div class="viewport">
      <div class="viewport-header">
        <div class="logo-section">
          <div class="logo-icon">🎨</div>
          <div class="logo-text">
            <span class="logo-title">FIGMA EXPORTER v2.1 🔥</span>
            <span class="logo-subtitle">Blender Pipeline - BUILD 20260110-FIX1</span>
          </div>
        </div>
      </div>

      <div class="viewport-content">
        <!-- 工艺贴图大图预览 -->
        <div class="craft-large-preview" id="craftLargePreview">
          <div class="craft-large-preview-header">
            <div class="craft-large-preview-title" id="craftLargePreviewTitle">工艺预览</div>
            <button class="craft-large-preview-close" onclick="closeCraftLargePreview()">✕ 关闭</button>
          </div>
          <canvas class="craft-large-preview-canvas" id="craftLargePreviewCanvas" width="800" height="600"></canvas>
        </div>

        <canvas id="webgpuCanvas"></canvas>

        <!-- 空状态占位符 -->
        <div class="viewport-placeholder" id="emptyState">
          <div class="viewport-placeholder-icon">📦</div>
          <div class="viewport-placeholder-text">
            Select a Frame in Figma to preview export regions
          </div>
        </div>

        <!-- Vector 预览网格 -->
        <div class="vector-preview-container" id="vectorPreview" style="display: none;">
          <div class="vector-preview-header">
            <span class="vector-preview-title">刀版图预览</span>
            <button class="auto-name-btn" onclick="autoAssignPanelCodes()" title="自动命名面板">🏷️ 自动命名</button>
            <span class="vector-preview-hint">点击设置折叠顺序</span>
          </div>
          <div class="spatial-canvas" id="spatialCanvas">
            <!-- 画布控制工具栏 - 浮动在左上角 -->
            <div class="canvas-controls-floating">
              <button class="canvas-btn" onclick="zoomOut()" title="缩小">−</button>
              <span class="canvas-zoom-display" id="zoomDisplay">100%</span>
              <button class="canvas-btn" onclick="zoomIn()" title="放大">+</button>
              <button class="canvas-btn" onclick="resetView()" title="重置">⟲</button>
            </div>
            <div class="spatial-viewport" id="spatialViewport"></div>
            <!-- 折叠顺序面板 -->
            <div class="fold-order-panel" id="foldOrderPanel" style="display: none;">
              <div class="fold-order-header">
                <span class="fold-order-title">📐 折叠顺序</span>
                <div class="fold-order-actions">
                  <button class="canvas-btn canvas-btn-danger" onclick="clearAllSelections(event)" title="清空所有">⟲</button>
                  <button class="canvas-btn" onclick="toggleFoldPanelMinimize(event)" title="最小化">◀</button>
                  <button class="canvas-btn" onclick="toggleFoldPanel(event)" title="关闭">×</button>
                </div>
              </div>
              <div class="fold-order-content" id="foldOrderContent">
                <div style="color: var(--color-neutral-500); font-size: 10px; text-align: center; padding: 12px;">
                  点击折叠边设置顺序
                </div>
              </div>
            </div>
          </div>
          <!-- 折叠顺序预览栏 - 可最小化 -->
          <div class="order-preview-bar" id="orderPreview">
            <button class="canvas-btn" onclick="toggleOrderPreview(event)" title="展开/收起折叠顺序">
              <span id="orderToggleIcon">▶</span>
            </button>
            <span class="order-preview-label" id="orderLabel">折叠顺序:</span>
            <span id="orderItems" style="display: flex; gap: 4px; flex-wrap: wrap; flex: 1;"></span>
            <button class="canvas-btn canvas-btn-danger" onclick="clearAllSelections(event)" title="清空所有" id="orderClearBtn">✕</button>
          </div>
        </div>
      </div>

      <!-- 工艺预览缩略图区域 - 移到左侧下方 -->
      <div class="craft-preview-thumbnails" id="craftThumbnails">
        <div class="craft-thumbnails-header">
          <span class="craft-thumbnails-title">🎨 工艺预览</span>
          <button class="craft-thumbnails-toggle" id="craftThumbnailsToggle" onclick="toggleCraftThumbnails()">
            <span class="toggle-icon">▼</span>
          </button>
        </div>
        <div class="craft-thumbnails-grid" id="craftThumbnailsGrid">
          <!-- 缩略图将通过 JS 动态生成 -->
        </div>
      </div>

      <div class="viewport-footer">
        <div class="status-bar">
          <div class="status-indicator" id="statusIndicator"></div>
          <span id="status">Ready</span>
        </div>
        <div class="viewport-info" id="viewportInfo"></div>
      </div>
    </div>

    <!-- Right: Control Panel -->
    <div class="control-panel" id="controlPanel">
      <!-- 折叠按钮 -->
      <button class="panel-toggle" id="panelToggle" onclick="togglePanel()">
        <span id="toggleIcon">›</span>
      </button>

      <!-- N面板 Tab 栏 -->
      <div class="panel-tabs">
        <button class="panel-tab active" onclick="switchTab('export')" id="tabExport">
          📦 Export
        </button>
        <button class="panel-tab" onclick="switchTab('fold')" id="tabFold">
          📐 折叠
        </button>
        <button class="panel-tab" onclick="switchTab('normal')" id="tabNormal">
          🎨 工艺
        </button>
      </div>

      <!-- Tab 内容区域 -->
      <div class="panel-tab-content active" id="tabContentExport">
        <!-- Export Mode Section -->
        <div class="section">
          <div class="section-title">Export Mode</div>

          <button class="export-btn" onclick="startWebGPURender()" style="margin-bottom: var(--space-md); background: linear-gradient(135deg, #8b5cf6, #6366f1);">
            ✨ 开启 Cycles 级光追预览
          </button>

          <div class="toggle-row" id="clipModeRow" onclick="toggleClipMode()">
            <div>
              <div class="toggle-label">Clip Mode</div>
              <div class="toggle-hint">Export masked regions</div>
            </div>
            <div class="toggle-switch" id="clipModeSwitch"></div>
          </div>

          <div style="display: flex; gap: 8px; margin-top: 0; margin-bottom: var(--space-sm);">
            <button class="secondary-btn" onclick="addSelectedVectors()" style="flex: 1; margin: 0;">
              ➕ 添加 Clipmask
            </button>
            <button class="secondary-btn danger" onclick="clearAllVectors()" style="flex: 1; margin: 0;">
              🗑️ 清除全部
            </button>
          </div>

          <div class="toggle-row" id="craftVectorRow" onclick="toggleCraftVector()">
            <div>
              <div class="toggle-label">Craft Vector</div>
              <div class="toggle-hint">Export B/W vector layers</div>
            </div>
            <div class="toggle-switch" id="craftVectorSwitch"></div>
          </div>
        </div>

        <!-- Craft Marking Section -->
        <div class="section">
          <div class="section-title">Craft Marking</div>

          <!-- 批量标记选项 -->
          <div class="batch-mark-options" style="margin-bottom: var(--space-sm);">
            <div class="batch-option-row">
              <label class="batch-checkbox">
                <input type="checkbox" id="markSameColor" />
                <span>🎨 标记相同颜色</span>
              </label>
            </div>
            <div class="batch-option-row">
              <label class="batch-checkbox">
                <input type="checkbox" id="markInClipMask" />
                <span>📎 仅限 ClipMask 范围内</span>
              </label>
            </div>
          </div>

          <button class="secondary-btn" onclick="selectByColor()" style="margin-top: 0; margin-bottom: var(--space-sm);">
            🎨 Select Same Color
          </button>

          <div class="slider-row">
            <div class="slider-header">
              <span class="slider-label">Gray Value (Intensity)</span>
              <span class="slider-value" id="grayValueDisplay">255</span>
            </div>
            <input type="range" class="slider-track" id="graySlider" min="0" max="255" value="255"
              oninput="updateGrayValue(this.value)">
          </div>

          <div class="craft-grid">
            <button class="craft-btn gold" onclick="markCraftWithGray('烫金')">
              <span class="craft-dot"></span> 烫金
            </button>
            <button class="craft-btn silver" onclick="markCraftWithGray('烫银')">
              <span class="craft-dot"></span> 烫银
            </button>
            <button class="craft-btn uv" onclick="markCraftWithGray('UV')">
              <span class="craft-dot"></span> UV
            </button>
            <button class="craft-btn emboss" onclick="markCraftWithGray('凹凸')">
              <span class="craft-dot"></span> 凹凸
            </button>
            <button class="craft-btn normal" onclick="markCraftWithGray('法线')">
              <span class="craft-dot"></span> 法线
            </button>
            <button class="craft-btn displacement" onclick="markCraftWithGray('置换')">
              <span class="craft-dot"></span> 置换
            </button>
          </div>
        </div>

        <!-- Marked Layers Section -->
        <div class="section" id="markedSection" style="display: none;">
          <div class="section-title">Marked Layers</div>
          <div class="marked-list" id="markedLayers"></div>
          <button class="secondary-btn" onclick="regenerateAllIndicators()">
            🔄 Regenerate Markers
          </button>
          <button class="secondary-btn danger" onclick="clearAllMarks()">
            🗑️ Clear All Marks
          </button>
        </div>
      </div>

      <!-- 折叠顺序 Tab 内容 -->
      <div class="panel-tab-content" id="tabContentFold">
        <!-- 折叠边编辑开关 -->
        <div class="section">
          <div class="toggle-row" id="foldEdgeModeRow" onclick="toggleFoldEdgeMode()">
            <div>
              <div class="toggle-label">编辑折叠边</div>
              <div class="toggle-hint">点击虚线添加折叠边</div>
            </div>
            <div class="toggle-switch" id="foldEdgeModeSwitch"></div>
          </div>
        </div>

        <!-- 根面板提示 -->
        <div class="section" id="rootPanelHint">
          <div style="padding: 8px; background: rgba(245, 158, 11, 0.1); border-radius: 6px; font-size: 10px; color: var(--color-warning);">
            💡 右键点击面板设置为根节点
          </div>
        </div>

        <!-- 父子面板指定（带动关系） -->
        <div class="section">
          <div class="section-title">带动关系</div>
          <div style="display: flex; gap: 4px; margin-bottom: 8px;">
            <input id="drivenParentSelect" class="driven-select" type="hidden" value="" />
            <div class="driven-dropdown" id="drivenParentDropdown">
              <button class="driven-dropdown-trigger" type="button" aria-expanded="false" onclick="toggleDrivenDropdown(event, 'parent')">
                <span class="driven-dropdown-label placeholder" id="drivenParentLabel">选择父面板...</span>
                <span class="driven-dropdown-icon">˅</span>
              </button>
              <div class="driven-dropdown-menu" id="drivenParentMenu"></div>
            </div>

            <input id="drivenChildSelect" class="driven-select" type="hidden" value="" />
            <div class="driven-dropdown" id="drivenChildDropdown">
              <button class="driven-dropdown-trigger" type="button" aria-expanded="false" onclick="toggleDrivenDropdown(event, 'child')">
                <span class="driven-dropdown-label placeholder" id="drivenChildLabel">选择子面板...</span>
                <span class="driven-dropdown-icon">˅</span>
              </button>
              <div class="driven-dropdown-menu" id="drivenChildMenu"></div>
            </div>
            <button class="driven-add-btn" onclick="addChildToGroup()" title="添加到组">+</button>
          </div>
          <!-- PS风格的组列表 -->
          <div id="drivenGroupList" class="fold-layer-tree">
            <!-- 动态生成 -->
          </div>
        </div>

        <!-- 折叠顺序（PS图层形式） -->
        <div class="section">
          <div class="section-title">折叠顺序</div>
          <div id="foldLayerTree" class="fold-layer-tree">
            <!-- 动态生成 -->
          </div>
        </div>

        <!-- 导出按钮 -->
        <div class="section" style="margin-top: 12px;">
          <button class="secondary-btn" onclick="exportFoldJSON()" style="background: linear-gradient(135deg, #10b981, #059669); border: none; color: white;">
            📥 导出折叠 JSON
          </button>
        </div>
      </div>

      <!-- 工艺调节 Tab 内容 -->
      <div class="panel-tab-content" id="tabContentNormal">
        <!-- 图层选择器 -->
        <div class="section" style="padding-bottom: 8px;">
          <div class="normal-layer-selector">
            <input id="normalLayerSelect" type="hidden" value="" />
            <div class="driven-dropdown" id="normalLayerDropdown" style="flex: 1;">
              <button class="driven-dropdown-trigger" type="button" onclick="toggleNormalLayerDropdown(event)">
                <span class="driven-dropdown-label placeholder" id="normalLayerLabel">选择工艺图层...</span>
                <span class="driven-dropdown-icon">˅</span>
              </button>
              <div class="driven-dropdown-menu" id="normalLayerMenu"></div>
            </div>
            <button class="refresh-btn" onclick="refreshNormalLayers()" title="刷新列表">↻</button>
          </div>

          <!-- 工艺类型按钮组 -->
          <div class="craft-type-buttons" id="craftTypeButtons" style="display: none;">
            <!-- 动态生成工艺按钮 -->
          </div>
        </div>

        <!-- 工艺参数面板容器 -->
        <div class="craft-params-container">
          <!-- 法线面板 -->
          <div class="craft-param-panel" id="panelNormal">

            <div class="param-section">
              <div class="section-title">Basic Parameters</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">Strength</span>
                  <span class="param-value" id="normalStrengthVal">2.0</span>
                </div>
                <input type="range" class="param-slider" id="normalStrength"
                  min="0.1" max="50" step="0.1" value="2" oninput="updateNormalSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">Blur Radius</span>
                  <span class="param-value" id="normalBlurVal">0</span>
                </div>
                <input type="range" class="param-slider" id="normalBlur"
                  min="0" max="100" step="1" value="0" oninput="updateNormalSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">Sharpness</span>
                  <span class="param-value" id="normalSharpnessVal">1.0</span>
                </div>
                <input type="range" class="param-slider" id="normalSharpness"
                  min="0.1" max="10" step="0.1" value="1" oninput="updateNormalSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">Contrast</span>
                  <span class="param-value" id="normalContrastVal">1.0</span>
                </div>
                <input type="range" class="param-slider" id="normalContrast"
                  min="0.1" max="10" step="0.1" value="1" oninput="updateNormalSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">Brightness</span>
                  <span class="param-value" id="normalBrightnessVal">0</span>
                </div>
                <input type="range" class="param-slider" id="normalBrightness"
                  min="-255" max="255" step="1" value="0" oninput="updateNormalSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">边缘柔和度 (Edge Softness)</span>
                  <span class="param-value" id="normalEdgeSoftnessVal">0.0</span>
                </div>
                <input type="range" class="param-slider" id="normalEdgeSoftness"
                  min="0" max="100" step="0.5" value="0" oninput="updateNormalSettings()">
              </div>
              <div class="param-toggle" onclick="toggleNormalInvertY()">
                <div>
                  <div class="toggle-label">Invert Y (DirectX)</div>
                  <div class="toggle-hint">Switch between OpenGL/DirectX format</div>
                </div>
                <div class="toggle-switch" id="normalInvertYSwitch"></div>
              </div>
              <div class="param-toggle" onclick="toggleNormalReverse()">
                <div>
                  <div class="toggle-label">🔄 Reverse Effect</div>
                  <div class="toggle-hint">Invert the height map</div>
                </div>
                <div class="toggle-switch" id="normalReverseSwitch"></div>
              </div>
              <div class="param-toggle" onclick="toggleNormalGrayscale()">
                <div>
                  <div class="toggle-label">Convert to Grayscale</div>
                  <div class="toggle-hint">Use luminance as height map</div>
                </div>
                <div class="toggle-switch" id="normalGrayscaleSwitch"></div>
              </div>
              
              <div id="grayscaleWeights" style="display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div class="section-title" style="font-size: 10px; margin-bottom: 8px;">Color Weights</div>
                
                <div class="param-row" style="margin-bottom: 4px;">
                  <div style="display:flex; justify-content:space-between; font-size: 9px; color: #f87171;">
                    <span>Red</span><span id="weightRVal">0.299</span>
                  </div>
                  <input type="range" class="param-slider" id="weightR" min="-2" max="2" step="0.01" value="0.299" oninput="updateNormalSettings()">
                </div>
                
                <div class="param-row" style="margin-bottom: 4px;">
                  <div style="display:flex; justify-content:space-between; font-size: 9px; color: #4ade80;">
                    <span>Green</span><span id="weightGVal">0.587</span>
                  </div>
                  <input type="range" class="param-slider" id="weightG" min="-2" max="2" step="0.01" value="0.587" oninput="updateNormalSettings()">
                </div>
                
                <div class="param-row" style="margin-bottom: 4px;">
                  <div style="display:flex; justify-content:space-between; font-size: 9px; color: #60a5fa;">
                    <span>Blue</span><span id="weightBVal">0.114</span>
                  </div>
                  <input type="range" class="param-slider" id="weightB" min="-2" max="2" step="0.01" value="0.114" oninput="updateNormalSettings()">
                </div>
                
                <div class="param-row" style="margin-bottom: 4px;">
                  <div style="display:flex; justify-content:space-between; font-size: 9px; color: #22d3ee;">
                    <span>Cyan</span><span id="weightCVal">0.0</span>
                  </div>
                  <input type="range" class="param-slider" id="weightC" min="-2" max="2" step="0.01" value="0" oninput="updateNormalSettings()">
                </div>
                
                <div class="param-row" style="margin-bottom: 4px;">
                  <div style="display:flex; justify-content:space-between; font-size: 9px; color: #e879f9;">
                    <span>Magenta</span><span id="weightMVal">0.0</span>
                  </div>
                  <input type="range" class="param-slider" id="weightM" min="-2" max="2" step="0.01" value="0" oninput="updateNormalSettings()">
                </div>
                
                <div class="param-row" style="margin-bottom: 4px;">
                  <div style="display:flex; justify-content:space-between; font-size: 9px; color: #facc15;">
                    <span>Yellow</span><span id="weightYVal">0.0</span>
                  </div>
                  <input type="range" class="param-slider" id="weightY" min="-2" max="2" step="0.01" value="0" oninput="updateNormalSettings()">
                </div>
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">Algorithm</div>
              <div class="param-btn-group">
                <button class="param-btn active" id="algoScharr" onclick="setNormalAlgorithm('scharr')">Scharr</button>
                <button class="param-btn" id="algoSobel" onclick="setNormalAlgorithm('sobel')">Sobel</button>
              </div>
              <div class="algo-hint">Scharr provides better rotational symmetry</div>
            </div>

            <div class="param-section">
              <div class="section-title">Presets</div>
              <select class="param-select" id="normalPreset" onchange="selectPreset(this.value)">
                <option value="default">默认</option>
                <option value="subtle">细腻</option>
                <option value="medium">中等</option>
                <option value="strong">强烈</option>
                <option value="emboss">浮雕</option>
                <option value="photo">照片转法线</option>
              </select>
            </div>
          </div>

          <!-- 凹凸面板 -->
          <div class="craft-param-panel" id="panelEmboss" style="display: none;">
            <div class="param-section">
              <div class="section-title">SDF Parameters</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">SDF 扩散距离</span>
                  <span class="param-value" id="sdfSpreadVal">10.0</span>
                </div>
                <input type="range" class="param-slider" id="sdfSpread"
                  min="0.5" max="100" step="0.5" value="10" oninput="updateEmbossSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">高度缩放</span>
                  <span class="param-value" id="heightScaleVal">1.5</span>
                </div>
                <input type="range" class="param-slider" id="heightScale"
                  min="0.1" max="5" step="0.1" value="1.5" oninput="updateEmbossSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">边缘柔和度</span>
                  <span class="param-value" id="sdfSoftnessVal">1.0</span>
                </div>
                <input type="range" class="param-slider" id="sdfSoftness"
                  min="0.1" max="3" step="0.1" value="1" oninput="updateEmbossSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">波纹数量</span>
                  <span class="param-value" id="rippleCountVal">3</span>
                </div>
                <input type="range" class="param-slider" id="rippleCount"
                  min="1" max="10" step="1" value="3" oninput="updateEmbossSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">波纹粗细</span>
                  <span class="param-value" id="rippleWidthVal">0.5</span>
                </div>
                <input type="range" class="param-slider" id="rippleWidth"
                  min="0.1" max="1.0" step="0.05" value="0.5" oninput="updateEmbossSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">虚线效果</span>
                  <span class="param-value" id="rippleDashVal">0.0</span>
                </div>
                <input type="range" class="param-slider" id="rippleDash"
                  min="0" max="0.9" step="0.05" value="0" oninput="updateEmbossSettings()">
              </div>
              <div class="param-btn-group">
                <button class="param-btn" id="sdfExpand" onclick="setSdfMode('expand')">Expand</button>
                <button class="param-btn active" id="sdfShrink" onclick="setSdfMode('shrink')">Shrink</button>
              </div>
              <div class="param-btn-group">
                <button class="param-btn active" onclick="setEmbossProfile('smoothstep')">平滑</button>
                <button class="param-btn" onclick="setEmbossProfile('linear')">线性</button>
                <button class="param-btn" onclick="setEmbossProfile('pillow')">枕状浮雕</button>
              </div>
              <div class="param-toggle" onclick="toggleEmbossMaskMode()">
                <div>
                  <div class="toggle-label">Use Luminance for Mask</div>
                  <div class="toggle-hint">For image inputs (black/white)</div>
                </div>
                <div class="toggle-switch" id="embossMaskModeSwitch"></div>
              </div>
              <div class="param-toggle" onclick="toggleEmbossMaskInvert()">
                <div>
                  <div class="toggle-label">Invert Mask</div>
                  <div class="toggle-hint">Invert black/white interpretation</div>
                </div>
                <div class="toggle-switch" id="embossMaskInvertSwitch"></div>
              </div>
            </div>
          </div>

          <!-- 金属面板 -->
          <div class="craft-param-panel" id="panelMetal" style="display: none;">
            <div class="param-section">
              <div class="section-title">Parameters</div>
              <select class="param-select" id="metalType" onchange="updateMetalSettings()">
                <option value="gold">烫金</option>
                <option value="silver">烫银</option>
              </select>
              <select class="param-select" id="metalTexture" onchange="updateMetalSettings()">
                <option value="mirror">镜面</option>
                <option value="matte">磨砂</option>
                <option value="brushed">拉丝</option>
                <option value="satin">缎面</option>
              </select>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">纹理强度</span>
                  <span class="param-value" id="metalIntensityVal">0.5</span>
                </div>
                <input type="range" class="param-slider" id="metalIntensity"
                  min="0" max="1" step="0.1" value="0.5" oninput="updateMetalSettings()">
              </div>
            </div>
          </div>

          <!-- UV光油面板 -->
          <div class="craft-param-panel" id="panelUV" style="display: none;">
            <div class="param-section">
              <div class="section-title">UV Regions Preview</div>
              <div class="uv-regions-grid" id="uvRegionsGrid">
                <!-- 动态生成多个光油区域预览 -->
              </div>
            </div>
            <div class="param-section">
              <div class="section-title">UV Parameters</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">光泽度 (Gloss)</span>
                  <span class="param-value" id="uvGlossVal">0.95</span>
                </div>
                <input type="range" class="param-slider" id="uvGloss"
                  min="0" max="1" step="0.01" value="0.95" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">厚度 (Thickness)</span>
                  <span class="param-value" id="uvThicknessVal">0.5</span>
                </div>
                <input type="range" class="param-slider" id="uvThickness"
                  min="0.05" max="3" step="0.05" value="0.5" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">粗糙度 (Roughness)</span>
                  <span class="param-value" id="uvRoughnessVal">0.1</span>
                </div>
                <input type="range" class="param-slider" id="uvRoughness"
                  min="0" max="1" step="0.01" value="0.1" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">边缘柔和度 (Edge Softness)</span>
                  <span class="param-value" id="uvEdgeSoftnessVal">0.0</span>
                </div>
                <input type="range" class="param-slider" id="uvEdgeSoftness"
                  min="0" max="10" step="0.5" value="0" oninput="updateUVSettings()">
              </div>
              <!-- 🔥 锐化强度参数 -->
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🔪 锐化强度 (Sharpen)</span>
                  <span class="param-value" id="uvSharpenVal">0.0</span>
                </div>
                <input type="range" class="param-slider" id="uvSharpen"
                  min="0" max="5" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
              <!-- 🔥 模糊强度参数 -->
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🌫️ 模糊强度 (Blur)</span>
                  <span class="param-value" id="uvBlurVal">0.0</span>
                </div>
                <input type="range" class="param-slider" id="uvBlur"
                  min="0" max="10" step="0.5" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-toggle" onclick="toggleUVMaskMode()">
                <div>
                  <div class="toggle-label">Use Luminance for Mask</div>
                  <div class="toggle-hint">For image inputs (black/white)</div>
                </div>
                <div class="toggle-switch" id="uvMaskModeSwitch"></div>
              </div>
              <div class="param-toggle" onclick="toggleUVMaskInvert()">
                <div>
                  <div class="toggle-label">Invert Mask</div>
                  <div class="toggle-hint">Invert black/white interpretation</div>
                </div>
                <div class="toggle-switch" id="uvMaskInvertSwitch"></div>
              </div>
            </div>

            <!-- UV类型预设 -->
            <div class="param-section">
              <div class="section-title">🎨 UV类型预设</div>
              <div class="uv-preset-grid">
                <button class="uv-preset-btn active" data-uv-type="gloss" onclick="selectUVPreset('gloss')">✨ 高光</button>
                <button class="uv-preset-btn" data-uv-type="semi" onclick="selectUVPreset('semi')">💫 半光</button>
                <button class="uv-preset-btn" data-uv-type="satin" onclick="selectUVPreset('satin')">🌟 缎面</button>
                <button class="uv-preset-btn" data-uv-type="matte" onclick="selectUVPreset('matte')">🌫️ 哑光</button>
                <button class="uv-preset-btn" data-uv-type="reverse" onclick="selectUVPreset('reverse')">🔄 反向UV</button>
                <button class="uv-preset-btn" data-uv-type="frosted" onclick="selectUVPreset('frosted')">❄️ 磨砂UV</button>
                <button class="uv-preset-btn" data-uv-type="fragment" onclick="selectUVPreset('fragment')">💎 碎片UV</button>
                <button class="uv-preset-btn" data-uv-type="diamond" onclick="selectUVPreset('diamond')">💠 钻石UV</button>
                <button class="uv-preset-btn" data-uv-type="mosaic" onclick="selectUVPreset('mosaic')">🔷 马赛克UV</button>
                <button class="uv-preset-btn" data-uv-type="concentric" onclick="selectUVPreset('concentric')">⭕ 同心圆UV</button>
              </div>
            </div>

            <!-- 碎片UV专属参数 -->
            <div class="param-section uv-type-params" id="uvFragmentParams" style="display: none;">
              <div class="section-title">💎 碎片UV参数</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">碎片大小 (Fragment Size)</span>
                  <span class="param-value" id="uvFragmentSizeVal">8</span>
                </div>
                <input type="range" class="param-slider" id="uvFragmentSize"
                  min="2" max="20" step="1" value="8" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">变化强度 (Variation)</span>
                  <span class="param-value" id="uvFragmentVariationVal">60</span>
                </div>
                <input type="range" class="param-slider" id="uvFragmentVariation"
                  min="10" max="100" step="5" value="60" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">旋转角度 (Rotation)</span>
                  <span class="param-value" id="uvFragmentRotationVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvFragmentRotation"
                  min="0" max="360" step="15" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">📡 放射强度 (Radial)</span>
                  <span class="param-value" id="uvFragmentRadialVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvFragmentRadial"
                  min="-100" max="100" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🌀 扭曲强度 (Twist)</span>
                  <span class="param-value" id="uvFragmentTwistVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvFragmentTwist"
                  min="-180" max="180" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
            </div>

            <!-- 钻石UV专属参数 -->
            <div class="param-section uv-type-params" id="uvDiamondParams" style="display: none;">
              <div class="section-title">💠 钻石UV参数</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">闪光强度 (Sparkle Intensity)</span>
                  <span class="param-value" id="uvSparkleIntensityVal">40</span>
                </div>
                <input type="range" class="param-slider" id="uvSparkleIntensity"
                  min="10" max="100" step="5" value="40" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">闪光频率 (Sparkle Frequency)</span>
                  <span class="param-value" id="uvSparkleFrequencyVal">0.5</span>
                </div>
                <input type="range" class="param-slider" id="uvSparkleFrequency"
                  min="0.1" max="1.0" step="0.1" value="0.5" oninput="updateUVSettings()">
              </div>
              <!-- 钻石UV高级参数 -->
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🔄 旋转角度 (Rotation)</span>
                  <span class="param-value" id="uvDiamondRotationVal">0°</span>
                </div>
                <input type="range" class="param-slider" id="uvDiamondRotation"
                  min="0" max="360" step="15" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">📡 放射强度 (Radial)</span>
                  <span class="param-value" id="uvDiamondRadialVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvDiamondRadial"
                  min="-100" max="100" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🌀 扭曲强度 (Twist)</span>
                  <span class="param-value" id="uvDiamondTwistVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvDiamondTwist"
                  min="-180" max="180" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
            </div>

            <!-- 马赛克UV专属参数 -->
            <div class="param-section uv-type-params" id="uvMosaicParams" style="display: none;">
              <div class="section-title">🔷 马赛克UV参数</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">马赛克块大小 (Mosaic Size)</span>
                  <span class="param-value" id="uvMosaicSizeVal">6</span>
                </div>
                <input type="range" class="param-slider" id="uvMosaicSize"
                  min="2" max="15" step="1" value="6" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">变化强度 (Variation)</span>
                  <span class="param-value" id="uvMosaicVariationVal">80</span>
                </div>
                <input type="range" class="param-slider" id="uvMosaicVariation"
                  min="20" max="120" step="10" value="80" oninput="updateUVSettings()">
              </div>
              <!-- 马赛克UV高级参数 -->
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🔄 旋转角度 (Rotation)</span>
                  <span class="param-value" id="uvMosaicRotationVal">0°</span>
                </div>
                <input type="range" class="param-slider" id="uvMosaicRotation"
                  min="0" max="360" step="15" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">📡 放射强度 (Radial)</span>
                  <span class="param-value" id="uvMosaicRadialVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvMosaicRadial"
                  min="-100" max="100" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🌀 扭曲强度 (Twist)</span>
                  <span class="param-value" id="uvMosaicTwistVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvMosaicTwist"
                  min="-180" max="180" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
            </div>

            <!-- 磨砂UV专属参数 -->
            <div class="param-section uv-type-params" id="uvFrostedParams" style="display: none;">
              <div class="section-title">❄️ 磨砂UV参数</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">磨砂强度 (Frost Intensity)</span>
                  <span class="param-value" id="uvFrostIntensityVal">30</span>
                </div>
                <input type="range" class="param-slider" id="uvFrostIntensity"
                  min="10" max="60" step="5" value="30" oninput="updateUVSettings()">
              </div>
              <!-- 磨砂UV高级参数 -->
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🔄 旋转角度 (Rotation)</span>
                  <span class="param-value" id="uvFrostedRotationVal">0°</span>
                </div>
                <input type="range" class="param-slider" id="uvFrostedRotation"
                  min="0" max="360" step="15" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">📡 放射强度 (Radial)</span>
                  <span class="param-value" id="uvFrostedRadialVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvFrostedRadial"
                  min="-100" max="100" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🌀 扭曲强度 (Twist)</span>
                  <span class="param-value" id="uvFrostedTwistVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvFrostedTwist"
                  min="-180" max="180" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
            </div>

            <!-- ⭕ 同心圆UV专属参数 -->
            <div class="param-section uv-type-params" id="uvConcentricParams" style="display: none;">
              <div class="section-title">⭕ 同心圆UV参数</div>

              <!-- 模式选择 -->
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">模式 (Mode)</span>
                </div>
                <select class="param-select" id="uvConcentricMode" onchange="updateUVSettings()">
                  <option value="circle">标准圆形</option>
                  <option value="shape">图形缩小</option>
                </select>
              </div>

              <!-- 样式选择 -->
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">样式 (Style)</span>
                </div>
                <select class="param-select" id="uvConcentricStyle" onchange="updateUVSettings()">
                  <option value="ring">圆环</option>
                  <option value="dot">圆点</option>
                </select>
              </div>

              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">圆环数量 (Ring Count)</span>
                  <span class="param-value" id="uvRingCountVal">10</span>
                </div>
                <input type="range" class="param-slider" id="uvRingCount"
                  min="3" max="30" step="1" value="10" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">圆环间距 (Ring Spacing)</span>
                  <span class="param-value" id="uvRingSpacingVal">20</span>
                </div>
                <input type="range" class="param-slider" id="uvRingSpacing"
                  min="5" max="50" step="1" value="20" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">线条粗细 (Line Width)</span>
                  <span class="param-value" id="uvLineWidthVal">3</span>
                </div>
                <input type="range" class="param-slider" id="uvLineWidth"
                  min="1" max="10" step="0.5" value="3" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">渐变强度 (Gradient)</span>
                  <span class="param-value" id="uvGradientVal">50</span>
                </div>
                <input type="range" class="param-slider" id="uvGradient"
                  min="0" max="100" step="5" value="50" oninput="updateUVSettings()">
              </div>
              <!-- 圆点间距参数 -->
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">圆点间距 (Dot Spacing)</span>
                  <span class="param-value" id="uvDotSpacingVal">15</span>
                </div>
                <input type="range" class="param-slider" id="uvDotSpacing"
                  min="5" max="50" step="1" value="15" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">📡 放射强度 (Radial)</span>
                  <span class="param-value" id="uvConcentricRadialVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvConcentricRadial"
                  min="-100" max="100" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">🌀 扭曲强度 (Twist)</span>
                  <span class="param-value" id="uvConcentricTwistVal">0</span>
                </div>
                <input type="range" class="param-slider" id="uvConcentricTwist"
                  min="-180" max="180" step="0.1" value="0" oninput="updateUVSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">Quick Actions</div>
              <button class="param-btn" onclick="selectSameColorAsUV()">🎨 选择相同颜色</button>
              <button class="param-btn" onclick="selectClipMaskColors()">📎 选择 ClipMask 内颜色</button>
            </div>

            <div class="param-section">
              <div class="section-title">🔃 生成贴图 (Convert To)</div>
              <div class="param-btn-group">
                <button class="param-btn" onclick="applyGeneratedMapToPreview('normal')">应用到法线 (Apply)</button>
                <button class="param-btn" onclick="applyGeneratedMapToPreview('displacement')">应用到置换 (Apply)</button>
              </div>
              <div class="param-btn-group" style="margin-top: 4px;">
                <button class="param-btn" onclick="downloadCurrentMap('normal')">📥 下载法线</button>
                <button class="param-btn" onclick="downloadCurrentMap('displacement')">📥 下载置换</button>
              </div>
              <button class="secondary-btn" onclick="downloadAllGeneratedMaps()" style="margin-top: 4px;">📦 一键下载所有</button>
              <div style="font-size: 9px; color: var(--color-neutral-500); margin-top: 4px;">
                "应用"仅更新预览并记录到导出JSON，"下载"保存图片文件
              </div>
            </div>
          </div>

          <!-- 烫金面板 -->
          <div class="craft-param-panel" id="panelHotfoilGold" style="display: none;">
            <div class="param-section">
              <div class="section-title">参数调整</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">金属度 (Metallic)</span>
                  <span class="param-value" id="hotfoilGoldMetallicValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldMetallic"
                  min="0.8" max="1" step="0.01" value="1.0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">粗糙度 (Roughness)</span>
                  <span class="param-value" id="hotfoilGoldRoughnessValue">0.2</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldRoughness"
                  min="0" max="0.5" step="0.01" value="0.2" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">IOR (折射率)</span>
                  <span class="param-value" id="hotfoilGoldIORValue">1.5</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldIOR"
                  min="1.0" max="3.0" step="0.1" value="1.5" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">各向异性 (Anisotropic)</span>
                  <span class="param-value" id="hotfoilGoldAnisotropicValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldAnisotropic"
                  min="0" max="1" step="0.01" value="0.0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">高度 (Height)</span>
                  <span class="param-value" id="hotfoilGoldHeightValue">0.5</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldHeight"
                  min="0" max="2" step="0.1" value="0.5" oninput="updateHotfoilGoldSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">颜色调整</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">色调 (Hue)</span>
                  <span class="param-value" id="hotfoilGoldHueValue">45</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldHue"
                  min="0" max="60" step="1" value="45" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">饱和度 (Saturation)</span>
                  <span class="param-value" id="hotfoilGoldSaturationValue">0.8</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldSaturation"
                  min="0" max="1" step="0.01" value="0.8" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">亮度 (Brightness)</span>
                  <span class="param-value" id="hotfoilGoldBrightnessValue">0.9</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldBrightness"
                  min="0.5" max="1.5" step="0.01" value="0.9" oninput="updateHotfoilGoldSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">纹理效果</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">拉丝强度 (Brushed)</span>
                  <span class="param-value" id="hotfoilGoldBrushedValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldBrushed"
                  min="0" max="1" step="0.01" value="0.0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">纹理类型 (Texture Type)</span>
                </div>
                <select class="param-select" id="hotfoilGoldNoiseType" onchange="updateHotfoilGoldSettings()">
                  <option value="none">无纹理</option>
                  <option value="matte" selected>磨砂</option>
                  <option value="brushed-h">水平拉丝</option>
                  <option value="brushed-v">垂直拉丝</option>
                  <option value="brushed-radial">径向拉丝</option>
                  <option value="circular">圆环拉丝</option>
                  <option value="noise">细腻噪点</option>
                </select>
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">噪点强度 (Noise)</span>
                  <span class="param-value" id="hotfoilGoldNoiseValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldNoise"
                  min="0" max="1" step="0.001" value="0.0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">X 缩放 (Scale X)</span>
                  <span class="param-value" id="hotfoilGoldNoiseScaleXValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldNoiseScaleX"
                  min="0.001" max="100" step="0.001" value="1.0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">Y 缩放 (Scale Y)</span>
                  <span class="param-value" id="hotfoilGoldNoiseScaleYValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldNoiseScaleY"
                  min="0.001" max="100" step="0.001" value="1.0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">噪点旋转 (Rotation)</span>
                  <span class="param-value" id="hotfoilGoldNoiseRotationValue">0°</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldNoiseRotation"
                  min="0" max="360" step="1" value="0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">噪点频率 (Frequency)</span>
                  <span class="param-value" id="hotfoilGoldNoiseFrequencyValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldNoiseFrequency"
                  min="0.01" max="10" step="0.01" value="1.0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">条纹数量 (Stripe Count)</span>
                  <span class="param-value" id="hotfoilGoldStripeCountValue">10</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldStripeCount"
                  min="1" max="100" step="1" value="10" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">扭曲度 (Distortion)</span>
                  <span class="param-value" id="hotfoilGoldDistortionValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldDistortion"
                  min="0" max="5" step="0.01" value="0" oninput="updateHotfoilGoldSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">边缘调节</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">边缘柔和度 (Edge Softness)</span>
                  <span class="param-value" id="hotfoilGoldEdgeSoftnessValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldEdgeSoftness"
                  min="0" max="20" step="0.1" value="0" oninput="updateHotfoilGoldSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">边缘渐变 (Edge Fade)</span>
                  <span class="param-value" id="hotfoilGoldEdgeFadeValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilGoldEdgeFade"
                  min="0" max="100" step="0.5" value="0" oninput="updateHotfoilGoldSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">预设</div>
              <select class="param-select" id="hotfoilGoldPreset" onchange="selectHotfoilGoldPreset(this.value)">
                <option value="default">默认</option>
                <option value="bright">明亮</option>
                <option value="matte">哑光</option>
                <option value="glossy">高光</option>
              </select>
            </div>

            <div class="param-section">
              <div class="section-title">快捷操作</div>
              <button class="param-btn" onclick="selectSameColorAsHotfoilGold()">🎨 选择相同颜色</button>
            </div>
          </div>

          <!-- 烫银面板 -->
          <div class="craft-param-panel" id="panelHotfoilSilver" style="display: none;">
            <div class="param-section">
              <div class="section-title">参数调整</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">金属度 (Metallic)</span>
                  <span class="param-value" id="hotfoilSilverMetallicValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverMetallic"
                  min="0.8" max="1" step="0.01" value="1.0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">粗糙度 (Roughness)</span>
                  <span class="param-value" id="hotfoilSilverRoughnessValue">0.15</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverRoughness"
                  min="0" max="0.5" step="0.01" value="0.15" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">IOR (折射率)</span>
                  <span class="param-value" id="hotfoilSilverIORValue">1.5</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverIOR"
                  min="1.0" max="3.0" step="0.1" value="1.5" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">各向异性 (Anisotropic)</span>
                  <span class="param-value" id="hotfoilSilverAnisotropicValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverAnisotropic"
                  min="0" max="1" step="0.01" value="0.0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">高度 (Height)</span>
                  <span class="param-value" id="hotfoilSilverHeightValue">0.5</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverHeight"
                  min="0" max="2" step="0.1" value="0.5" oninput="updateHotfoilSilverSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">颜色调整</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">色调 (Hue)</span>
                  <span class="param-value" id="hotfoilSilverHueValue">0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverHue"
                  min="0" max="30" step="1" value="0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">饱和度 (Saturation)</span>
                  <span class="param-value" id="hotfoilSilverSaturationValue">0.1</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverSaturation"
                  min="0" max="0.5" step="0.01" value="0.1" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">亮度 (Brightness)</span>
                  <span class="param-value" id="hotfoilSilverBrightnessValue">0.95</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverBrightness"
                  min="0.5" max="1.5" step="0.01" value="0.95" oninput="updateHotfoilSilverSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">纹理效果</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">拉丝强度 (Brushed)</span>
                  <span class="param-value" id="hotfoilSilverBrushedValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverBrushed"
                  min="0" max="1" step="0.01" value="0.0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">纹理类型 (Texture Type)</span>
                </div>
                <select class="param-select" id="hotfoilSilverNoiseType" onchange="updateHotfoilSilverSettings()">
                  <option value="none">无纹理</option>
                  <option value="matte" selected>磨砂</option>
                  <option value="brushed-h">水平拉丝</option>
                  <option value="brushed-v">垂直拉丝</option>
                  <option value="brushed-radial">径向拉丝</option>
                  <option value="circular">圆环拉丝</option>
                  <option value="noise">细腻噪点</option>
                </select>
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">噪点强度 (Noise)</span>
                  <span class="param-value" id="hotfoilSilverNoiseValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverNoise"
                  min="0" max="1" step="0.001" value="0.0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">X 缩放 (Scale X)</span>
                  <span class="param-value" id="hotfoilSilverNoiseScaleXValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverNoiseScaleX"
                  min="0.001" max="100" step="0.001" value="1.0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">Y 缩放 (Scale Y)</span>
                  <span class="param-value" id="hotfoilSilverNoiseScaleYValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverNoiseScaleY"
                  min="0.001" max="100" step="0.001" value="1.0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">噪点旋转 (Rotation)</span>
                  <span class="param-value" id="hotfoilSilverNoiseRotationValue">0°</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverNoiseRotation"
                  min="0" max="360" step="1" value="0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">噪点频率 (Frequency)</span>
                  <span class="param-value" id="hotfoilSilverNoiseFrequencyValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverNoiseFrequency"
                  min="0.01" max="10" step="0.01" value="1.0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">条纹数量 (Stripe Count)</span>
                  <span class="param-value" id="hotfoilSilverStripeCountValue">10</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverStripeCount"
                  min="1" max="100" step="1" value="10" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">扭曲度 (Distortion)</span>
                  <span class="param-value" id="hotfoilSilverDistortionValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverDistortion"
                  min="0" max="5" step="0.01" value="0" oninput="updateHotfoilSilverSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">边缘调节</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">边缘柔和度 (Edge Softness)</span>
                  <span class="param-value" id="hotfoilSilverEdgeSoftnessValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverEdgeSoftness"
                  min="0" max="20" step="0.1" value="0" oninput="updateHotfoilSilverSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">边缘渐变 (Edge Fade)</span>
                  <span class="param-value" id="hotfoilSilverEdgeFadeValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="hotfoilSilverEdgeFade"
                  min="0" max="100" step="0.5" value="0" oninput="updateHotfoilSilverSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">预设</div>
              <select class="param-select" id="hotfoilSilverPreset" onchange="selectHotfoilSilverPreset(this.value)">
                <option value="default">默认</option>
                <option value="bright">明亮</option>
                <option value="matte">哑光</option>
                <option value="glossy">高光</option>
              </select>
            </div>

            <div class="param-section">
              <div class="section-title">快捷操作</div>
              <button class="param-btn" onclick="selectSameColorAsHotfoilSilver()">🎨 选择相同颜色</button>
            </div>
          </div>

          <!-- 置换面板 - Professional V3 -->
          <div class="craft-param-panel" id="panelDisplacement" style="display: none;">
            <!-- 核心参数 -->
            <div class="param-section">
              <div class="section-title">🎯 核心参数 (Core)</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">强度 (Strength)</span>
                  <span class="param-value" id="displacementStrengthValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="displacementStrength"
                  min="0" max="10.0" step="0.1" value="1.0" oninput="updateDisplacementSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">中点 (Midlevel)</span>
                  <span class="param-value" id="displacementMidlevelValue">0.5</span>
                </div>
                <input type="range" class="param-slider" id="displacementMidlevel"
                  min="0" max="1" step="0.01" value="0.5" oninput="updateDisplacementSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">缩放 (Scale)</span>
                  <span class="param-value" id="displacementScaleValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="displacementScale"
                  min="0.1" max="5.0" step="0.1" value="1.0" oninput="updateDisplacementSettings()">
              </div>
            </div>

            <!-- 滤镜参数 -->
            <div class="param-section">
              <div class="section-title">🎨 滤镜 (Filters)</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">对比度 (Contrast)</span>
                  <span class="param-value" id="displacementContrastValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="displacementContrast"
                  min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateDisplacementSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">亮度 (Brightness)</span>
                  <span class="param-value" id="displacementBrightnessValue">0</span>
                </div>
                <input type="range" class="param-slider" id="displacementBrightness"
                  min="-100" max="100" step="1" value="0" oninput="updateDisplacementSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">伽马 (Gamma)</span>
                  <span class="param-value" id="displacementGammaValue">1.0</span>
                </div>
                <input type="range" class="param-slider" id="displacementGamma"
                  min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateDisplacementSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">反转 (Invert)</span>
                  <span class="param-value" id="displacementInvertValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="displacementInvert"
                  min="0" max="1" step="0.01" value="0" oninput="updateDisplacementSettings()">
              </div>
            </div>

            <!-- 平滑参数 -->
            <div class="param-section">
              <div class="section-title">🔧 平滑 (Smoothing)</div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">模糊 (Blur)</span>
                  <span class="param-value" id="displacementBlurValue">0</span>
                </div>
                <input type="range" class="param-slider" id="displacementBlur"
                  min="0" max="50" step="1" value="0" oninput="updateDisplacementSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">锐化 (Sharpen)</span>
                  <span class="param-value" id="displacementSharpnessValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="displacementSharpness"
                  min="0" max="2.0" step="0.1" value="0" oninput="updateDisplacementSettings()">
              </div>
              <div class="param-row">
                <div class="param-header">
                  <span class="param-label">边缘柔和度 (Edge Softness)</span>
                  <span class="param-value" id="displacementEdgeSoftnessValue">0.0</span>
                </div>
                <input type="range" class="param-slider" id="displacementEdgeSoftness"
                  min="0" max="50" step="0.1" value="0" oninput="updateDisplacementSettings()">
              </div>
            </div>

            <div class="param-section">
              <div class="section-title">快捷操作</div>
              <button class="param-btn" onclick="selectSameColorAsDisplacement()">🎨 选择相同颜色</button>
            </div>
          </div>
        </div>
      </div>

      <div class="panel-footer">
        <button class="export-btn" id="exportBtn" onclick="doUnifiedExport()">
          🚀 Export to Blender
        </button>
      </div>
    </div>
  </div>

  <script>
    // State
    let clipModeEnabled = false;
    let craftVectorEnabled = false;
    let selectedVectors = [];
    let sourceFrameId = null;
    let markedLayers = [];
    let selectedLayerId = null;

    // Vector 点选排序状态
    let allVectors = [];
    let vectorOrderMap = {};
    let nextOrderNumber = 1;

    // 画布控制状态
    let canvasZoom = 1;
    let canvasPanX = 0;
    let canvasPanY = 0;
    
    // Override source for Normal Map preview (from "Convert To")
    let overrideNormalInput = null;

    // ============================================
    // 工艺参数状态
    // ============================================
    let embossSettings = {
      sdfSpread: 10, // 默认值改为 10，避免山脉效果
      sdfProfile: 'smoothstep',
      sdfMode: 'shrink',
      sdfSoftness: 1.0,
      heightScale: 1.5,
      rippleCount: 3, // 波纹数量（用于枕状浮雕）
      rippleWidth: 0.5, // 波纹粗细（0.1-1.0）
      rippleDash: 0 // 虚线效果（0=实线，0.1-0.9=虚线）
    };

    let metalSettings = {
      type: 'gold',
      texture: 'mirror',
      intensity: 0.5
    };

    let uvSettings = {
      gloss: 0.95,
      thickness: 0.5,
      roughness: 0.1,
      type: 'gloss',
      edgeSoftness: 0.0,
      edgeFade: 0.0,
      // 碎片UV参数
      fragmentSize: 8,
      fragmentVariation: 60,
      // 钻石UV参数
      sparkleIntensity: 40,
      sparkleFrequency: 0.5,
      // 马赛克UV参数
      mosaicSize: 6,
      mosaicVariation: 80,
      // 磨砂UV参数
      frostIntensity: 30
    };

    let hotfoilGoldSettings = {
      metallic: 1.0,
      roughness: 0.2,
      ior: 1.5,
      anisotropic: 0.0,
      heightScale: 0.5,
      hue: 45,
      saturation: 0.8,
      brightness: 0.9,
      brushed: 0.0,
      noiseType: 'matte',
      noise: 0.0,
      noiseScaleX: 1.0,
      noiseScaleY: 1.0,
      noiseRotation: 0,
      noiseFrequency: 1.0,
      stripeCount: 10,
      distortion: 0.0,
      edgeSoftness: 0.0,
      edgeFade: 0.0
    };

    let hotfoilSilverSettings = {
      metallic: 1.0,
      roughness: 0.15,
      ior: 1.5,
      anisotropic: 0.0,
      heightScale: 0.5,
      hue: 0,
      saturation: 0.1,
      brightness: 0.95,
      brushed: 0.0,
      noiseType: 'matte',
      noise: 0.0,
      noiseScaleX: 1.0,
      noiseScaleY: 1.0,
      noiseRotation: 0,
      noiseFrequency: 1.0,
      stripeCount: 10,
      distortion: 0.0,
      edgeSoftness: 0.0,
      edgeFade: 0.0
    };

    let displacementSettings = {
      strength: 1.0,
      midlevel: 0.5,
      scale: 1.0,
      contrast: 1.0,
      brightness: 0,
      gamma: 1.0,
      invert: 0.0,
      blur: 0,
      sharpness: 0.0,
      edgeSoftness: 0.0
    };

    // 防抖定时器
    let normalUpdateTimer = null;
    let displacementUpdateTimer = null;

    // 更新法线贴图参数
    function updateNormalSettings() {
      const strength = parseFloat(document.getElementById('normalStrength').value);
      const blur = parseInt(document.getElementById('normalBlur').value);
      const sharpness = parseFloat(document.getElementById('normalSharpness').value);
      const contrast = parseFloat(document.getElementById('normalContrast').value);
      const brightness = parseInt(document.getElementById('normalBrightness').value);
      const edgeSoftness = parseFloat(document.getElementById('normalEdgeSoftness').value);

      // Grayscale Weights
      const wR = parseFloat(document.getElementById('weightR').value);
      const wG = parseFloat(document.getElementById('weightG').value);
      const wB = parseFloat(document.getElementById('weightB').value);
      const wC = parseFloat(document.getElementById('weightC').value);
      const wM = parseFloat(document.getElementById('weightM').value);
      const wY = parseFloat(document.getElementById('weightY').value);

      normalMapSettings.strength = strength;
      normalMapSettings.blurRadius = blur;
      normalMapSettings.sharpness = sharpness;
      normalMapSettings.contrast = contrast;
      normalMapSettings.brightness = brightness;
      normalMapSettings.edgeSoftness = edgeSoftness;
      
      normalMapSettings.weightR = wR;
      normalMapSettings.weightG = wG;
      normalMapSettings.weightB = wB;
      normalMapSettings.weightC = wC;
      normalMapSettings.weightM = wM;
      normalMapSettings.weightY = wY;

      // 立即更新 UI 数值显示，不延迟
      requestAnimationFrame(() => {
        document.getElementById('normalStrengthVal').textContent = strength.toFixed(1);
        document.getElementById('normalBlurVal').textContent = blur;
        document.getElementById('normalSharpnessVal').textContent = sharpness.toFixed(1);
        document.getElementById('normalContrastVal').textContent = contrast.toFixed(1);
        document.getElementById('normalBrightnessVal').textContent = brightness;
        document.getElementById('normalEdgeSoftnessVal').textContent = edgeSoftness.toFixed(1);
        
        document.getElementById('weightRVal').textContent = wR.toFixed(2);
        document.getElementById('weightGVal').textContent = wG.toFixed(2);
        document.getElementById('weightBVal').textContent = wB.toFixed(2);
        document.getElementById('weightCVal').textContent = wC.toFixed(2);
        document.getElementById('weightMVal').textContent = wM.toFixed(2);
        document.getElementById('weightYVal').textContent = wY.toFixed(2);
      });

      // 防抖：延迟执行重计算（100ms），避免高频触发计算导致卡顿
      if (normalUpdateTimer) cancelAnimationFrame(normalUpdateTimer);
      normalUpdateTimer = requestAnimationFrame(() => {
        renderCache.invalidate('normal');
        saveCurrentLayerSettings();
        updateNormalPreview();

        // 降低缩略图更新频率，优先更新大图预览
        if (window.currentCraftType === 'normal') {
          const largeCanvas = document.getElementById('craftLargePreviewCanvas');
          if (largeCanvas) {
            renderCraftLargePreview(largeCanvas, 'normal');
          }
        }

        // 只更新 normal 缩略图
        scheduleThumbnailUpdate('normal');
      });
    }

    // 防抖定时器
    let embossUpdateTimer = null;
    let hotfoilGoldUpdateTimer = null;
    let hotfoilSilverUpdateTimer = null;
    let thumbnailUpdateTimer = null;

    // 渲染缓存 - 避免重复计算
    const renderCache = {
      thumbnails: new Map(),
      largePreview: new Map(),
      lastHeightDataHash: null,
      invalidate(craftType) {
        if (craftType) {
          this.thumbnails.delete(craftType);
          this.largePreview.delete(craftType);
        } else {
          this.thumbnails.clear();
          this.largePreview.clear();
        }
      },
      invalidateAll() {
        this.thumbnails.clear();
        this.largePreview.clear();
        this.lastHeightDataHash = null;
      }
    };

    // 更新凹凸参数
    function updateEmbossSettings() {
      const spread = parseFloat(document.getElementById('sdfSpread').value);
      const scale = parseFloat(document.getElementById('heightScale').value);
      const softness = parseFloat(document.getElementById('sdfSoftness').value);
      const rippleCount = parseInt(document.getElementById('rippleCount').value);
      const rippleWidth = parseFloat(document.getElementById('rippleWidth').value);
      const rippleDash = parseFloat(document.getElementById('rippleDash').value);

      embossSettings.sdfSpread = spread;
      embossSettings.heightScale = scale;
      embossSettings.sdfSoftness = softness;
      embossSettings.rippleCount = rippleCount;
      embossSettings.rippleWidth = rippleWidth;
      embossSettings.rippleDash = rippleDash;

      // 立即更新显示值（无延迟）
      document.getElementById('sdfSpreadVal').textContent = spread.toFixed(1);
      document.getElementById('heightScaleVal').textContent = scale.toFixed(1);
      document.getElementById('sdfSoftnessVal').textContent = softness.toFixed(1);
      document.getElementById('rippleCountVal').textContent = rippleCount;
      document.getElementById('rippleWidthVal').textContent = rippleWidth.toFixed(2);
      document.getElementById('rippleDashVal').textContent = rippleDash.toFixed(2);

      // 防抖：延迟执行重计算（150ms）
      clearTimeout(embossUpdateTimer);
      embossUpdateTimer = setTimeout(() => {
        renderCache.invalidate('emboss');
        updateEmbossPreview();
        scheduleThumbnailUpdate('emboss');

        // 🎨 实时更新大图预览
        if (window.currentCraftType === 'emboss') {
          const largeCanvas = document.getElementById('craftLargePreviewCanvas');
          if (largeCanvas) {
            renderCraftLargePreview(largeCanvas, 'emboss');
          }
        }
      }, 150); // 150ms 延迟

      // Update mask mode switch
      const maskModeSw = document.getElementById('embossMaskModeSwitch');
      if (maskModeSw) {
          maskModeSw.classList.toggle('active', (embossSettings.maskMode || 'alpha') === 'luminance');
      }
    }

    // 设置 SDF 模式
    function setSdfMode(mode) {
      embossSettings.sdfMode = mode;
      document.getElementById('sdfExpand').classList.toggle('active', mode === 'expand');
      document.getElementById('sdfShrink').classList.toggle('active', mode === 'shrink');

      // 使用防抖优化
      clearTimeout(embossUpdateTimer);
      embossUpdateTimer = setTimeout(() => {
        renderCache.invalidate('emboss');
        updateEmbossPreview();
        scheduleThumbnailUpdate('emboss');
        if (window.currentCraftType === 'emboss') {
          const largeCanvas = document.getElementById('craftLargePreviewCanvas');
          if (largeCanvas) renderCraftLargePreview(largeCanvas, 'emboss');
        }
      }, 100);
    }

    // Toggle UV Mask Mode
    function toggleUVMaskMode() {
      const current = uvSettings.maskMode || 'alpha';
      uvSettings.maskMode = current === 'alpha' ? 'luminance' : 'alpha';
      
      const sw = document.getElementById('uvMaskModeSwitch');
      if (sw) sw.classList.toggle('active', uvSettings.maskMode === 'luminance');
      
      updateUVSettings();
    }

    // Toggle UV Mask Invert
    function toggleUVMaskInvert() {
      uvSettings.maskInvert = !uvSettings.maskInvert;
      const sw = document.getElementById('uvMaskInvertSwitch');
      if (sw) sw.classList.toggle('active', uvSettings.maskInvert);
      updateUVSettings();
    }

    // Toggle Emboss Mask Mode
    function toggleEmbossMaskMode() {
      const current = embossSettings.maskMode || 'alpha';
      embossSettings.maskMode = current === 'alpha' ? 'luminance' : 'alpha';
      
      const sw = document.getElementById('embossMaskModeSwitch');
      if (sw) sw.classList.toggle('active', embossSettings.maskMode === 'luminance');
      
      updateEmbossSettings();
    }

    // Toggle Emboss Mask Invert
    function toggleEmbossMaskInvert() {
      embossSettings.maskInvert = !embossSettings.maskInvert;
      const sw = document.getElementById('embossMaskInvertSwitch');
      if (sw) sw.classList.toggle('active', embossSettings.maskInvert);
      updateEmbossSettings();
    }

    function setEmbossProfile(profile) {
      embossSettings.sdfProfile = profile;
      // 更新按钮激活状态
      const buttons = document.querySelectorAll('#panelEmboss .param-btn-group:last-child .param-btn');
      buttons.forEach(btn => {
        btn.classList.remove('active');
        const onclick = btn.getAttribute('onclick');
        if (onclick && onclick.includes(`'${profile}'`)) {
          btn.classList.add('active');
        }
      });

      // 使用防抖优化
      clearTimeout(embossUpdateTimer);
      embossUpdateTimer = setTimeout(() => {
        renderCache.invalidate('emboss');
        updateEmbossPreview();
        scheduleThumbnailUpdate('emboss');
        if (window.currentCraftType === 'emboss') {
          const largeCanvas = document.getElementById('craftLargePreviewCanvas');
          if (largeCanvas) renderCraftLargePreview(largeCanvas, 'emboss');
        }
      }, 100);
    }

    // 更新金属参数
    function updateMetalSettings() {
      metalSettings.type = document.getElementById('metalType').value;
      metalSettings.texture = document.getElementById('metalTexture').value;
      metalSettings.intensity = parseFloat(document.getElementById('metalIntensity').value);
      document.getElementById('metalIntensityVal').textContent = metalSettings.intensity.toFixed(1);
      updateMetalPreview();
    }

    // UV 预设定义
    const UV_PRESETS = {
      'gloss': { gloss: 0.95, roughness: 0.05 },
      'semi': { gloss: 0.75, roughness: 0.25 },
      'satin': { gloss: 0.60, roughness: 0.40 },
      'matte': { gloss: 0.10, roughness: 0.90 },
      'reverse': { gloss: 0.95, roughness: 0.05 }, // 反向UV通常也是高光
      'frosted': { gloss: 0.5, roughness: 0.5, frostIntensity: 30 }, // 磨砂需要中等光泽度以显示噪点
      'fragment': { gloss: 0.9, fragmentSize: 8, fragmentVariation: 60 },
      'diamond': { gloss: 0.95, sparkleIntensity: 40 },
      'mosaic': { gloss: 0.9, mosaicSize: 6 },
      'concentric': { gloss: 0.95, ringCount: 10 }
    };

    // 更新 UV 参数
    // 选择UV预设
    function selectUVPreset(uvType) {
      // 更新UV类型
      uvSettings.type = uvType;

      // 应用预设值
      if (UV_PRESETS[uvType]) {
        const preset = UV_PRESETS[uvType];
        if (preset.gloss !== undefined) {
          uvSettings.gloss = preset.gloss;
          document.getElementById('uvGloss').value = preset.gloss;
        }
        if (preset.roughness !== undefined) {
          uvSettings.roughness = preset.roughness;
          document.getElementById('uvRoughness').value = preset.roughness;
        }
        // 更新其他可能的预设值...
      }

      // 更新按钮激活状态
      document.querySelectorAll('.uv-preset-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-uv-type="${uvType}"]`).classList.add('active');

      // 隐藏所有UV类型参数面板
      document.querySelectorAll('.uv-type-params').forEach(panel => {
        panel.style.display = 'none';
      });

      // 显示对应的参数面板
      if (uvType === 'fragment') {
        document.getElementById('uvFragmentParams').style.display = 'block';
      } else if (uvType === 'diamond') {
        document.getElementById('uvDiamondParams').style.display = 'block';
      } else if (uvType === 'mosaic') {
        document.getElementById('uvMosaicParams').style.display = 'block';
      } else if (uvType === 'frosted') {
        document.getElementById('uvFrostedParams').style.display = 'block';
      } else if (uvType === 'concentric') {
        document.getElementById('uvConcentricParams').style.display = 'block';
      }

      // 更新预览
      updateUVSettings();
    }

    function updateUVSettings() {
      uvSettings.gloss = parseFloat(document.getElementById('uvGloss').value);
      uvSettings.thickness = parseFloat(document.getElementById('uvThickness').value);
      uvSettings.roughness = parseFloat(document.getElementById('uvRoughness').value);
      uvSettings.edgeSoftness = parseFloat(document.getElementById('uvEdgeSoftness').value);
      // 🔥 绑定锐化参数（安全检查）
      const sharpenEl = document.getElementById('uvSharpen');
      uvSettings.sharpen = sharpenEl ? parseFloat(sharpenEl.value) : 0;

      // 读取专属参数
      const uvType = uvSettings.type || 'gloss';
      if (uvType === 'fragment') {
        uvSettings.fragmentSize = parseInt(document.getElementById('uvFragmentSize').value);
        uvSettings.fragmentVariation = parseInt(document.getElementById('uvFragmentVariation').value);
        // 🔥 绑定高级参数
        uvSettings.fragmentRotation = parseInt(document.getElementById('uvFragmentRotation').value);
        uvSettings.fragmentRadial = parseFloat(document.getElementById('uvFragmentRadial').value);
        uvSettings.fragmentTwist = parseFloat(document.getElementById('uvFragmentTwist').value);
        document.getElementById('uvFragmentSizeVal').textContent = uvSettings.fragmentSize;
        document.getElementById('uvFragmentVariationVal').textContent = uvSettings.fragmentVariation;
        document.getElementById('uvFragmentRotationVal').textContent = uvSettings.fragmentRotation + '°';
        document.getElementById('uvFragmentRadialVal').textContent = uvSettings.fragmentRadial.toFixed(1);
        document.getElementById('uvFragmentTwistVal').textContent = uvSettings.fragmentTwist.toFixed(1);
      } else if (uvType === 'diamond') {
        uvSettings.sparkleIntensity = parseInt(document.getElementById('uvSparkleIntensity').value);
        uvSettings.sparkleFrequency = parseFloat(document.getElementById('uvSparkleFrequency').value);
        // 🔥 绑定高级参数
        uvSettings.diamondRotation = parseInt(document.getElementById('uvDiamondRotation').value);
        uvSettings.diamondRadial = parseFloat(document.getElementById('uvDiamondRadial').value);
        uvSettings.diamondTwist = parseFloat(document.getElementById('uvDiamondTwist').value);
        document.getElementById('uvSparkleIntensityVal').textContent = uvSettings.sparkleIntensity;
        document.getElementById('uvSparkleFrequencyVal').textContent = uvSettings.sparkleFrequency.toFixed(1);
        document.getElementById('uvDiamondRotationVal').textContent = uvSettings.diamondRotation + '°';
        document.getElementById('uvDiamondRadialVal').textContent = uvSettings.diamondRadial.toFixed(1);
        document.getElementById('uvDiamondTwistVal').textContent = uvSettings.diamondTwist.toFixed(1);
      } else if (uvType === 'mosaic') {
        uvSettings.mosaicSize = parseInt(document.getElementById('uvMosaicSize').value);
        uvSettings.mosaicVariation = parseInt(document.getElementById('uvMosaicVariation').value);
        // 🔥 绑定高级参数
        uvSettings.mosaicRotation = parseInt(document.getElementById('uvMosaicRotation').value);
        uvSettings.mosaicRadial = parseFloat(document.getElementById('uvMosaicRadial').value);
        uvSettings.mosaicTwist = parseFloat(document.getElementById('uvMosaicTwist').value);
        document.getElementById('uvMosaicSizeVal').textContent = uvSettings.mosaicSize;
        document.getElementById('uvMosaicVariationVal').textContent = uvSettings.mosaicVariation;
        document.getElementById('uvMosaicRotationVal').textContent = uvSettings.mosaicRotation + '°';
        document.getElementById('uvMosaicRadialVal').textContent = uvSettings.mosaicRadial.toFixed(1);
        document.getElementById('uvMosaicTwistVal').textContent = uvSettings.mosaicTwist.toFixed(1);
      } else if (uvType === 'frosted') {
        uvSettings.frostIntensity = parseInt(document.getElementById('uvFrostIntensity').value);
        // 🔥 绑定高级参数
        uvSettings.frostedRotation = parseInt(document.getElementById('uvFrostedRotation').value);
        uvSettings.frostedRadial = parseFloat(document.getElementById('uvFrostedRadial').value);
        uvSettings.frostedTwist = parseFloat(document.getElementById('uvFrostedTwist').value);
        document.getElementById('uvFrostIntensityVal').textContent = uvSettings.frostIntensity;
        document.getElementById('uvFrostedRotationVal').textContent = uvSettings.frostedRotation + '°';
        document.getElementById('uvFrostedRadialVal').textContent = uvSettings.frostedRadial.toFixed(1);
        document.getElementById('uvFrostedTwistVal').textContent = uvSettings.frostedTwist.toFixed(1);
      } else if (uvType === 'concentric') {
        uvSettings.concentricMode = document.getElementById('uvConcentricMode').value;
        uvSettings.concentricStyle = document.getElementById('uvConcentricStyle').value;
        uvSettings.ringCount = parseInt(document.getElementById('uvRingCount').value);
        uvSettings.ringSpacing = parseInt(document.getElementById('uvRingSpacing').value);
        uvSettings.lineWidth = parseFloat(document.getElementById('uvLineWidth').value);
        uvSettings.gradient = parseInt(document.getElementById('uvGradient').value);
        uvSettings.dotSpacing = parseInt(document.getElementById('uvDotSpacing').value);
        document.getElementById('uvRingCountVal').textContent = uvSettings.ringCount;
        document.getElementById('uvRingSpacingVal').textContent = uvSettings.ringSpacing;
        document.getElementById('uvLineWidthVal').textContent = uvSettings.lineWidth.toFixed(1);
        document.getElementById('uvGradientVal').textContent = uvSettings.gradient;
        document.getElementById('uvDotSpacingVal').textContent = uvSettings.dotSpacing;
        uvSettings.concentricRadial = parseFloat(document.getElementById('uvConcentricRadial').value);
        document.getElementById('uvConcentricRadialVal').textContent = uvSettings.concentricRadial.toFixed(1);
        uvSettings.concentricTwist = parseFloat(document.getElementById('uvConcentricTwist').value);
        document.getElementById('uvConcentricTwistVal').textContent = uvSettings.concentricTwist.toFixed(1);
      }

      document.getElementById('uvGlossVal').textContent = uvSettings.gloss.toFixed(2);
      document.getElementById('uvThicknessVal').textContent = uvSettings.thickness.toFixed(2);
      document.getElementById('uvRoughnessVal').textContent = uvSettings.roughness.toFixed(2);
      document.getElementById('uvEdgeSoftnessVal').textContent = uvSettings.edgeSoftness.toFixed(1);
      // 🔥 更新锐化参数显示（安全检查）
      const sharpenValEl = document.getElementById('uvSharpenVal');
      if (sharpenValEl) {
        sharpenValEl.textContent = uvSettings.sharpen.toFixed(1);
      }
      // 🔥 更新模糊参数显示（安全检查）
      const blurValEl = document.getElementById('uvBlurVal');
      if (blurValEl) {
        uvSettings.blur = parseFloat(document.getElementById('uvBlur').value);
        blurValEl.textContent = uvSettings.blur.toFixed(1);
      }

      renderCache.invalidate('uv');
      updateUVPreview();

      // 🎨 实时更新大图预览
      if (window.currentCraftType === 'uv') {
        const largeCanvas = document.getElementById('craftLargePreviewCanvas');
        if (largeCanvas) {
          renderCraftLargePreview(largeCanvas, 'uv');
        }
      }
    }

    // 预览更新函数
    function updateEmbossPreview() {
      if (!previewHeightData) return;
      const canvas = document.getElementById('embossPreview');
      if (!canvas) return; // 如果canvas不存在，直接返回
      const ctx = canvas.getContext('2d');

      // 使用 SDF 生成高度图
      const sdfData = generateSDF(previewHeightData, previewWidth, previewHeight, {
        spread: embossSettings.sdfSpread,
        profile: embossSettings.sdfProfile,
        mode: embossSettings.sdfMode || 'shrink',
        softness: embossSettings.sdfSoftness || 1.0,
        rippleCount: embossSettings.rippleCount || 3,
        rippleWidth: embossSettings.rippleWidth || 0.5,
        rippleDash: embossSettings.rippleDash || 0,
        threshold: 128
      });

      // 应用高度缩放
      for (let i = 0; i < sdfData.length; i += 4) {
        const v = Math.min(255, sdfData[i] * embossSettings.heightScale);
        sdfData[i] = sdfData[i + 1] = sdfData[i + 2] = v;
      }

      const imgData = new ImageData(sdfData, previewWidth, previewHeight);
      canvas.width = previewWidth;
      canvas.height = previewHeight;
      ctx.putImageData(imgData, 0, 0);

      // 同步更新大图预览
      updateCraftLargePreview();
    }

    function updateMetalPreview() {
      const canvas = document.getElementById('metalPreview');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      canvas.width = 100;
      canvas.height = 100;

      // 生成金属纹理预览
      const imgData = ctx.createImageData(100, 100);
      generateMetalTexture(imgData.data, 100, 100, metalSettings);
      ctx.putImageData(imgData, 0, 0);
    }

    function updateUVPreview() {
      const canvas = document.getElementById('uvPreview');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      canvas.width = 100;
      canvas.height = 100;

      // UV 光油预览 - 显示粗糙度
      const roughness = Math.round((1 - uvSettings.gloss) * 255);
      ctx.fillStyle = `rgb(${roughness}, ${roughness}, ${roughness})`;
      ctx.fillRect(0, 0, 100, 100);
      ctx.fillStyle = '#fff';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`R: ${(1 - uvSettings.gloss).toFixed(2)}`, 50, 55);
    }

    // 更新烫金设置
    function updateHotfoilGoldSettings() {
      hotfoilGoldSettings.metallic = parseFloat(document.getElementById('hotfoilGoldMetallic').value);
      hotfoilGoldSettings.roughness = parseFloat(document.getElementById('hotfoilGoldRoughness').value);
      hotfoilGoldSettings.ior = parseFloat(document.getElementById('hotfoilGoldIOR').value);
      hotfoilGoldSettings.anisotropic = parseFloat(document.getElementById('hotfoilGoldAnisotropic').value);
      hotfoilGoldSettings.heightScale = parseFloat(document.getElementById('hotfoilGoldHeight').value);
      hotfoilGoldSettings.hue = parseFloat(document.getElementById('hotfoilGoldHue').value);
      hotfoilGoldSettings.saturation = parseFloat(document.getElementById('hotfoilGoldSaturation').value);
      hotfoilGoldSettings.brightness = parseFloat(document.getElementById('hotfoilGoldBrightness').value);
      hotfoilGoldSettings.brushed = parseFloat(document.getElementById('hotfoilGoldBrushed').value);
      hotfoilGoldSettings.noiseType = document.getElementById('hotfoilGoldNoiseType').value;
      hotfoilGoldSettings.noise = parseFloat(document.getElementById('hotfoilGoldNoise').value);
      hotfoilGoldSettings.noiseScaleX = parseFloat(document.getElementById('hotfoilGoldNoiseScaleX').value);
      hotfoilGoldSettings.noiseScaleY = parseFloat(document.getElementById('hotfoilGoldNoiseScaleY').value);
      hotfoilGoldSettings.noiseRotation = parseFloat(document.getElementById('hotfoilGoldNoiseRotation').value);
      hotfoilGoldSettings.noiseFrequency = parseFloat(document.getElementById('hotfoilGoldNoiseFrequency').value);
      hotfoilGoldSettings.stripeCount = parseFloat(document.getElementById('hotfoilGoldStripeCount').value);
      hotfoilGoldSettings.distortion = parseFloat(document.getElementById('hotfoilGoldDistortion').value);
      hotfoilGoldSettings.edgeSoftness = parseFloat(document.getElementById('hotfoilGoldEdgeSoftness').value);
      hotfoilGoldSettings.edgeFade = parseFloat(document.getElementById('hotfoilGoldEdgeFade').value);

      document.getElementById('hotfoilGoldMetallicValue').textContent = hotfoilGoldSettings.metallic.toFixed(2);
      document.getElementById('hotfoilGoldRoughnessValue').textContent = hotfoilGoldSettings.roughness.toFixed(2);
      document.getElementById('hotfoilGoldIORValue').textContent = hotfoilGoldSettings.ior.toFixed(1);
      document.getElementById('hotfoilGoldAnisotropicValue').textContent = hotfoilGoldSettings.anisotropic.toFixed(2);
      document.getElementById('hotfoilGoldHeightValue').textContent = hotfoilGoldSettings.heightScale.toFixed(1);
      document.getElementById('hotfoilGoldHueValue').textContent = hotfoilGoldSettings.hue.toFixed(0);
      document.getElementById('hotfoilGoldSaturationValue').textContent = hotfoilGoldSettings.saturation.toFixed(2);
      document.getElementById('hotfoilGoldBrightnessValue').textContent = hotfoilGoldSettings.brightness.toFixed(2);
      document.getElementById('hotfoilGoldBrushedValue').textContent = hotfoilGoldSettings.brushed.toFixed(2);
      document.getElementById('hotfoilGoldNoiseValue').textContent = hotfoilGoldSettings.noise.toFixed(3);
      document.getElementById('hotfoilGoldNoiseScaleXValue').textContent = hotfoilGoldSettings.noiseScaleX.toFixed(2);
      document.getElementById('hotfoilGoldNoiseScaleYValue').textContent = hotfoilGoldSettings.noiseScaleY.toFixed(2);
      document.getElementById('hotfoilGoldNoiseRotationValue').textContent = hotfoilGoldSettings.noiseRotation.toFixed(0) + '°';
      document.getElementById('hotfoilGoldNoiseFrequencyValue').textContent = hotfoilGoldSettings.noiseFrequency.toFixed(2);
      document.getElementById('hotfoilGoldStripeCountValue').textContent = hotfoilGoldSettings.stripeCount.toFixed(0);
      document.getElementById('hotfoilGoldDistortionValue').textContent = hotfoilGoldSettings.distortion.toFixed(2);
      document.getElementById('hotfoilGoldEdgeSoftnessValue').textContent = hotfoilGoldSettings.edgeSoftness.toFixed(1);
      document.getElementById('hotfoilGoldEdgeFadeValue').textContent = hotfoilGoldSettings.edgeFade.toFixed(1);

      // 防抖优化：延迟执行重计算
      clearTimeout(hotfoilGoldUpdateTimer);
      hotfoilGoldUpdateTimer = setTimeout(() => {
        renderCache.invalidate('hot-stamping-gold');
        updateHotfoilGoldPreview();
        scheduleThumbnailUpdate('hot-stamping-gold');
        if (window.currentCraftType === 'hot-stamping-gold') {
          updateCraftLargePreview();
        }
      }, 100);
    }

    // 更新烫银设置
    function updateHotfoilSilverSettings() {
      hotfoilSilverSettings.metallic = parseFloat(document.getElementById('hotfoilSilverMetallic').value);
      hotfoilSilverSettings.roughness = parseFloat(document.getElementById('hotfoilSilverRoughness').value);
      hotfoilSilverSettings.ior = parseFloat(document.getElementById('hotfoilSilverIOR').value);
      hotfoilSilverSettings.anisotropic = parseFloat(document.getElementById('hotfoilSilverAnisotropic').value);
      hotfoilSilverSettings.heightScale = parseFloat(document.getElementById('hotfoilSilverHeight').value);
      hotfoilSilverSettings.hue = parseFloat(document.getElementById('hotfoilSilverHue').value);
      hotfoilSilverSettings.saturation = parseFloat(document.getElementById('hotfoilSilverSaturation').value);
      hotfoilSilverSettings.brightness = parseFloat(document.getElementById('hotfoilSilverBrightness').value);
      hotfoilSilverSettings.brushed = parseFloat(document.getElementById('hotfoilSilverBrushed').value);
      hotfoilSilverSettings.noiseType = document.getElementById('hotfoilSilverNoiseType').value;
      hotfoilSilverSettings.noise = parseFloat(document.getElementById('hotfoilSilverNoise').value);
      hotfoilSilverSettings.noiseScaleX = parseFloat(document.getElementById('hotfoilSilverNoiseScaleX').value);
      hotfoilSilverSettings.noiseScaleY = parseFloat(document.getElementById('hotfoilSilverNoiseScaleY').value);
      hotfoilSilverSettings.noiseRotation = parseFloat(document.getElementById('hotfoilSilverNoiseRotation').value);
      hotfoilSilverSettings.noiseFrequency = parseFloat(document.getElementById('hotfoilSilverNoiseFrequency').value);
      hotfoilSilverSettings.stripeCount = parseFloat(document.getElementById('hotfoilSilverStripeCount').value);
      hotfoilSilverSettings.distortion = parseFloat(document.getElementById('hotfoilSilverDistortion').value);
      hotfoilSilverSettings.edgeSoftness = parseFloat(document.getElementById('hotfoilSilverEdgeSoftness').value);
      hotfoilSilverSettings.edgeFade = parseFloat(document.getElementById('hotfoilSilverEdgeFade').value);

      document.getElementById('hotfoilSilverMetallicValue').textContent = hotfoilSilverSettings.metallic.toFixed(2);
      document.getElementById('hotfoilSilverRoughnessValue').textContent = hotfoilSilverSettings.roughness.toFixed(2);
      document.getElementById('hotfoilSilverIORValue').textContent = hotfoilSilverSettings.ior.toFixed(1);
      document.getElementById('hotfoilSilverAnisotropicValue').textContent = hotfoilSilverSettings.anisotropic.toFixed(2);
      document.getElementById('hotfoilSilverHeightValue').textContent = hotfoilSilverSettings.heightScale.toFixed(1);
      document.getElementById('hotfoilSilverHueValue').textContent = hotfoilSilverSettings.hue.toFixed(0);
      document.getElementById('hotfoilSilverSaturationValue').textContent = hotfoilSilverSettings.saturation.toFixed(2);
      document.getElementById('hotfoilSilverBrightnessValue').textContent = hotfoilSilverSettings.brightness.toFixed(2);
      document.getElementById('hotfoilSilverBrushedValue').textContent = hotfoilSilverSettings.brushed.toFixed(2);
      document.getElementById('hotfoilSilverNoiseValue').textContent = hotfoilSilverSettings.noise.toFixed(3);
      document.getElementById('hotfoilSilverNoiseScaleXValue').textContent = hotfoilSilverSettings.noiseScaleX.toFixed(2);
      document.getElementById('hotfoilSilverNoiseScaleYValue').textContent = hotfoilSilverSettings.noiseScaleY.toFixed(2);
      document.getElementById('hotfoilSilverNoiseRotationValue').textContent = hotfoilSilverSettings.noiseRotation.toFixed(0) + '°';
      document.getElementById('hotfoilSilverNoiseFrequencyValue').textContent = hotfoilSilverSettings.noiseFrequency.toFixed(2);
      document.getElementById('hotfoilSilverStripeCountValue').textContent = hotfoilSilverSettings.stripeCount.toFixed(0);
      document.getElementById('hotfoilSilverDistortionValue').textContent = hotfoilSilverSettings.distortion.toFixed(2);
      document.getElementById('hotfoilSilverEdgeSoftnessValue').textContent = hotfoilSilverSettings.edgeSoftness.toFixed(1);
      document.getElementById('hotfoilSilverEdgeFadeValue').textContent = hotfoilSilverSettings.edgeFade.toFixed(1);

      // 防抖优化：延迟执行重计算
      clearTimeout(hotfoilSilverUpdateTimer);
      hotfoilSilverUpdateTimer = setTimeout(() => {
        renderCache.invalidate('hot-stamping-silver');
        updateHotfoilSilverPreview();
        scheduleThumbnailUpdate('hot-stamping-silver');
        if (window.currentCraftType === 'hot-stamping-silver') {
          updateCraftLargePreview();
        }
      }, 100);
    }

    // 更新置换设置
    function updateDisplacementSettings() {
      displacementSettings.strength = parseFloat(document.getElementById('displacementStrength').value);
      displacementSettings.midlevel = parseFloat(document.getElementById('displacementMidlevel').value);
      displacementSettings.scale = parseFloat(document.getElementById('displacementScale').value);
      displacementSettings.contrast = parseFloat(document.getElementById('displacementContrast').value);
      displacementSettings.brightness = parseInt(document.getElementById('displacementBrightness').value);
      displacementSettings.gamma = parseFloat(document.getElementById('displacementGamma').value);
      displacementSettings.invert = parseFloat(document.getElementById('displacementInvert').value);
      displacementSettings.blur = parseInt(document.getElementById('displacementBlur').value);
      displacementSettings.sharpness = parseFloat(document.getElementById('displacementSharpness').value);
      displacementSettings.edgeSoftness = parseFloat(document.getElementById('displacementEdgeSoftness').value);

      document.getElementById('displacementStrengthValue').textContent = displacementSettings.strength.toFixed(1);
      document.getElementById('displacementMidlevelValue').textContent = displacementSettings.midlevel.toFixed(2);
      document.getElementById('displacementScaleValue').textContent = displacementSettings.scale.toFixed(1);
      document.getElementById('displacementContrastValue').textContent = displacementSettings.contrast.toFixed(1);
      document.getElementById('displacementBrightnessValue').textContent = displacementSettings.brightness;
      document.getElementById('displacementGammaValue').textContent = displacementSettings.gamma.toFixed(1);
      document.getElementById('displacementInvertValue').textContent = displacementSettings.invert.toFixed(2);
      document.getElementById('displacementBlurValue').textContent = displacementSettings.blur;
      document.getElementById('displacementSharpnessValue').textContent = displacementSettings.sharpness.toFixed(1);
      document.getElementById('displacementEdgeSoftnessValue').textContent = displacementSettings.edgeSoftness.toFixed(1);

      // 防抖优化：延迟执行重计算
      clearTimeout(displacementUpdateTimer);
      displacementUpdateTimer = setTimeout(() => {
        renderCache.invalidate('displacement');
        scheduleThumbnailUpdate('displacement');
        if (window.currentCraftType === 'displacement') {
          updateCraftLargePreview();
        }
      }, 100);
    }

    // 更新烫金预览
    function updateHotfoilGoldPreview() {
      const canvas = document.getElementById('hotfoilGoldPreview');
      if (!canvas || !previewHeightData) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;

      // 清空画布
      ctx.clearRect(0, 0, w, h);

      const s = hotfoilGoldSettings;

      // 创建临时画布用于渲染矢量形状
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = previewWidth;
      tempCanvas.height = previewHeight;
      const tempCtx = tempCanvas.getContext('2d');
      const imgData = tempCtx.createImageData(previewWidth, previewHeight);

      // HSL 转 RGB 辅助函数
      function hslToRgb(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
      }

      // 根据色调、饱和度、亮度生成金色
      const baseHue = s.hue;
      const [r, g, b] = hslToRgb(baseHue, s.saturation, s.brightness);

      // 基于矢量形状渲染金属效果
      for (let i = 0; i < previewHeightData.length; i += 4) {
        const alpha = previewHeightData[i]; // 使用红色通道作为 alpha
        if (alpha > 0) {
          imgData.data[i] = r;
          imgData.data[i + 1] = g;
          imgData.data[i + 2] = b;
          imgData.data[i + 3] = alpha;
        } else {
          imgData.data[i + 3] = 0; // 透明
        }
      }

      tempCtx.putImageData(imgData, 0, 0);

      // 保持比例绘制到预览 canvas
      const scale = Math.min(w / previewWidth, h / previewHeight);
      const dw = previewWidth * scale;
      const dh = previewHeight * scale;
      const dx = (w - dw) / 2;
      const dy = (h - dh) / 2;
      
      // 使用双线性插值进行缩放
      ctx.drawImage(tempCanvas, 0, 0, previewWidth, previewHeight, dx, dy, dw, dh);
      ctx.drawImage(tempCanvas, dx, dy, dw, dh);
    }

    // 更新烫银预览
    function updateHotfoilSilverPreview() {
      const canvas = document.getElementById('hotfoilSilverPreview');
      if (!canvas || !previewHeightData) return;
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;

      // 清空画布
      ctx.clearRect(0, 0, w, h);

      const s = hotfoilSilverSettings;

      // 创建临时画布用于渲染矢量形状
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = previewWidth;
      tempCanvas.height = previewHeight;
      const tempCtx = tempCanvas.getContext('2d');
      const imgData = tempCtx.createImageData(previewWidth, previewHeight);

      // HSL 转 RGB 辅助函数
      function hslToRgb(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
      }

      // 根据色调、饱和度、亮度生成银色
      const baseHue = s.hue;
      const [r, g, b] = hslToRgb(baseHue, s.saturation, s.brightness);

      // 基于矢量形状渲染金属效果
      for (let i = 0; i < previewHeightData.length; i += 4) {
        const alpha = previewHeightData[i]; // 使用红色通道作为 alpha
        if (alpha > 0) {
          imgData.data[i] = r;
          imgData.data[i + 1] = g;
          imgData.data[i + 2] = b;
          imgData.data[i + 3] = alpha;
        } else {
          imgData.data[i + 3] = 0; // 透明
        }
      }

      tempCtx.putImageData(imgData, 0, 0);

      // 保持比例绘制到预览 canvas
      const scale = Math.min(w / previewWidth, h / previewHeight);
      const dw = previewWidth * scale;
      const dh = previewHeight * scale;
      const dx = (w - dw) / 2;
      const dy = (h - dh) / 2;
      ctx.drawImage(tempCanvas, dx, dy, dw, dh);
    }

    // 选择相同颜色作为 UV 工艺
    function selectSameColorAsUV() {
      parent.postMessage({
        pluginMessage: { type: 'selectSameColorAsUV' }
      }, '*');
    }

    // 选择相同颜色作为烫金工艺
    function selectSameColorAsHotfoilGold() {
      parent.postMessage({
        pluginMessage: { type: 'selectSameColorAsHotfoilGold' }
      }, '*');
    }

    // 选择相同颜色作为烫银工艺
    function selectSameColorAsHotfoilSilver() {
      parent.postMessage({
        pluginMessage: { type: 'selectSameColorAsHotfoilSilver' }
      }, '*');
    }

    // 选择相同颜色作为置换工艺
    function selectSameColorAsDisplacement() {
      parent.postMessage({
        pluginMessage: { type: 'selectSameColorAsDisplacement' }
      }, '*');
    }

    // 烫金预设切换
    function selectHotfoilGoldPreset(preset) {
      const presets = {
        'default': { metallic: 1.0, roughness: 0.2, heightScale: 0.5 },
        'bright': { metallic: 1.0, roughness: 0.1, heightScale: 0.3 },
        'matte': { metallic: 0.9, roughness: 0.4, heightScale: 0.5 },
        'glossy': { metallic: 1.0, roughness: 0.05, heightScale: 0.7 }
      };

      if (presets[preset]) {
        hotfoilGoldSettings = { ...presets[preset] };
        document.getElementById('hotfoilGoldMetallic').value = hotfoilGoldSettings.metallic;
        document.getElementById('hotfoilGoldRoughness').value = hotfoilGoldSettings.roughness;
        document.getElementById('hotfoilGoldHeight').value = hotfoilGoldSettings.heightScale;
        updateHotfoilGoldSettings();
      }
    }

    // 烫银预设切换
    function selectHotfoilSilverPreset(preset) {
      const presets = {
        'default': { metallic: 1.0, roughness: 0.15, heightScale: 0.5 },
        'bright': { metallic: 1.0, roughness: 0.08, heightScale: 0.3 },
        'matte': { metallic: 0.9, roughness: 0.35, heightScale: 0.5 },
        'glossy': { metallic: 1.0, roughness: 0.03, heightScale: 0.7 }
      };

      if (presets[preset]) {
        hotfoilSilverSettings = { ...presets[preset] };
        document.getElementById('hotfoilSilverMetallic').value = hotfoilSilverSettings.metallic;
        document.getElementById('hotfoilSilverRoughness').value = hotfoilSilverSettings.roughness;
        document.getElementById('hotfoilSilverHeight').value = hotfoilSilverSettings.heightScale;
        updateHotfoilSilverSettings();
      }
    }

    // 选择 ClipMask 内的相同颜色
    function selectClipMaskColors() {
      parent.postMessage({
        pluginMessage: { type: 'selectClipMaskColors' }
      }, '*');
    }

    // 应用批量标记
    function applyBatchMark() {
      const sameColor = document.getElementById('markSameColor').checked;
      const inClipMask = document.getElementById('markInClipMask').checked;

      // 获取当前选中的工艺按钮
      const activeBtn = document.querySelector('.craft-type-btn.active');
      if (!activeBtn) {
        alert('❌ 请先选择一个工艺类型');
        return;
      }

      const craftType = activeBtn.getAttribute('onclick').match(/'([^']+)'/)[1];

      parent.postMessage({
        pluginMessage: {
          type: 'batchMarkCraft',
          craftType: craftType,
          sameColor: sameColor,
          inClipMask: inClipMask
        }
      }, '*');
    }

    // 法线预览相关状态
    let previewHeightData = null;
    let previewWidth = 0;
    let previewHeight = 0;

    // 工艺大图预览（提前定义）
    window.currentCraftType = null;

    window.showCraftLargePreview = function(craftType) {
      console.log('🎯 showCraftLargePreview called with:', craftType);
      window.currentCraftType = craftType;
      const container = document.getElementById('craftLargePreview');
      const canvas = document.getElementById('craftLargePreviewCanvas');
      const title = document.getElementById('craftLargePreviewTitle');
      if (!container || !canvas) {
        console.log('❌ Container or canvas not found');
        return;
      }
      const craftLabels = {
        'hot-stamping-gold': '烫金',
        'hot-stamping-silver': '烫银',
        'uv': 'UV光油',
        'emboss': '凹凸',
        'normal': '法线',
        'displacement': '置换'
      };
      title.textContent = `${craftLabels[craftType] || craftType} - 工艺预览`;
      container.classList.add('active');
      // 清除所有缓存并强制在下一帧重新渲染
      renderCache.invalidateAll();
      requestAnimationFrame(() => {
        renderCraftLargePreview(canvas, craftType);
      });
    };

    window.closeCraftLargePreview = function() {
      const container = document.getElementById('craftLargePreview');
      if (container) container.classList.remove('active');
      window.currentCraftType = null;
    };

    // 切换工艺类型
    function switchCraftType(type) {
      // 隐藏所有面板
      document.getElementById('panelNormal').style.display = 'none';
      document.getElementById('panelEmboss').style.display = 'none';
      document.getElementById('panelMetal').style.display = 'none';
      document.getElementById('panelUV').style.display = 'none';
      const hotfoilGold = document.getElementById('panelHotfoilGold');
      const hotfoilSilver = document.getElementById('panelHotfoilSilver');
      const displacement = document.getElementById('panelDisplacement');
      if (hotfoilGold) hotfoilGold.style.display = 'none';
      if (hotfoilSilver) hotfoilSilver.style.display = 'none';
      if (displacement) displacement.style.display = 'none';

      // 隐藏所有预览画布
      const allPreviews = [
        'normalPreview',
        'embossPreview',
        'metalPreview',
        'hotfoilGoldPreview',
        'hotfoilSilverPreview'
      ];
      allPreviews.forEach(previewId => {
        const preview = document.getElementById(previewId);
        if (preview) preview.style.display = 'none';
      });

      // 显示选中的面板
      let panelId = '';
      let previewId = '';
      if (type === 'hotfoil-gold') {
        panelId = 'panelHotfoilGold';
        previewId = 'hotfoilGoldPreview';
      } else if (type === 'hotfoil-silver') {
        panelId = 'panelHotfoilSilver';
        previewId = 'hotfoilSilverPreview';
      } else {
        panelId = 'panel' + type.charAt(0).toUpperCase() + type.slice(1);
        // 根据类型选择预览画布
        if (type === 'normal' || type === 'uv' || type === 'displacement') {
          previewId = 'normalPreview';
        } else if (type === 'emboss') {
          previewId = 'embossPreview';
        } else if (type === 'metal') {
          previewId = 'metalPreview';
        }
      }

      const panel = document.getElementById(panelId);
      if (panel) {
        panel.style.display = 'block';
      }

      // 显示对应的预览画布
      const preview = document.getElementById(previewId);
      if (preview) {
        preview.style.display = 'block';
      }

      // 初始化预览
      if (type === 'hotfoil-gold') {
        updateHotfoilGoldPreview();
      } else if (type === 'hotfoil-silver') {
        updateHotfoilSilverPreview();
      }

      // 更新按钮激活状态
      const buttons = document.querySelectorAll('.craft-type-btn');
      buttons.forEach(btn => {
        const btnType = btn.getAttribute('onclick').match(/'([^']+)'/)[1];
        btn.classList.toggle('active', btnType === type);
      });

      // 更新左下角缩略图的选中状态
      const allCards = document.querySelectorAll('.craft-thumbnail-card');
      allCards.forEach(card => card.classList.remove('active'));

      // 工艺类型映射（处理不同的命名方式）
      const typeMapping = {
        'hotfoil-gold': 'hot-stamping-gold',
        'hotfoil-silver': 'hot-stamping-silver',
        'hot-stamping-gold': 'hot-stamping-gold',
        'hot-stamping-silver': 'hot-stamping-silver',
        'normal': 'normal',
        'emboss': 'emboss',
        'uv': 'uv',
        'metal': 'metal'
      };

      const mappedType = typeMapping[type] || type;
      const selectedCard = document.querySelector(`.craft-thumbnail-card[data-craft-type="${mappedType}"]`);
      if (selectedCard) {
        selectedCard.classList.add('active');
      }

      // 🚀 极致体验优化：切换工艺时自动打开大图预览
      if (window.showCraftLargePreview) {
        window.showCraftLargePreview(mappedType);
      }

      // 🔥 修复：切换到UV时确保参数面板显示正确
      if (mappedType === 'uv') {
          const currentType = uvSettings.type || 'gloss';
          selectUVPreset(currentType);
      }
    }

    // 切换 Invert Y
    function toggleNormalInvertY() {
      normalMapSettings.invertY = !normalMapSettings.invertY;
      const sw = document.getElementById('normalInvertYSwitch');
      sw.classList.toggle('active', normalMapSettings.invertY);
      renderCache.invalidate('normal');
      saveCurrentLayerSettings();
      updateNormalPreview();
      scheduleThumbnailUpdate('normal');
      if (window.currentCraftType === 'normal') {
        renderCraftLargePreview(document.getElementById('craftLargePreviewCanvas'), 'normal');
      }
    }

    // 切换 Grayscale Mode
    function toggleNormalGrayscale() {
      normalMapSettings.useGrayscale = !normalMapSettings.useGrayscale;
      const sw = document.getElementById('normalGrayscaleSwitch');
      sw.classList.toggle('active', normalMapSettings.useGrayscale);
      
      const weightsPanel = document.getElementById('grayscaleWeights');
      if (weightsPanel) {
        weightsPanel.style.display = normalMapSettings.useGrayscale ? 'block' : 'none';
      }
      
      saveCurrentLayerSettings();
      renderCache.invalidate('normal');
      updateNormalPreview();
      scheduleThumbnailUpdate('normal');
      if (window.currentCraftType === 'normal') {
        renderCraftLargePreview(document.getElementById('craftLargePreviewCanvas'), 'normal');
      }
    }

    // 设置算法
    function setNormalAlgorithm(algo) {
      normalMapSettings.algorithm = algo;
      document.getElementById('algoScharr').classList.toggle('active', algo === 'scharr');
      document.getElementById('algoSobel').classList.toggle('active', algo === 'sobel');
      renderCache.invalidate('normal');
      saveCurrentLayerSettings();
      updateNormalPreview();
      scheduleThumbnailUpdate('normal');
      if (window.currentCraftType === 'normal') {
        renderCraftLargePreview(document.getElementById('craftLargePreviewCanvas'), 'normal');
      }
    }

    // 选择预设（按钮点击）
    function selectPreset(presetId) {
      // 更新按钮状态
      document.querySelectorAll('.preset-btn-item').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.preset === presetId);
      });
      applyPreset(presetId);
    }

    // 选择预设（下拉，保留兼容）
    function onPresetSelect() {
      const select = document.getElementById('normalPresetSelect');
      if (select) {
        applyPreset(select.value);
      }
    }

    // 应用预设
    function applyPreset(presetId) {
      const preset = NORMAL_PRESETS[presetId] || customPresets[presetId];
      if (!preset) return;

      currentPreset = presetId;
      normalMapSettings = { ...preset };
      delete normalMapSettings.name;

      updateUIFromSettings();
      updateNormalPreview();
    }

    // 从设置更新 UI
    function updateUIFromSettings() {
      document.getElementById('normalStrength').value = normalMapSettings.strength;
      document.getElementById('normalStrengthVal').textContent = normalMapSettings.strength.toFixed(1);

      document.getElementById('normalBlur').value = normalMapSettings.blurRadius;
      document.getElementById('normalBlurVal').textContent = normalMapSettings.blurRadius;

      document.getElementById('normalSharpness').value = normalMapSettings.sharpness;
      document.getElementById('normalSharpnessVal').textContent = normalMapSettings.sharpness.toFixed(1);

      document.getElementById('normalInvertYSwitch').classList.toggle('active', normalMapSettings.invertY);
      document.getElementById('normalGrayscaleSwitch').classList.toggle('active', normalMapSettings.useGrayscale);
      document.getElementById('algoScharr').classList.toggle('active', normalMapSettings.algorithm === 'scharr');
      document.getElementById('algoSobel').classList.toggle('active', normalMapSettings.algorithm === 'sobel');
    }

    // 从选中图层加载高度图预览
    function loadHeightMapPreview(layerId) {
      if (!layerId) return;
      parent.postMessage({
        pluginMessage: { type: 'getLayerForNormalPreview', layerId: layerId }
      }, '*');
    }

    // 刷新法线图层列表
    function refreshNormalLayers() {
      updateNormalLayerSelect();
    }

    // 当选择法线图层时
    function onNormalLayerSelect() {
      const select = document.getElementById('normalLayerSelect');
      const layerId = select.value;
      if (layerId) {
        // 单独模式下加载图层设置
        if (normalSettingsMode === 'individual') {
          loadCurrentLayerSettings();
        }
        loadHeightMapPreview(layerId);
      }
    }

    // 更新法线图层下拉列表
    function updateNormalLayerSelect() {
      const menu = document.getElementById('normalLayerMenu');
      const label = document.getElementById('normalLayerLabel');

      // 检查所有工艺类型，不仅仅是"法线"
      const normalLayers = markedLayers.filter(l => {
        const crafts = l.crafts || [l.craftType];
        // 支持多种工艺名称
        return crafts.some(c =>
          c === '法线' ||
          c === 'Normal' ||
          c === 'normal' ||
          c === '凹凸' ||
          c === 'Emboss' ||
          c === 'emboss' ||
          c === '金属' ||
          c === 'Metal' ||
          c === 'metal' ||
          c === 'UV' ||
          c === 'uv' ||
          c === '烫金' ||
          c === '烫银'
        );
      });

      let html = '';
      if (normalLayers.length === 0) {
        html = '<div class="driven-dropdown-item disabled">无工艺图层 (请先标记)</div>';
        label.textContent = '选择工艺图层...';
        label.classList.add('placeholder');
      } else {
        normalLayers.forEach(layer => {
          const crafts = layer.crafts || [layer.craftType];
          const craftLabel = crafts.join(', ');
          html += `<div class="driven-dropdown-item" data-value="${layer.id}" onclick="selectNormalLayer('${layer.id}', '${layer.name}')">${layer.name} [${craftLabel}]</div>`;
        });
      }
      menu.innerHTML = html;
    }

    // 切换法线图层下拉
    function toggleNormalLayerDropdown(event) {
      event.stopPropagation();
      const dropdown = document.getElementById('normalLayerDropdown');
      const trigger = dropdown.querySelector('.driven-dropdown-trigger');
      const menu = dropdown.querySelector('.driven-dropdown-menu');
      const isOpen = trigger.getAttribute('aria-expanded') === 'true';

      // 关闭其他下拉
      document.querySelectorAll('.driven-dropdown-menu.open').forEach(m => {
        m.classList.remove('open');
        m.parentElement.querySelector('.driven-dropdown-trigger').setAttribute('aria-expanded', 'false');
      });

      if (!isOpen) {
        trigger.setAttribute('aria-expanded', 'true');
        menu.classList.add('open');
      }
    }

    // 选择法线图层
    function selectNormalLayer(layerId, layerName) {
      document.getElementById('normalLayerSelect').value = layerId;
      const label = document.getElementById('normalLayerLabel');
      label.textContent = layerName;
      label.classList.remove('placeholder');

      // 关闭下拉
      const menu = document.getElementById('normalLayerMenu');
      const trigger = document.getElementById('normalLayerDropdown').querySelector('.driven-dropdown-trigger');
      menu.classList.remove('open');
      trigger.setAttribute('aria-expanded', 'false');

      // 生成工艺按钮
      updateCraftTypeButtons(layerId);

      // 触发选择事件
      onNormalLayerSelect();
    }

    // 关闭法线图层下拉
    function closeNormalLayerDropdown() {
      const menu = document.getElementById('normalLayerMenu');
      const trigger = document.getElementById('normalLayerDropdown').querySelector('.driven-dropdown-trigger');
      if (menu && trigger) {
        menu.classList.remove('open');
        trigger.setAttribute('aria-expanded', 'false');
      }
    }

    // 更新工艺类型按钮
    function updateCraftTypeButtons(layerId) {
      const buttonsContainer = document.getElementById('craftTypeButtons');
      if (!buttonsContainer) return;

      // 查找选中的图层
      const layer = markedLayers.find(l => l.id === layerId);
      if (!layer) {
        buttonsContainer.style.display = 'none';
        return;
      }

      // 获取该图层的所有工艺类型
      const crafts = layer.crafts || [layer.craftType];
      if (crafts.length === 0) {
        buttonsContainer.style.display = 'none';
        return;
      }

      // 工艺类型映射
      const craftMap = {
        '法线': { type: 'normal', icon: '🗺️', label: '法线' },
        'Normal': { type: 'normal', icon: '🗺️', label: '法线' },
        'normal': { type: 'normal', icon: '🗺️', label: '法线' },
        '凹凸': { type: 'emboss', icon: '📐', label: '凹凸' },
        'Emboss': { type: 'emboss', icon: '📐', label: '凹凸' },
        'emboss': { type: 'emboss', icon: '📐', label: '凹凸' },
        '金属': { type: 'metal', icon: '✨', label: '金属' },
        'Metal': { type: 'metal', icon: '✨', label: '金属' },
        'metal': { type: 'metal', icon: '✨', label: '金属' },
        'UV': { type: 'uv', icon: '💧', label: 'UV光油' },
        'uv': { type: 'uv', icon: '💧', label: 'UV光油' },
        '烫金': { type: 'hotfoil-gold', icon: '🥇', label: '烫金' },
        '烫银': { type: 'hotfoil-silver', icon: '🥈', label: '烫银' },
        '置换': { type: 'displacement', icon: '🏔️', label: '置换' },
        'Displacement': { type: 'displacement', icon: '🏔️', label: '置换' },
        'displacement': { type: 'displacement', icon: '🏔️', label: '置换' }
      };

      // 生成按钮
      let html = '';
      const uniqueCrafts = [];
      crafts.forEach(craft => {
        const mapped = craftMap[craft];
        if (mapped && !uniqueCrafts.find(c => c.type === mapped.type)) {
          uniqueCrafts.push(mapped);
        }
      });

      uniqueCrafts.forEach((craft, index) => {
        const activeClass = index === 0 ? 'active' : '';
        html += `<button class="craft-type-btn ${activeClass}" onclick="switchCraftType('${craft.type}')">${craft.icon} ${craft.label}</button>`;
      });

      buttonsContainer.innerHTML = html;
      buttonsContainer.style.display = uniqueCrafts.length > 0 ? 'flex' : 'none';

      // 自动显示第一个工艺面板
      if (uniqueCrafts.length > 0) {
        switchCraftType(uniqueCrafts[0].type);
      }

      // 同步更新工艺缩略图 - 只显示该图层的工艺类型
      updateCraftThumbnailsForSelection([layer], true);
    }

    // 设置模式 (全局/单独)
    function setNormalMode(mode) {
      normalSettingsMode = mode;
      document.getElementById('modeGlobal').classList.toggle('active', mode === 'global');
      document.getElementById('modeIndividual').classList.toggle('active', mode === 'individual');

      const hint = document.getElementById('modeHint');
      if (mode === 'global') {
        hint.textContent = '参数应用到所有法线图层';
      } else {
        hint.textContent = '每个图层独立参数';
        loadCurrentLayerSettings();
      }
    }

    // 保存当前图层设置
    function saveCurrentLayerSettings() {
      if (normalSettingsMode !== 'individual') return;
      const layerId = document.getElementById('normalLayerSelect').value;
      if (!layerId) return;
      layerNormalSettings[layerId] = { ...normalMapSettings };
    }

    // 加载当前图层设置
    function loadCurrentLayerSettings() {
      const layerId = document.getElementById('normalLayerSelect').value;
      if (!layerId) return;

      if (layerNormalSettings[layerId]) {
        normalMapSettings = { ...layerNormalSettings[layerId] };
        updateUIFromSettings();
        updateNormalPreview();
      }
    }

    // 保存当前设置为默认
    function saveAsDefault() {
      try {
        saveSettings('normalMapDefaultSettings', normalMapSettings);
        alert('✅ 已保存为默认设置');
      } catch (e) {
        alert('❌ 保存失败');
      }
    }

    // 加载默认设置
    function loadDefaultSettings() {
      requestSettings('normalMapDefaultSettings', (data) => {
        if (data) {
          normalMapSettings = data;
          updateUIFromSettings();
        }
      });
    }

    // 保存自定义预设
    function saveCustomPresetsToStorage() {
      try {
        saveSettings('normalMapCustomPresets', customPresets);
      } catch (e) {
        console.warn('无法保存预设到本地存储:', e);
      }
    }

    // 加载自定义预设
    function loadCustomPresetsFromStorage() {
      requestSettings('normalMapCustomPresets', (data) => {
        if (data) {
          customPresets = data;
          updateCustomPresetOptions();
        }
      });
    }

    // 更新自定义预设选项
    function updateCustomPresetOptions() {
      const grid = document.getElementById('customPresetGrid');
      const area = document.getElementById('customPresetsArea');

      console.log('📦 updateCustomPresetOptions called');
      console.log('📦 customPresets:', customPresets);
      console.log('📦 grid:', grid);
      console.log('📦 area:', area);

      const keys = Object.keys(customPresets);
      console.log('📦 keys:', keys);

      if (keys.length === 0) {
        if (area) area.style.display = 'none';
        return;
      }

      if (area) area.style.display = 'block';
      let html = '';
      keys.forEach(id => {
        const preset = customPresets[id];
        const isActive = currentPreset === id ? 'active' : '';
        html += `<button class="preset-btn-item ${isActive}" data-preset="${id}" onclick="selectPreset('${id}')">${preset.name}</button>`;
      });
      if (grid) grid.innerHTML = html;
      console.log('📦 Updated grid HTML');
    }

    // 获取图层的法线设置
    function getLayerNormalSettings(layerId) {
      if (normalSettingsMode === 'global') {
        return normalMapSettings;
      }
      return layerNormalSettings[layerId] || normalMapSettings;
    }

    // 更新法线预览
    function updateNormalPreview() {
      // 优先使用覆盖源（来自"Convert To"功能），否则使用原始预览数据
      const sourceData = overrideNormalInput || previewHeightData;
      if (!sourceData) return;

      const canvas = document.getElementById('normalPreview');
      if (!canvas) return; // 如果canvas不存在，直接返回
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;

      // 生成法线贴图
      const normalData = jsGenerateNormalMap(
        sourceData,
        previewWidth,
        previewHeight,
        normalMapSettings.strength
      );

      // 缩放到预览尺寸
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = previewWidth;
      tempCanvas.height = previewHeight;
      const tempCtx = tempCanvas.getContext('2d');
      const imgData = tempCtx.createImageData(previewWidth, previewHeight);
      imgData.data.set(normalData);
      tempCtx.putImageData(imgData, 0, 0);

      // 保持比例绘制到预览 canvas
      ctx.clearRect(0, 0, w, h);
      const scale = Math.min(w / previewWidth, h / previewHeight);
      const dw = previewWidth * scale;
      const dh = previewHeight * scale;
      const dx = (w - dw) / 2;
      const dy = (h - dh) / 2;
      ctx.drawImage(tempCanvas, dx, dy, dw, dh);

      // 同步更新大图预览
      updateCraftLargePreview();
    }

    // 渲染工艺缩略图预览 - 使用真实的vector形状
    function renderCraftThumbnail(canvas, craftType) {
      if (!previewHeightData) {
        // 如果还没有预览数据，显示占位符
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('等待数据', canvas.width / 2, canvas.height / 2);
        return;
      }

      // 动态调整画布尺寸以匹配显示尺寸（解决模糊/锯齿问题）
      const rect = canvas.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        if (canvas.width !== rect.width || canvas.height !== rect.height) {
          canvas.width = rect.width;
          canvas.height = rect.height;
        }
      }

      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // 检查缓存
      const cached = renderCache.thumbnails.get(craftType);
      if (cached && cached.width === previewWidth && cached.height === previewHeight) {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        const scale = Math.min(w / previewWidth, h / previewHeight);
        const dw = previewWidth * scale;
        const dh = previewHeight * scale;
        const dx = (w - dw) / 2;
        const dy = (h - dh) / 2;
        ctx.save();
        ctx.translate(0, h);
        ctx.scale(1, -1);
        ctx.drawImage(cached.canvas, 0, 0, previewWidth, previewHeight, dx, h - dy - dh, dw, dh);
        ctx.restore();
        return;
      }

      // 启用图像平滑以减少锯齿
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      // 创建临时画布用于渲染矢量形状
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = previewWidth;
      tempCanvas.height = previewHeight;
      const tempCtx = tempCanvas.getContext('2d');
      // 启用临时画布的平滑
      tempCtx.imageSmoothingEnabled = true;
      tempCtx.imageSmoothingQuality = 'high';

      const imgData = tempCtx.createImageData(previewWidth, previewHeight);

      // HSL 转 RGB 辅助函数
      function hslToRgb(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
      }

      // 根据工艺类型渲染
      if (craftType === 'hot-stamping-gold') {
        // 应用烫金颜色 + 纹理效果
        const s = hotfoilGoldSettings;
        const [r, g, b] = hslToRgb(s.hue, s.saturation, s.brightness);

        // 生成纹理（如果启用）
        let textureData = null;
        if (s.noise > 0) {
          textureData = generateAdvancedTexture(previewWidth, previewHeight, {
            type: s.noiseType || 'matte',
            intensity: s.noise,
            scaleX: s.noiseScaleX || 1.0,
            scaleY: s.noiseScaleY || 1.0,
            rotation: s.noiseRotation || 0,
            frequency: s.noiseFrequency || 1.0,
            stripeCount: s.stripeCount || 10,
            distortion: s.distortion || 0.0,
            centerX: 0.5,
            centerY: 0.5
          });
        }

        for (let i = 0; i < previewHeightData.length; i += 4) {
          const alpha = previewHeightData[i + 3];
          if (alpha > 0) {
            let finalR = r, finalG = g, finalB = b;

            // 应用纹理调制
            if (textureData) {
              const texValue = textureData[i] / 255; // 0-1
              finalR = Math.round(r * texValue);
              finalG = Math.round(g * texValue);
              finalB = Math.round(b * texValue);
            }

            imgData.data[i] = finalR;
            imgData.data[i + 1] = finalG;
            imgData.data[i + 2] = finalB;
            imgData.data[i + 3] = alpha;
          }
        }

        // 应用边缘效果
        if (s.edgeSoftness > 0 || s.edgeFade > 0) {
          const processed = applyEdgeEffects(imgData.data, previewWidth, previewHeight, s.edgeSoftness, s.edgeFade);
          imgData.data.set(processed);
        }
      } else if (craftType === 'hot-stamping-silver') {
        // 应用烫银颜色 + 纹理效果
        const s = hotfoilSilverSettings;
        const [r, g, b] = hslToRgb(s.hue, s.saturation, s.brightness);

        // 生成纹理（如果启用）
        let textureData = null;
        if (s.noise > 0) {
          textureData = generateAdvancedTexture(previewWidth, previewHeight, {
            type: s.noiseType || 'matte',
            intensity: s.noise,
            scaleX: s.noiseScaleX || 1.0,
            scaleY: s.noiseScaleY || 1.0,
            rotation: s.noiseRotation || 0,
            frequency: s.noiseFrequency || 1.0,
            stripeCount: s.stripeCount || 10,
            distortion: s.distortion || 0.0,
            centerX: 0.5,
            centerY: 0.5
          });
        }

        for (let i = 0; i < previewHeightData.length; i += 4) {
          const alpha = previewHeightData[i + 3];
          if (alpha > 0) {
            let finalR = r, finalG = g, finalB = b;

            // 应用纹理调制
            if (textureData) {
              const texValue = textureData[i] / 255; // 0-1
              finalR = Math.round(r * texValue);
              finalG = Math.round(g * texValue);
              finalB = Math.round(b * texValue);
            }

            imgData.data[i] = finalR;
            imgData.data[i + 1] = finalG;
            imgData.data[i + 2] = finalB;
            imgData.data[i + 3] = alpha;
          }
        }

        // 应用边缘效果
        if (s.edgeSoftness > 0 || s.edgeFade > 0) {
          const processed = applyEdgeEffects(imgData.data, previewWidth, previewHeight, s.edgeSoftness, s.edgeFade);
          imgData.data.set(processed);
        }
      } else if (craftType === 'displacement') {
        // 应用置换效果（灰度高度图可视化）
        const s = displacementSettings;

        // 调试：打印参数值
        console.log('🏔️ Displacement Settings:', {
          strength: s.strength,
          midlevel: s.midlevel,
          blur: s.blur,
          sharpness: s.sharpness,
          contrast: s.contrast,
          brightness: s.brightness,
          edgeSoftness: s.edgeSoftness
        });

        // 应用边缘柔和度
        const processedHeightData = applyEdgeSoftness(previewHeightData, previewWidth, previewHeight, s.edgeSoftness || 0);

        for (let i = 0; i < processedHeightData.length; i += 4) {
          const alpha = processedHeightData[i + 3];
          if (alpha > 0) {
            // 获取原始高度值 (0-255)
            let height = processedHeightData[i];

            // 1. 应用亮度调整
            height = Math.max(0, Math.min(255, height + s.brightness));

            // 2. 应用对比度
            height = ((height / 255.0 - 0.5) * s.contrast + 0.5) * 255;

            // 3. 应用伽马校正
            if (s.gamma !== 1.0) {
              height = Math.pow(height / 255.0, 1.0 / s.gamma) * 255;
            }

            // 4. 应用锐化
            if (s.sharpness > 0) {
              const sharpAmount = s.sharpness;
              height = height + (height - 128) * sharpAmount;
            }

            // 5. 应用缩放
            height = height * s.scale;

            // 6. 应用中点和强度调整
            const normalized = height / 255.0; // 0-1
            const adjusted = (normalized - s.midlevel) * s.strength + s.midlevel;
            let clamped = Math.max(0, Math.min(1, adjusted));

            // 7. 应用反转
            if (s.invert > 0) {
              clamped = clamped * (1 - s.invert) + (1 - clamped) * s.invert;
            }

            const gray = Math.round(clamped * 255);

            imgData.data[i] = gray;
            imgData.data[i + 1] = gray;
            imgData.data[i + 2] = gray;
            imgData.data[i + 3] = alpha;
          }
        }

        // 应用模糊效果（如果需要）
        if (s.blur > 0) {
          applyGaussianBlur(imgData, previewWidth, previewHeight, s.blur);
        }
      } else if (craftType === 'uv') {
        // 应用 UV 光油效果（支持多种专业UV类型）
        const uvType = uvSettings.type || 'gloss';
        const intensity = Math.round(uvSettings.gloss * 255);

        // 应用边缘柔和度
        const edgeSoftness = uvSettings.edgeSoftness || 0;
        const processedHeightData = applyEdgeSoftness(previewHeightData, previewWidth, previewHeight, edgeSoftness);

        // 根据UV类型应用不同效果
        if (uvType === 'reverse') {
          // 🔄 反向UV
          for (let i = 0; i < processedHeightData.length; i += 4) {
            const alpha = processedHeightData[i + 3];
            if (alpha > 0) {
              const reversed = 255 - intensity;
              imgData.data[i] = reversed;
              imgData.data[i + 1] = reversed;
              imgData.data[i + 2] = reversed;
              imgData.data[i + 3] = alpha;
            }
          }
        } else if (uvType === 'frosted') {
          // ❄️ 磨砂UV
          applyFrostedUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else if (uvType === 'fragment') {
          // 💎 碎片UV（车漆效果）
          applyFragmentUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else if (uvType === 'diamond') {
          // 💠 钻石UV
          applyDiamondUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else if (uvType === 'mosaic') {
          // 🔷 马赛克UV
          applyMosaicUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else if (uvType === 'concentric') {
          // ⭕ 同心圆UV
          applyConcentricUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else {
          // 标准UV（高光、半光、缎面、哑光）
          for (let i = 0; i < processedHeightData.length; i += 4) {
            const alpha = processedHeightData[i + 3];
            if (alpha > 0) {
              imgData.data[i] = intensity;
              imgData.data[i + 1] = intensity;
              imgData.data[i + 2] = intensity;
              imgData.data[i + 3] = alpha;
            }
          }
        }

        // 🔥 应用锐化滤镜（消除模糊效果）
        const sharpenStrength = uvSettings.sharpen || 0;
        if (sharpenStrength > 0) {
          applySharpenFilter(imgData, previewWidth, previewHeight, sharpenStrength);
        }

        // 🔥 应用模糊滤镜（柔和效果）
        const blurStrength = uvSettings.blur || 0;
        if (blurStrength > 0) {
          applyGaussianBlur(imgData, previewWidth, previewHeight, blurStrength);
        }
      } else if (craftType === 'emboss' || craftType === 'deboss') {
        // 凹凸/压纹使用SDF算法消除锯齿
        const sdfData = generateSDF(previewHeightData, previewWidth, previewHeight, {
          spread: embossSettings.sdfSpread,
          profile: embossSettings.sdfProfile,
          mode: embossSettings.sdfMode || 'shrink',
          softness: embossSettings.sdfSoftness || 1.0,
          rippleCount: embossSettings.rippleCount || 3,
          rippleWidth: embossSettings.rippleWidth || 0.5,
          rippleDash: embossSettings.rippleDash || 0,
          threshold: 128
        });

        for (let i = 0; i < sdfData.length; i += 4) {
          const v = Math.min(255, sdfData[i] * embossSettings.heightScale);
          imgData.data[i] = v;
          imgData.data[i + 1] = v;
          imgData.data[i + 2] = v;
          imgData.data[i + 3] = 255;
        }
      } else if (craftType === 'normal') {
        // 法线贴图使用蓝紫色预览（标准法线贴图颜色）
        
        // 🔥 Use override data if available (from "Apply to Normal")
        let sourceData = previewHeightData;
        if (overrideNormalInput) {
             sourceData = overrideNormalInput;
        }
        
        // 应用边缘柔和度
        const edgeSoftness = normalMapSettings.edgeSoftness || 0;
        const processedHeightData = applyEdgeSoftness(sourceData, previewWidth, previewHeight, edgeSoftness);

        for (let i = 0; i < processedHeightData.length; i += 4) {
          const alpha = processedHeightData[i + 3]; // 使用处理后的 Alpha 通道
          
          // 背景填充标准法线颜色 (128, 128, 255)
          imgData.data[i] = 128;
          imgData.data[i + 1] = 128;
          imgData.data[i + 2] = 255;
          imgData.data[i + 3] = 255; // 背景完全不透明

          // 如果有内容，则叠加内容（这里简单处理，实际法线预览通常不需要叠加，除非是为了显示遮罩范围）
          // 但为了显示"边缘柔和度"的效果，我们需要让 Alpha 通道生效
          // 修改策略：
          // 1. 背景统一为 (128, 128, 255)
          // 2. 内容区域也显示为 (128, 128, 255)，但 Alpha 通道受控
          // 3. 实际上，用户想要看到的是"贴图"的样子，标准的法线贴图背景就是 (128, 128, 255)
          // 4. 如果 Alpha < 255，那么就是半透明的法线颜色？
          // 5. 不，用户反馈是"周围也填充为蓝紫色"，意味着整个图片应该是实心的蓝紫色，
          //    而不仅仅是有内容的区域。
          //    但是，如果完全实心，就看不出形状了。
          //    通常法线贴图在透明区域应该是 (128, 128, 255, 0) 或者 (128, 128, 255, 255)
          //    如果用户说是"展示"，可能是指预览背景。
          
          // 重新理解：用户希望看到的是一张完整的法线贴图，空的地方也是蓝紫色。
          // 但是为了区分"有内容"和"无内容"，通常无内容区域是平坦的法线 (128, 128, 255)。
          // 这里我们把整个画布填充为平坦法线，然后内容区域保持原样（也是平坦法线，因为没有高度变化信息传入）
          // 这里的预览只是一个示意图。
          
          // 修正逻辑：
          // 1. 填充背景为 (128, 128, 255, 255)
          // 2. 内容区域根据 Alpha 显示。
          //    由于这里只是缩略图，且没有实际法线生成逻辑（只是示意），
          //    所以整个图看起来都是蓝紫色的。
          //    为了让用户看到"形状"，我们可以让背景稍微暗一点或者透明一点？
          //    或者，用户希望看到的是"导出后的贴图样子"？导出后的贴图，透明区域通常是 (128, 128, 255, 0) 或 (128, 128, 255, 255)。
          
          // 再次阅读反馈："法线贴图的周围也填充为蓝紫色标准的展示啊"
          // 这通常意味着背景不应该是透明的，或者是黑色的，而应该是法线平坦色。
          
          if (alpha > 0) {
            // 内容区域：保持标准法线颜色
            imgData.data[i] = 128;
            imgData.data[i + 1] = 128;
            imgData.data[i + 2] = 255;
            imgData.data[i + 3] = alpha; // 保持边缘柔和度的 Alpha
          } else {
             // 背景区域：填充标准法线颜色，但 Alpha 为 0 或 255？
             // 如果是预览，为了能看到背景网格，通常 Alpha=0。
             // 但如果用户要求"填充"，可能是指视觉上看到蓝紫色。
             // 让我们尝试把背景设为半透明的蓝紫色，以便区分。
             imgData.data[i] = 128;
             imgData.data[i + 1] = 128;
             imgData.data[i + 2] = 255;
             imgData.data[i + 3] = 0; // 保持透明，但在大图预览中背景是黑色的，所以可能需要处理
          }
        }
        
        // 针对缩略图，我们还是保持透明背景，但在大图预览中可能需要调整。
        // 或者是用户觉得现在的预览只有内容区域有颜色，太奇怪了？
        // 让我们回退到之前的逻辑，但确保颜色正确。
        // 之前的逻辑：
        // if (alpha > 0) { ... }
        // 这意味着 alpha=0 的地方是完全透明的。
        
        // 尝试方案：
        // 在大图预览 `renderCraftLargePreview` 中，我们将背景填充为 (128, 128, 255)。
        // 在缩略图 `renderCraftThumbnail` 中，保持透明以便融合 UI。
      } else if (craftType === 'displacement') {
        // 置换贴图 - 显示黑白高度图
        for (let i = 0; i < previewHeightData.length; i += 4) {
          const alpha = previewHeightData[i + 3];
          if (alpha > 0) {
            const v = previewHeightData[i]; // 使用 R 通道作为高度值
            imgData.data[i] = v;
            imgData.data[i + 1] = v;
            imgData.data[i + 2] = v;
            imgData.data[i + 3] = alpha;
          }
        }
      }

      tempCtx.putImageData(imgData, 0, 0);

      // 保持比例绘制到缩略图 canvas
      const scale = Math.min(w / previewWidth, h / previewHeight);
      const dw = previewWidth * scale;
      const dh = previewHeight * scale;
      const dx = (w - dw) / 2;
      const dy = (h - dh) / 2;

      // 翻转 Y 轴
      ctx.save();
      ctx.translate(0, h);
      ctx.scale(1, -1);
      ctx.drawImage(tempCanvas, 0, 0, previewWidth, previewHeight, dx, h - dy - dh, dw, dh);
      ctx.restore();

      // 保存到缓存
      renderCache.thumbnails.set(craftType, {
        canvas: tempCanvas,
        width: previewWidth,
        height: previewHeight
      });
    }

    // 渲染工艺大图预览 - 高分辨率版本
    function renderCraftLargePreview(canvas, craftType) {
      if (!previewHeightData) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('等待数据...', canvas.width / 2, canvas.height / 2);
        return;
      }

      // 动态调整画布尺寸以匹配显示尺寸（解决模糊/锯齿问题）
      const rect = canvas.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        if (canvas.width !== rect.width || canvas.height !== rect.height) {
          canvas.width = rect.width;
          canvas.height = rect.height;
        }
      }

      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // 检查缓存
      const cached = renderCache.largePreview.get(craftType);
      if (cached && cached.width === previewWidth && cached.height === previewHeight) {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        const scale = Math.min(w / previewWidth, h / previewHeight);
        const dw = previewWidth * scale;
        const dh = previewHeight * scale;
        const dx = (w - dw) / 2;
        const dy = (h - dh) / 2;
        ctx.save();
        ctx.translate(0, h);
        ctx.scale(1, -1);
        ctx.drawImage(cached.canvas, 0, 0, previewWidth, previewHeight, dx, h - dy - dh, dw, dh);
        ctx.restore();
        return;
      }

      // 启用图像平滑以减少锯齿
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';

      // 创建临时画布用于渲染矢量形状
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = previewWidth;
      tempCanvas.height = previewHeight;
      const tempCtx = tempCanvas.getContext('2d');
      // 启用临时画布的平滑
      tempCtx.imageSmoothingEnabled = true;
      tempCtx.imageSmoothingQuality = 'high';
      
      const imgData = tempCtx.createImageData(previewWidth, previewHeight);

      // HSL 转 RGB 辅助函数
      function hslToRgb(h, s, l) {
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r, g, b;
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
      }

      // 根据工艺类型渲染
      if (craftType === 'hot-stamping-gold') {
        // 应用烫金颜色 + 纹理效果
        const s = hotfoilGoldSettings;
        const [r, g, b] = hslToRgb(s.hue, s.saturation, s.brightness);

        // 生成纹理（如果启用）
        let textureData = null;
        if (s.noise > 0) {
          textureData = generateAdvancedTexture(previewWidth, previewHeight, {
            type: s.noiseType || 'matte',
            intensity: s.noise,
            scaleX: s.noiseScaleX || 1.0,
            scaleY: s.noiseScaleY || 1.0,
            rotation: s.noiseRotation || 0,
            frequency: s.noiseFrequency || 1.0,
            stripeCount: s.stripeCount || 10,
            distortion: s.distortion || 0.0,
            centerX: 0.5,
            centerY: 0.5
          });
        }

        for (let i = 0; i < previewHeightData.length; i += 4) {
          const alpha = previewHeightData[i + 3];
          if (alpha > 0) {
            let finalR = r, finalG = g, finalB = b;

            // 应用纹理调制
            if (textureData) {
              const texValue = textureData[i] / 255; // 0-1
              finalR = Math.round(r * texValue);
              finalG = Math.round(g * texValue);
              finalB = Math.round(b * texValue);
            }

            imgData.data[i] = finalR;
            imgData.data[i + 1] = finalG;
            imgData.data[i + 2] = finalB;
            imgData.data[i + 3] = alpha;
          }
        }

        // 应用边缘效果
        if (s.edgeSoftness > 0 || s.edgeFade > 0) {
          const processed = applyEdgeEffects(imgData.data, previewWidth, previewHeight, s.edgeSoftness, s.edgeFade);
          imgData.data.set(processed);
        }
      } else if (craftType === 'hot-stamping-silver') {
        // 应用烫银颜色 + 纹理效果
        const s = hotfoilSilverSettings;
        const [r, g, b] = hslToRgb(s.hue, s.saturation, s.brightness);

        // 生成纹理（如果启用）
        let textureData = null;
        if (s.noise > 0) {
          textureData = generateAdvancedTexture(previewWidth, previewHeight, {
            type: s.noiseType || 'matte',
            intensity: s.noise,
            scaleX: s.noiseScaleX || 1.0,
            scaleY: s.noiseScaleY || 1.0,
            rotation: s.noiseRotation || 0,
            frequency: s.noiseFrequency || 1.0,
            stripeCount: s.stripeCount || 10,
            distortion: s.distortion || 0.0,
            centerX: 0.5,
            centerY: 0.5
          });
        }

        for (let i = 0; i < previewHeightData.length; i += 4) {
          const alpha = previewHeightData[i + 3];
          if (alpha > 0) {
            let finalR = r, finalG = g, finalB = b;

            // 应用纹理调制
            if (textureData) {
              const texValue = textureData[i] / 255; // 0-1
              finalR = Math.round(r * texValue);
              finalG = Math.round(g * texValue);
              finalB = Math.round(b * texValue);
            }

            imgData.data[i] = finalR;
            imgData.data[i + 1] = finalG;
            imgData.data[i + 2] = finalB;
            imgData.data[i + 3] = alpha;
          }
        }

        // 应用边缘效果
        if (s.edgeSoftness > 0 || s.edgeFade > 0) {
          const processed = applyEdgeEffects(imgData.data, previewWidth, previewHeight, s.edgeSoftness, s.edgeFade);
          imgData.data.set(processed);
        }
      } else if (craftType === 'displacement') {
        // 应用置换效果（灰度高度图可视化）
        const s = displacementSettings;

        // 调试：打印参数值
        console.log('🏔️ Displacement Settings:', {
          strength: s.strength,
          midlevel: s.midlevel,
          blur: s.blur,
          sharpness: s.sharpness,
          contrast: s.contrast,
          brightness: s.brightness,
          edgeSoftness: s.edgeSoftness
        });

        // 应用边缘柔和度
        const processedHeightData = applyEdgeSoftness(previewHeightData, previewWidth, previewHeight, s.edgeSoftness || 0);

        for (let i = 0; i < processedHeightData.length; i += 4) {
          const alpha = processedHeightData[i + 3];
          if (alpha > 0) {
            // 获取原始高度值 (0-255)
            let height = processedHeightData[i];

            // 1. 应用亮度调整
            height = Math.max(0, Math.min(255, height + s.brightness));

            // 2. 应用对比度
            height = ((height / 255.0 - 0.5) * s.contrast + 0.5) * 255;

            // 3. 应用伽马校正
            if (s.gamma !== 1.0) {
              height = Math.pow(height / 255.0, 1.0 / s.gamma) * 255;
            }

            // 4. 应用锐化
            if (s.sharpness > 0) {
              const sharpAmount = s.sharpness;
              height = height + (height - 128) * sharpAmount;
            }

            // 5. 应用缩放
            height = height * s.scale;

            // 6. 应用中点和强度调整
            const normalized = height / 255.0; // 0-1
            const adjusted = (normalized - s.midlevel) * s.strength + s.midlevel;
            let clamped = Math.max(0, Math.min(1, adjusted));

            // 7. 应用反转
            if (s.invert > 0) {
              clamped = clamped * (1 - s.invert) + (1 - clamped) * s.invert;
            }

            const gray = Math.round(clamped * 255);

            imgData.data[i] = gray;
            imgData.data[i + 1] = gray;
            imgData.data[i + 2] = gray;
            imgData.data[i + 3] = alpha;
          }
        }

        // 应用模糊效果（如果需要）
        if (s.blur > 0) {
          applyGaussianBlur(imgData, previewWidth, previewHeight, s.blur);
        }
      } else if (craftType === 'uv') {
        // 应用 UV 光油效果（支持多种专业UV类型）
        const uvType = uvSettings.type || 'gloss';
        const intensity = Math.round(uvSettings.gloss * 255);

        // 应用边缘柔和度
        const edgeSoftness = uvSettings.edgeSoftness || 0;
        const processedHeightData = applyEdgeSoftness(previewHeightData, previewWidth, previewHeight, edgeSoftness);

        // 根据UV类型应用不同效果
        if (uvType === 'reverse') {
          // 🔄 反向UV
          for (let i = 0; i < processedHeightData.length; i += 4) {
            const alpha = processedHeightData[i + 3];
            if (alpha > 0) {
              const reversed = 255 - intensity;
              imgData.data[i] = reversed;
              imgData.data[i + 1] = reversed;
              imgData.data[i + 2] = reversed;
              imgData.data[i + 3] = alpha;
            }
          }
        } else if (uvType === 'frosted') {
          // ❄️ 磨砂UV
          applyFrostedUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else if (uvType === 'fragment') {
          // 💎 碎片UV（车漆效果）
          applyFragmentUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else if (uvType === 'diamond') {
          // 💠 钻石UV
          applyDiamondUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else if (uvType === 'mosaic') {
          // 🔷 马赛克UV
          applyMosaicUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else if (uvType === 'concentric') {
          // ⭕ 同心圆UV
          applyConcentricUV(imgData, processedHeightData, previewWidth, previewHeight, intensity);
        } else {
          // 标准UV（高光、半光、缎面、哑光）
          for (let i = 0; i < processedHeightData.length; i += 4) {
            const alpha = processedHeightData[i + 3];
            if (alpha > 0) {
              imgData.data[i] = intensity;
              imgData.data[i + 1] = intensity;
              imgData.data[i + 2] = intensity;
              imgData.data[i + 3] = alpha;
            }
          }
        }

        // 🔥 应用锐化滤镜（消除模糊效果）
        const sharpenStrength = uvSettings.sharpen || 0;
        if (sharpenStrength > 0) {
          applySharpenFilter(imgData, previewWidth, previewHeight, sharpenStrength);
        }

        // 🔥 应用模糊滤镜（柔和效果）
        const blurStrength = uvSettings.blur || 0;
        if (blurStrength > 0) {
          applyGaussianBlur(imgData, previewWidth, previewHeight, blurStrength);
        }
      } else if (craftType === 'emboss' || craftType === 'deboss') {
        // Use SDF generation for emboss
        const sdfData = generateSDF(previewHeightData, previewWidth, previewHeight, {
          spread: embossSettings.sdfSpread,
          profile: embossSettings.sdfProfile,
          mode: embossSettings.sdfMode || 'shrink',
          softness: embossSettings.sdfSoftness || 1.0,
          rippleCount: embossSettings.rippleCount || 3,
          rippleWidth: embossSettings.rippleWidth || 0.5,
          rippleDash: embossSettings.rippleDash || 0,
          threshold: 128
        });

        // Apply height scale
        for (let i = 0; i < sdfData.length; i += 4) {
          const v = Math.min(255, sdfData[i] * embossSettings.heightScale);
          imgData.data[i] = v;
          imgData.data[i + 1] = v;
          imgData.data[i + 2] = v;
          imgData.data[i + 3] = 255;
        }
        imgData.data.set(sdfData);
      } else if (craftType === 'normal') {
        // Use Normal Map generation
        const normalData = jsGenerateNormalMap(
          previewHeightData,
          previewWidth,
          previewHeight,
          normalMapSettings.strength
        );

        // 应用边缘柔和度到 Alpha 通道
        const edgeSoftness = normalMapSettings.edgeSoftness || 0;
        const maskData = applyEdgeSoftness(previewHeightData, previewWidth, previewHeight, edgeSoftness);

        for (let i = 0; i < normalData.length; i += 4) {
          const alpha = maskData[i + 3];

          if (alpha > 0 && alpha < 255) {
            // 边缘过渡区域：混合当前法线与平坦法线 (128, 128, 255)
            // 这样边缘柔和度会表现为法线逐渐变平，而不是变黑或变透明
            const t = alpha / 255.0;
            imgData.data[i] = Math.round(normalData[i] * t + 128 * (1 - t));
            imgData.data[i + 1] = Math.round(normalData[i + 1] * t + 128 * (1 - t));
            imgData.data[i + 2] = Math.round(normalData[i + 2] * t + 255 * (1 - t));
            imgData.data[i + 3] = 255; // 保持完全不透明，通过颜色混合模拟淡出
          } else if (alpha === 255) {
            // 内部区域
            imgData.data[i] = normalData[i];
            imgData.data[i + 1] = normalData[i + 1];
            imgData.data[i + 2] = normalData[i + 2];
            imgData.data[i + 3] = 255;
          } else {
            // 背景区域：填充平坦法线颜色 (128, 128, 255)
            imgData.data[i] = 128;
            imgData.data[i + 1] = 128;
            imgData.data[i + 2] = 255;
            imgData.data[i + 3] = 255; // 完全不透明背景
          }
        }
      } else if (craftType === 'displacement') {
        // Displacement Map - 直接显示高度图（黑白图）
        for (let i = 0; i < previewHeightData.length; i += 4) {
          const v = previewHeightData[i]; // 使用 R 通道作为高度值
          imgData.data[i] = v;
          imgData.data[i + 1] = v;
          imgData.data[i + 2] = v;
          imgData.data[i + 3] = 255;
        }
      }

      tempCtx.putImageData(imgData, 0, 0);

      // 保持比例绘制到大图 canvas，使用高质量缩放
      const scale = Math.min(w / previewWidth, h / previewHeight);
      const dw = previewWidth * scale;
      const dh = previewHeight * scale;
      const dx = (w - dw) / 2;
      const dy = (h - dh) / 2;

      // 翻转 Y 轴
      ctx.save();
      ctx.translate(0, h);
      ctx.scale(1, -1);
      ctx.drawImage(tempCanvas, 0, 0, previewWidth, previewHeight, dx, h - dy - dh, dw, dh);
      ctx.restore();

      // 保存到缓存
      renderCache.largePreview.set(craftType, {
        canvas: tempCanvas,
        width: previewWidth,
        height: previewHeight
      });
    }

    // 智能缩略图更新调度器 - 只更新指定工艺类型
    function scheduleThumbnailUpdate(craftType) {
      if (craftType) {
        // 只更新单个工艺的缩略图
        const canvas = document.querySelector(`.craft-thumbnail-canvas[data-craft-type="${craftType}"]`);
        if (canvas) {
          renderCraftThumbnail(canvas, craftType);
        }
      }
    }

    // 更新所有工艺缩略图（仅在高度图数据变化时调用）
    function updateAllCraftThumbnails() {
      const canvases = document.querySelectorAll('.craft-thumbnail-canvas');
      canvases.forEach(canvas => {
        const craftType = canvas.getAttribute('data-craft-type');
        if (craftType) {
          renderCraftThumbnail(canvas, craftType);
        }
      });
    }

    // 更新大图预览（如果打开的话）
    function updateCraftLargePreview() {
      if (!window.currentCraftType) return; // 如果大图预览没有打开，直接返回

      const canvas = document.getElementById('craftLargePreviewCanvas');
      if (!canvas) return;

      renderCraftLargePreview(canvas, window.currentCraftType);
    }

    // 显示高度图预览
    function showHeightPreview(imageData, width, height) {
      previewWidth = width;
      previewHeight = height;
      previewHeightData = imageData;
      
      // Reset override when new data arrives
      overrideNormalInput = null;

      // 高度图数据变化，清除所有渲染缓存
      // 注释掉 invalidateAll，改为在更新预览后自动重新渲染
      // renderCache.invalidateAll();

      // 显示 Height Map 预览
      const heightCanvas = document.getElementById('heightPreview');
      if (heightCanvas) {
        const ctx = heightCanvas.getContext('2d');
        const w = heightCanvas.width, h = heightCanvas.height;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        const imgData = tempCtx.createImageData(width, height);
        imgData.data.set(imageData);
        tempCtx.putImageData(imgData, 0, 0);

        // 绘制到预览 canvas
        ctx.clearRect(0, 0, w, h);
        ctx.drawImage(tempCanvas, 0, 0, w, h);
      }

      // 自动更新所有工艺预览
      updateNormalPreview();
      updateEmbossPreview();
      updateMetalPreview();
      updateUVPreview();

      // 更新左侧工艺缩略图
      updateAllCraftThumbnails();
    }

    // 解码 PNG 并显示预览
    async function decodePNGAndShowPreview(pngBytes, isImageNode = false) {
      const blob = new Blob([pngBytes], { type: 'image/png' });
      const url = URL.createObjectURL(blob);
      const img = new Image();

      img.onload = () => {
        const w = img.width, h = img.height;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const ctx = tempCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0);

        const imgData = ctx.getImageData(0, 0, w, h);

        // 只对图像节点翻转 Y 轴
        let finalData = imgData.data;
        if (isImageNode) {
          finalData = flipImageY(imgData.data, w, h);
        }
        showHeightPreview(finalData, w, h);

        setStatus('Preview loaded', 'success');
        URL.revokeObjectURL(url);
      };

      img.onerror = () => {
        setStatus('Failed to decode image', 'error');
        URL.revokeObjectURL(url);
      };

      img.src = url;
    }

    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;
    let panelCollapsed = false;

    // 当前激活的 Tab
    let activeTab = 'export';

    // 折叠组状态
    let foldGroups = [];
    let selectedGroupId = null;

    // 折叠边状态
    let foldEdges = [];
    let foldEdgeOrderMap = {};
    let selectedFoldEdgeId = null;
    let foldPanelVisible = false;
    let rootPanelId = null;
    let drivenRelations = {};
    let manualDrivenRelations = {}; // 手动设置的带动关系 { parentId: [childId1, childId2, ...] }
    let deletedEdgeIds = []; // 记住用户删除的边

    let drivenGroupOrder = [];

    let saveDrivenRelationsTimer = null;

    function scheduleSaveDrivenRelations() {
      if (!sourceFrameId) return;
      if (saveDrivenRelationsTimer) {
        clearTimeout(saveDrivenRelationsTimer);
      }
      saveDrivenRelationsTimer = setTimeout(() => {
        parent.postMessage({
          pluginMessage: {
            type: 'saveDrivenRelations',
            frameId: sourceFrameId,
            relations: {
              relations: manualDrivenRelations,
              order: drivenGroupOrder
            }
          }
        }, '*');
      }, 200);
    }

    // 手动创建折叠边模式
    let foldEdgeMode = false;
    let currentGhostEdge = null;
    let cachedBounds = null;
    let cachedScale = 1;

    // 面板命名映射 (vectorId -> panelCode)
    let panelNameMap = {};
    let hPanelId = null; // H 面的 vectorId

    // 获取面板的显示名称
    function getPanelDisplayName(vectorId, originalName) {
      return panelNameMap[vectorId] || originalName;
    }

    // 设置 H 面（双击设置）
    function setHPanel(vectorId) {
      hPanelId = vectorId;
      rootPanelId = allVectors.find(v => v.id === vectorId)?.name;
      panelNameMap = {};
      panelNameMap[vectorId] = 'H';
      autoAssignFromH();
    }

    // 基于 H 面自动命名所有面板
    // 横向顺序: R → F → L → H → HR
    function autoAssignFromH() {
      if (!hPanelId) return;

      const hPanel = allVectors.find(v => v.id === hPanelId);
      if (!hPanel) return;

      const selectedIds = Object.keys(vectorOrderMap);
      const selectedVectors = allVectors.filter(v => selectedIds.includes(v.id));

      const hLeft = hPanel.x;
      const hRight = hPanel.x + hPanel.width;
      const hTop = hPanel.y;
      const hBottom = hPanel.y + hPanel.height;

      // 找 H 左边所有相邻面板，按 x 坐标从右到左排序
      const leftPanels = selectedVectors
        .filter(v => {
          if (v.id === hPanelId) return false;
          const vCenterX = v.x + v.width / 2;
          const hasYOverlap = (v.y + v.height) > hTop && v.y < hBottom;
          // 面板中心在 H 左边
          return hasYOverlap && vCenterX < hLeft;
        })
        .sort((a, b) => b.x - a.x); // 从右到左

      console.log('leftPanels:', leftPanels.map(v => v.name));

      // 命名左边面板: L, F, R (从H往左)
      const leftNames = ['L', 'F', 'R'];
      leftPanels.forEach((v, i) => {
        if (i < leftNames.length) {
          panelNameMap[v.id] = leftNames[i];
        } else {
          panelNameMap[v.id] = 'R' + (i - 2);
        }
      });

      // H 右边相邻面板命名为 HR
      selectedVectors.forEach(v => {
        if (v.id === hPanelId || panelNameMap[v.id]) return;
        const vLeft = v.x;
        const hasYOverlap = (v.y + v.height) > hTop && v.y < hBottom;
        const isRight = vLeft >= hRight - 5;
        if (hasYOverlap && isRight) {
          let code = 'HR';
          let suffix = 1;
          while (Object.values(panelNameMap).includes(code)) {
            code = 'HR' + suffix++;
          }
          panelNameMap[v.id] = code;
        }
      });

      // 第二轮：命名 H 的上下相邻面板 (HT/HB)
      selectedVectors.forEach(v => {
        if (v.id === hPanelId || panelNameMap[v.id]) return;

        const vLeft = v.x;
        const vRight = v.x + v.width;
        const vTop = v.y;
        const vBottom = v.y + v.height;

        const isAbove = vBottom <= hTop + 5;
        const isBelow = vTop >= hBottom - 5;
        const hasXOverlap = vRight > hLeft && vLeft < hRight;

        let code = '';
        if (hasXOverlap && isAbove) code = 'HT';
        else if (hasXOverlap && isBelow) code = 'HB';

        if (code) {
          let finalCode = code;
          if (Object.values(panelNameMap).includes(finalCode)) {
            let suffix = 1;
            while (Object.values(panelNameMap).includes(code + suffix)) {
              suffix++;
            }
            finalCode = code + suffix;
          }
          panelNameMap[v.id] = finalCode;
        }
      });

      // 第三轮：基于已命名面板命名上下相邻面板
      // R上=FRT, R下=FRB, L上=FLT, L下=FLB, F上=FT, F下=FB
      assignVerticalPanels(selectedVectors);

      // 第四轮：剩余未命名
      assignRemainingPanels(selectedVectors);

      updateFigmaLayerNames();
      updateVectorGridUI();
      updateOrderPreview();
    }

    // 基于已命名面板命名上下相邻面板
    // 采用"最佳重叠匹配"策略，防止 H 抢占 L 的邻居
    function assignVerticalPanels(vectors) {
      // 1. 定义匹配批次
      // Batch 1: 基础面板 (L, R, H, F)
      // Batch 2: 二级面板 (HT, FB) - 必须在 Batch 1 之后，因为它们依赖 Batch 1 的结果
      const batches = [
        ['L', 'R', 'H', 'F'],
        ['HT', 'FB']
      ];

      // 临时存储最佳匹配：Map<vectorId, { baseCode, overlap, relation }>
      const candidates = new Map();

      // 尝试匹配函数
      const tryMatch = (baseCode) => {
        const namedId = Object.keys(panelNameMap).find(id => panelNameMap[id] === baseCode);
        if (!namedId) return;
        const basePanel = allVectors.find(v => v.id === namedId);
        if (!basePanel) return;

        const bLeft = basePanel.x;
        const bRight = basePanel.x + basePanel.width;
        const bTop = basePanel.y;
        const bBottom = basePanel.y + basePanel.height;

        vectors.forEach(v => {
          if (panelNameMap[v.id]) return; // 已命名的跳过

          const vLeft = v.x;
          const vRight = v.x + v.width;
          const vTop = v.y;
          const vBottom = v.y + v.height;
          
          // 计算重叠宽度
          const overlapW = Math.max(0, Math.min(vRight, bRight) - Math.max(vLeft, bLeft));
          if (overlapW <= 1) return; // 无有效重叠

          // 判定垂直相邻 (Gap < 30px)
          const isAbove = Math.abs(vBottom - bTop) < 30;
          const isBelow = Math.abs(vTop - bBottom) < 30;
          
          let relation = null;
          if (isAbove) relation = 'top';
          else if (isBelow) relation = 'bottom';
          
          if (!relation) return;

          // 记录最佳匹配 (重叠面积最大优先)
          const existing = candidates.get(v.id);
          if (!existing || overlapW > existing.overlap) {
            candidates.set(v.id, { baseCode, overlap: overlapW, relation });
          }
        });
      };

      // 应用匹配结果函数
      const applyCandidates = () => {
        candidates.forEach((match, vId) => {
          const { baseCode, relation } = match;
          let code = '';
          
          // 逻辑确认：
          // relation === 'top' 表示目标面板 v 在 baseCode 的上方 (v.bottom <= baseCode.top)
          // 用户要求：L 上面是 FLT，L 下面是 FLB
          // 之前的代码逻辑完全符合，但如果用户反馈不对，可能是因为 L 面板本身是反向的？
          // 或者之前的 "Best Match" 逻辑导致 L 没有抢过 H？
          // 这里我们严格执行：baseCode=L 且 relation=top -> FLT
          
          // 逻辑再次确认与修正：
          // 之前的强制交换可能因为坐标系理解偏差导致结果仍然不符合预期
          // 用户明确指出：L 下边是 FLB、上面是 FLT
          // 在屏幕坐标系中，y 值越小越靠上，y 值越大越靠下
          // relation === 'top' 是 v.bottom <= bTop，即 v 在 b 的上方 (y值更小) -> 命名为 FLT
          // relation === 'bottom' 是 v.top >= bBottom，即 v 在 b 的下方 (y值更大) -> 命名为 FLB
          // 因此，必须恢复为：Top -> FLT, Bottom -> FLB
          // 如果之前的版本用户说不对，可能是因为 L 本身被识别成了 R 或者 F？
          // 我们这里先严格按照 "Top=FLT, Bottom=FLB" 的逻辑写死，同时确保其他面板逻辑不变
          
          if (relation === 'top') {
            if (baseCode === 'H') code = 'HT';
            else if (baseCode === 'F') code = 'FT';
            else if (baseCode === 'L') code = 'FLT';
            else if (baseCode === 'R') code = 'FRT';
            else if (baseCode === 'HT') code = 'HT1';
          } else {
            if (baseCode === 'H') code = 'HB';
            else if (baseCode === 'F') code = 'FB';
            else if (baseCode === 'L') code = 'FLB';
            else if (baseCode === 'R') code = 'FRB';
            else if (baseCode === 'FB') code = 'FB1';
          }
          
          // 调试日志：打印匹配结果
          console.log(`Matched ${vId} relative to ${baseCode} (${relation}) -> ${code}`);
          
          if (code) {
            let finalCode = code;
            if (Object.values(panelNameMap).includes(finalCode)) {
              let suffix = 1;
              while (Object.values(panelNameMap).includes(code + suffix)) {
                suffix++;
              }
              finalCode = code + suffix;
            }
            panelNameMap[vId] = finalCode;
          }
        });
        candidates.clear();
      };

      // 执行批次
      batches.forEach(batch => {
        batch.forEach(code => tryMatch(code));
        applyCandidates();
      });
    }

    // 命名剩余未命名的面板
    function assignRemainingPanels(vectors) {
      vectors.forEach(v => {
        if (panelNameMap[v.id]) return;
        let code = 'P';
        let suffix = 1;
        let finalCode = code;
        while (Object.values(panelNameMap).includes(finalCode)) {
          finalCode = code + suffix;
          suffix++;
        }
        panelNameMap[v.id] = finalCode;
      });
    }

    // ============================================
    // N面板 Tab 切换
    // ============================================
    function switchTab(tabId) {
      activeTab = tabId;
      // 更新 Tab 按钮状态
      document.querySelectorAll('.panel-tab').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById('tab' + tabId.charAt(0).toUpperCase() + tabId.slice(1)).classList.add('active');
      // 更新内容区域
      document.querySelectorAll('.panel-tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById('tabContent' + tabId.charAt(0).toUpperCase() + tabId.slice(1)).classList.add('active');
      // 切换到折叠 Tab 时更新内容
      if (tabId === 'fold') {
        updateFoldTabContent();
      }
    }

    // ============================================
    // 折叠组管理
    // ============================================
    function addFoldGroup() {
      const newGroup = {
        id: 'group-' + Date.now(),
        name: '折叠组 ' + (foldGroups.length + 1),
        panelIds: [],
        order: foldGroups.length,
        expanded: true,
        foldAngle: 90
      };
      foldGroups.push(newGroup);
      updateFoldGroupList();
    }

    function toggleGroupExpand(groupId) {
      const group = foldGroups.find(g => g.id === groupId);
      if (group) {
        group.expanded = !group.expanded;
        updateFoldGroupList();
      }
    }

    function updateGroupAngle(groupId, angle) {
      const group = foldGroups.find(g => g.id === groupId);
      if (group) {
        group.foldAngle = parseInt(angle);
      }
    }

    function deleteGroup(groupId) {
      foldGroups = foldGroups.filter(g => g.id !== groupId);
      foldGroups.forEach((g, i) => g.order = i);
      updateFoldGroupList();
    }

    function updateFoldGroupList() {
      const container = document.getElementById('foldGroupList');
      if (!container) return;

      if (foldGroups.length === 0) {
        container.innerHTML = `<div class="fold-group-empty">暂无折叠组，点击下方按钮添加</div>`;
        return;
      }

      let html = '';
      foldGroups.sort((a, b) => a.order - b.order).forEach((group, idx) => {
        html += `<div class="fold-group-item ${selectedGroupId === group.id ? 'selected' : ''}"
                     draggable="true"
                     ondragstart="onGroupDragStart(event, '${group.id}')"
                     ondragover="onGroupDragOver(event)"
                     ondrop="onGroupDrop(event, '${group.id}')"
                     onclick="selectedGroupId='${group.id}'; updateFoldGroupList();">
          <div class="fold-group-header">
            <button class="fold-group-expand ${group.expanded ? 'expanded' : ''}"
                    onclick="event.stopPropagation(); toggleGroupExpand('${group.id}')">▶</button>
            <span class="fold-group-name">📁 ${group.name}</span>
            <span class="fold-group-order">${idx + 1}</span>
            <button onclick="event.stopPropagation(); deleteGroup('${group.id}')"
                    style="background:none;border:none;color:#f87171;cursor:pointer;font-size:12px;">×</button>
          </div>
          <div class="fold-group-content ${group.expanded ? 'expanded' : ''}">
            <div class="fold-group-angle">
              <label>角度</label>
              <input type="range" min="0" max="180" value="${group.foldAngle}"
                     onchange="updateGroupAngle('${group.id}', this.value)"
                     onclick="event.stopPropagation()">
              <span>${group.foldAngle}°</span>
            </div>
            <div class="fold-group-panels">
              ${group.panelIds.length > 0
                ? group.panelIds.map((pid, i) => `<div class="fold-panel-item">${i+1}. ${pid}</div>`).join('')
                : '<div class="fold-group-empty">无面板</div>'}
            </div>
          </div>
        </div>`;
      });
      container.innerHTML = html;
    }

    // 拖拽排序
    let draggedGroupId = null;
    function onGroupDragStart(e, groupId) {
      draggedGroupId = groupId;
      e.target.classList.add('dragging');
    }
    function onGroupDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('drag-over');
    }
    function onGroupDrop(e, targetId) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');
      if (!draggedGroupId || draggedGroupId === targetId) return;

      const fromIdx = foldGroups.findIndex(g => g.id === draggedGroupId);
      const toIdx = foldGroups.findIndex(g => g.id === targetId);
      const [moved] = foldGroups.splice(fromIdx, 1);
      foldGroups.splice(toIdx, 0, moved);
      foldGroups.forEach((g, i) => g.order = i);
      draggedGroupId = null;
      updateFoldGroupList();
    }

    // 导出折叠 JSON
    function exportFoldJSON() {
      const data = {
        version: '1.0.0',
        rootPanelId: rootPanelId,
        groups: foldGroups,
        edges: foldEdges,
        foldSequence: Object.entries(foldEdgeOrderMap)
          .sort((a, b) => a[1] - b[1])
          .map(([id]) => id)
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `fold-data-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      setStatus('已导出折叠 JSON', 'success');
    }

    // 自动分配面板代码（找最大面板作为H，然后自动命名）
    function autoAssignPanelCodes() {
      if (allVectors.length === 0) return;

      const selectedIds = Object.keys(vectorOrderMap);
      const selectedVectors = allVectors.filter(v => selectedIds.includes(v.id));
      if (selectedVectors.length === 0) return;

      // 按面积排序，最大的作为 H
      const sortedByArea = [...selectedVectors].sort((a, b) =>
        (b.width * b.height) - (a.width * a.height)
      );

      // 设置最大面板为 H，触发自动命名
      setHPanel(sortedByArea[0].id);
    }

    // 更新 Figma 图层名称
    function updateFigmaLayerNames() {
      const renames = [];
      for (const [vectorId, code] of Object.entries(panelNameMap)) {
        renames.push({ id: vectorId, name: code });
      }
      if (renames.length > 0) {
        parent.postMessage({ pluginMessage: { type: 'renameVectors', renames } }, '*');
      }
    }

    // 手动设置面板代码
    function setPanelCode(vectorId, code) {
      panelNameMap[vectorId] = code;
      updateFigmaLayerNames();
      updateVectorGridUI();
    }

    // Toggle Functions
    function toggleClipMode() {
      clipModeEnabled = !clipModeEnabled;
      document.getElementById('clipModeRow').classList.toggle('active', clipModeEnabled);
      document.getElementById('clipModeSwitch').classList.toggle('active', clipModeEnabled);
      if (clipModeEnabled) refreshVectors();
    }

    function toggleCraftVector() {
      craftVectorEnabled = !craftVectorEnabled;
      document.getElementById('craftVectorRow').classList.toggle('active', craftVectorEnabled);
      document.getElementById('craftVectorSwitch').classList.toggle('active', craftVectorEnabled);

      // Craft Vector toggle is declarative only. Generation must happen only during explicit export.
    }

    // ============================================
    // 面板折叠控制
    // ============================================
    function togglePanel() {
      panelCollapsed = !panelCollapsed;
      const panel = document.getElementById('controlPanel');
      const icon = document.getElementById('toggleIcon');
      panel.classList.toggle('collapsed', panelCollapsed);
      icon.textContent = panelCollapsed ? '‹' : '›';
      // 重新渲染画布
      setTimeout(() => updateVectorGridUI(), 350);
    }

    // ============================================
    // 画布缩放和平移控制
    // ============================================
    function zoomIn() {
      canvasZoom = Math.min(canvasZoom * 1.25, 4);
      applyCanvasTransform();
    }

    function zoomOut() {
      canvasZoom = Math.max(canvasZoom / 1.25, 0.25);
      applyCanvasTransform();
    }

    function resetView() {
      canvasZoom = 1;
      canvasPanX = 0;
      canvasPanY = 0;
      applyCanvasTransform();
    }

    function applyCanvasTransform() {
      const viewport = document.getElementById('spatialViewport');
      if (!viewport) return;
      viewport.style.transform = `translate(-50%, -50%) translate(${canvasPanX}px, ${canvasPanY}px) scale(${canvasZoom})`;
      document.getElementById('zoomDisplay').textContent = Math.round(canvasZoom * 100) + '%';
    }

    function isPointerOutsidePreviewBounds(e) {
      const viewport = document.getElementById('spatialViewport');
      if (!viewport) return false;

      const cards = viewport.querySelectorAll('.vector-card');
      if (cards.length > 0 && cards.length <= 2000) {
        let left = Infinity;
        let right = -Infinity;
        let top = Infinity;
        let bottom = -Infinity;

        for (let i = 0; i < cards.length; i++) {
          const r = cards[i].getBoundingClientRect();
          if (r.width === 0 || r.height === 0) continue;
          if (r.left < left) left = r.left;
          if (r.right > right) right = r.right;
          if (r.top < top) top = r.top;
          if (r.bottom > bottom) bottom = r.bottom;
        }

        if (left !== Infinity) {
          return e.clientX < left || e.clientX > right || e.clientY < top || e.clientY > bottom;
        }
      }

      const rect = viewport.getBoundingClientRect();
      return e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom;
    }

    // ============================================
    // 折叠边逻辑
    // ============================================

    // 切换折叠顺序面板
    function toggleFoldPanel(event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      foldPanelVisible = !foldPanelVisible;
      const panel = document.getElementById('foldOrderPanel');
      panel.style.display = foldPanelVisible ? 'block' : 'none';
    }

    function toggleFoldPanelMinimize(event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      const panel = document.getElementById('foldOrderPanel');
      if (!panel) return;
      panel.classList.toggle('minimized');
    }

    // 设置根面板
    function setRootPanel(panelName) {
      rootPanelId = rootPanelId === panelName ? null : panelName;
      foldPanelVisible = true;
      document.getElementById('foldOrderPanel').style.display = 'block';
      updateVectorGridUI();
    }

    // 切换折叠边创建模式
    function toggleFoldEdgeMode() {
      foldEdgeMode = !foldEdgeMode;
      // 更新开关状态
      document.getElementById('foldEdgeModeRow')?.classList.toggle('active', foldEdgeMode);
      document.getElementById('foldEdgeModeSwitch')?.classList.toggle('active', foldEdgeMode);
      updateVectorGridUI();
      updateFoldOrderPanel();
      updateFoldTabContent();
    }

    // 点击 ghost 边创建折叠边
    function createEdgeFromGhost(panel1Name, panel2Name, panel1Id, panel2Id) {
      createManualFoldEdge(
        { id: panel1Id, name: panel1Name },
        { id: panel2Id, name: panel2Name }
      );
      updateVectorGridUI();
      updateFoldOrderPanel();
    }

    // 手动创建折叠边
    function createManualFoldEdge(panel1, panel2) {
      const edgeId = `edge-${panel1.id}-${panel2.id}-m`;
      // 检查是否已存在
      if (foldEdges.find(e => e.id === edgeId)) return;

      foldEdges.push({
        id: edgeId,
        type: 'horizontal', // 默认横向，实际渲染时会根据位置调整
        source: 'manual',
        panel1: panel1.name,
        panel2: panel2.name,
        panel1Id: panel1.id,
        panel2Id: panel2.id
      });

      // 自动分配序号
      const nextNum = Object.keys(foldEdgeOrderMap).length + 1;
      foldEdgeOrderMap[edgeId] = nextNum;
    }

    // 删除折叠边
    function removeFoldEdge(edgeId) {
      // 记录删除的边ID，防止重新检测时再次出现
      if (!deletedEdgeIds.includes(edgeId)) {
        deletedEdgeIds.push(edgeId);
      }
      foldEdges = foldEdges.filter(e => e.id !== edgeId);
      delete foldEdgeOrderMap[edgeId];
      // 重新编号
      const ordered = Object.entries(foldEdgeOrderMap)
        .sort((a, b) => a[1] - b[1]);
      foldEdgeOrderMap = {};
      ordered.forEach(([id], i) => {
        foldEdgeOrderMap[id] = i + 1;
      });
      renderFoldEdges();
      updateFoldOrderPanel();
      updateFoldTabContent();
    }

    // 切换折叠顺序预览栏的展开/收起状态
    function toggleOrderPreview(event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      const orderPreview = document.getElementById('orderPreview');
      const toggleIcon = document.getElementById('orderToggleIcon');

      if (orderPreview.classList.contains('minimized')) {
        // 展开
        orderPreview.classList.remove('minimized');
        toggleIcon.textContent = '▼';
      } else {
        // 最小化
        orderPreview.classList.add('minimized');
        toggleIcon.textContent = '▶';
      }
    }

    // 一键取消所有排序
    function clearAllSelections(event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      vectorOrderMap = {};
      panelNameMap = {};
      foldEdges = [];
      foldEdgeOrderMap = {};
      deletedEdgeIds = [];
      hPanelId = null;
      manualDrivenRelations = {};
      drivenGroupOrder = [];
      // 同步清空到 Figma
      updateSelectedVectors();
      scheduleSaveDrivenRelations();
      updateVectorGridUI();
      updateOrderPreview();
      updateFoldOrderPanel();
      updateFoldTabContent();
    }

    // 检测折叠边 - 自动检测 + 保留手动添加的
    function detectFoldEdges() {
      // 保留手动添加的折叠边（source === 'manual'）
      const manualEdges = foldEdges.filter(e => e.source === 'manual');
      foldEdges = [...manualEdges];

      if (allVectors.length < 2) {
        updateFoldOrderPanel();
        return;
      }

      // 自动检测
      for (let i = 0; i < allVectors.length; i++) {
        for (let j = i + 1; j < allVectors.length; j++) {
          const v1 = allVectors[i];
          const v2 = allVectors[j];
          const edge = findSharedEdge(v1, v2);
          if (edge) {
            // 跳过已删除的边
            if (deletedEdgeIds.includes(edge.id)) continue;
            // 用 id 检查是否已存在
            const exists = foldEdges.find(e => e.id === edge.id);
            if (!exists) {
              edge.source = 'auto';
              foldEdges.push(edge);
            }
          }
        }
      }

      // 自动给新检测到的折叠边分配序号
      foldEdges.forEach(edge => {
        if (!foldEdgeOrderMap[edge.id]) {
          const nextNum = Object.keys(foldEdgeOrderMap).length + 1;
          foldEdgeOrderMap[edge.id] = nextNum;
        }
      });

      renderFoldEdges();
      updateFoldOrderPanel();
      updateFoldTabContent();
    }

    // 检查两个面板之间是否有其他面板阻挡
    function hasBlockingPanel(v1, v2, edgeType, edgePos, overlapStart, overlapEnd) {
      for (const v of allVectors) {
        if (v.id === v1.id || v.id === v2.id) continue;

        if (edgeType === 'horizontal') {
          // 检查是否有面板在这条横线上阻挡
          // 面板的y范围必须跨越edgePos，且x范围与重叠部分有交集
          if (v.y < edgePos && v.y + v.height > edgePos) {
            const vLeft = v.x;
            const vRight = v.x + v.width;
            if (vRight > overlapStart && vLeft < overlapEnd) {
              return true;
            }
          }
        } else {
          // 检查是否有面板在这条竖线上阻挡
          // 面板的x范围必须跨越edgePos，且y范围与重叠部分有交集
          if (v.x < edgePos && v.x + v.width > edgePos) {
            const vTop = v.y;
            const vBottom = v.y + v.height;
            if (vBottom > overlapStart && vTop < overlapEnd) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // 查找两个 vector 的共用边（只要边相邻且有重叠就识别）
    function findSharedEdge(v1, v2) {
      const tolerance = 10; // 边缘对齐容差
      const minOverlap = 5; // 最小重叠长度

      function getOverlap(a1, a2, b1, b2) {
        const start = Math.max(a1, b1);
        const end = Math.min(a2, b2);
        if (end - start < minOverlap) return null;
        return { start, end, length: end - start };
      }

      // 横向共用边（v1 底边 ≈ v2 顶边）
      if (Math.abs((v1.y + v1.height) - v2.y) < tolerance) {
        const overlap = getOverlap(v1.x, v1.x + v1.width, v2.x, v2.x + v2.width);
        if (overlap) {
          return {
            id: `edge-${v1.id}-${v2.id}-h`,
            type: 'horizontal',
            panel1: v1.name,
            panel2: v2.name,
            x: overlap.start,
            y: v1.y + v1.height,
            width: overlap.length,
            height: 2
          };
        }
      }
      // v2 底边 = v1 顶边
      if (Math.abs((v2.y + v2.height) - v1.y) < tolerance) {
        const overlap = getOverlap(v1.x, v1.x + v1.width, v2.x, v2.x + v2.width);
        if (overlap) {
          return {
            id: `edge-${v2.id}-${v1.id}-h`,
            type: 'horizontal',
            panel1: v2.name,
            panel2: v1.name,
            x: overlap.start,
            y: v2.y + v2.height,
            width: overlap.length,
            height: 2
          };
        }
      }

      // 竖向共用边（v1 右边 ≈ v2 左边）
      if (Math.abs((v1.x + v1.width) - v2.x) < tolerance) {
        const overlap = getOverlap(v1.y, v1.y + v1.height, v2.y, v2.y + v2.height);
        if (overlap) {
          return {
            id: `edge-${v1.id}-${v2.id}-v`,
            type: 'vertical',
            panel1: v1.name,
            panel2: v2.name,
            x: v1.x + v1.width,
            y: overlap.start,
            width: 2,
            height: overlap.length
          };
        }
      }
      // v2 右边 = v1 左边
      if (Math.abs((v2.x + v2.width) - v1.x) < tolerance) {
        const overlap = getOverlap(v1.y, v1.y + v1.height, v2.y, v2.y + v2.height);
        if (overlap) {
          return {
            id: `edge-${v2.id}-${v1.id}-v`,
            type: 'vertical',
            panel1: v2.name,
            panel2: v1.name,
            x: v2.x + v2.width,
            y: overlap.start,
            width: 2,
            height: overlap.length
          };
        }
      }

      return null;
    }

    // 渲染折叠边到画布
    function renderFoldEdges() {
      const viewport = document.getElementById('spatialViewport');
      if (!viewport || foldEdges.length === 0) return;

      const bounds = calculateBounds(allVectors);
      const canvas = document.getElementById('spatialCanvas');
      const canvasW = canvas.clientWidth || 400;
      const canvasH = canvas.clientHeight || 300;
      const padding = 16;
      const scale = Math.min((canvasW - padding * 2) / bounds.width, (canvasH - padding * 2) / bounds.height);

      // 移除旧的折叠边
      viewport.querySelectorAll('.fold-edge').forEach(el => el.remove());

      foldEdges.forEach((edge, idx) => {
        const isSelected = selectedFoldEdgeId === edge.id;
        const orderNum = foldEdgeOrderMap[edge.id];

        const left = (edge.x - bounds.minX) * scale;
        const top = (edge.y - bounds.minY) * scale;
        const width = edge.type === 'horizontal' ? edge.width * scale : 2;
        const height = edge.type === 'vertical' ? edge.height * scale : 2;

        const div = document.createElement('div');
        div.className = `fold-edge ${edge.type} ${isSelected ? 'selected' : ''}`;
        div.style.left = left + 'px';
        div.style.top = top + 'px';
        div.style.width = width + 'px';
        div.style.height = height + 'px';
        div.onclick = () => selectFoldEdge(edge.id);
        div.oncontextmenu = (e) => {
          e.preventDefault();
          removeFoldEdge(edge.id);
          renderFoldEdges();
          updateFoldOrderPanel();
        };
        div.title = '左键: 设置顺序 | 右键: 删除';

        if (orderNum) {
          div.innerHTML = `<div class="fold-edge-badge">${orderNum}</div>`;
        }

        viewport.appendChild(div);
      });
    }

    // 选择折叠边
    function selectFoldEdge(edgeId) {
      if (foldEdgeOrderMap[edgeId]) {
        delete foldEdgeOrderMap[edgeId];
      } else {
        const nextNum = Object.keys(foldEdgeOrderMap).length + 1;
        foldEdgeOrderMap[edgeId] = nextNum;
      }
      selectedFoldEdgeId = edgeId;
      foldPanelVisible = true;
      document.getElementById('foldOrderPanel').style.display = 'block';
      renderFoldEdges();
      updateFoldOrderPanel();
    }

    // 计算带动关系树（优先使用手动设置）
    function buildDrivenTree() {
      drivenRelations = {};
      if (!rootPanelId) return;

      // 如果有手动设置的关系，直接使用
      if (Object.keys(manualDrivenRelations).length > 0) {
        drivenRelations = JSON.parse(JSON.stringify(manualDrivenRelations));
        return;
      }

      // 否则自动检测
      if (foldEdges.length === 0) return;

      const visited = new Set([rootPanelId]);
      const queue = [rootPanelId];

      while (queue.length > 0) {
        const current = queue.shift();
        drivenRelations[current] = [];

        foldEdges.forEach(edge => {
          let child = null;
          if (edge.panel1 === current && !visited.has(edge.panel2)) {
            child = edge.panel2;
          } else if (edge.panel2 === current && !visited.has(edge.panel1)) {
            child = edge.panel1;
          }
          if (child) {
            visited.add(child);
            drivenRelations[current].push(child);
            queue.push(child);
          }
        });
      }
    }

    // 更新折叠顺序面板
    function updateFoldOrderPanel() {
      const content = document.getElementById('foldOrderContent');
      const tabContent = document.getElementById('foldOrderPanelInTab');
      let html = '';

      // 添加折叠边模式开关
      html += `<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; padding: 6px 8px; background: rgba(0,0,0,0.2); border-radius: 4px;">
        <input type="checkbox" id="foldEdgeModeCheck" ${foldEdgeMode ? 'checked' : ''} onchange="toggleFoldEdgeMode()" style="cursor: pointer;">
        <label for="foldEdgeModeCheck" style="font-size: 10px; color: var(--color-neutral-300); cursor: pointer; flex: 1;">编辑折叠边</label>
      </div>`;

      // 模式提示
      if (foldEdgeMode) {
        html += `<div style="padding: 6px 8px; background: rgba(236, 72, 153, 0.15); border-radius: 4px; margin-bottom: 8px; font-size: 9px; color: #f472b6;">
          点击虚线添加 · 点击×删除
        </div>`;
      }

      if (foldEdges.length === 0) {
        html += '<div style="color: var(--color-neutral-500); font-size: 10px; text-align: center; padding: 12px;">暂无折叠边</div>';
        if (content) content.innerHTML = html;
        if (tabContent) tabContent.innerHTML = html;
        return;
      }

      // 构建带动关系
      buildDrivenTree();

      // 根面板选择提示
      if (!rootPanelId) {
        html += `<div style="padding: 8px; background: rgba(245, 158, 11, 0.1); border-radius: 6px; margin-bottom: 8px; font-size: 10px; color: var(--color-warning);">
          💡 点击面板设置为根节点（不动的基准面）
        </div>`;
      }

      // 带动关系树
      if (rootPanelId && Object.keys(drivenRelations).length > 0) {
        html += `<div style="margin-bottom: 12px;">
          <div style="font-size: 9px; color: var(--color-neutral-500); text-transform: uppercase; margin-bottom: 6px;">带动关系</div>`;
        html += renderDrivenNode(rootPanelId, 0);
        html += `</div>`;
      }

      // 折叠边列表
      const ordered = foldEdges
        .filter(e => foldEdgeOrderMap[e.id])
        .sort((a, b) => foldEdgeOrderMap[a.id] - foldEdgeOrderMap[b.id]);

      if (ordered.length > 0) {
        html += `<div style="font-size: 9px; color: var(--color-neutral-500); text-transform: uppercase; margin-bottom: 6px;">折叠边 (${ordered.length})</div>`;
      }

      ordered.forEach(edge => {
        const num = foldEdgeOrderMap[edge.id];
        html += `<div class="fold-edge-item" style="display: flex; align-items: center; gap: 6px;">
          <span style="font-size: 10px; color: var(--color-primary-400); font-weight: 600; min-width: 16px;">${num}</span>
          <span style="font-size: 10px; color: var(--color-neutral-300); flex: 1;">${edge.panel1} ↔ ${edge.panel2}</span>
          <button onclick="removeFoldEdge('${edge.id}')" style="background: none; border: none; color: var(--color-neutral-500); cursor: pointer; font-size: 12px; padding: 2px 4px;" title="删除">×</button>
        </div>`;
      });

      content.innerHTML = html;
      // 同步到右侧 Tab
      if (tabContent) {
        tabContent.innerHTML = html;
      }
    }

    // 渲染带动关系节点 - 简化树形显示
    function renderDrivenNode(panelId, depth) {
      const isRoot = depth === 0;
      const children = drivenRelations[panelId] || [];
      const indent = depth > 0 ? '│  '.repeat(depth - 1) + '├─ ' : '';
      const prefix = isRoot ? '◆ ' : '';

      let html = `<div style="font-family: var(--font-mono); font-size: 11px; line-height: 1.6; color: ${isRoot ? 'var(--color-primary-400)' : 'var(--color-neutral-300)'};">
        <span style="color: var(--color-neutral-600);">${indent}</span>${prefix}${panelId}${isRoot ? ' (根)' : ''}
      </div>`;

      children.forEach((child, i) => {
        html += renderDrivenNode(child, depth + 1);
      });

      return html;
    }

    // ============================================
    // 右侧折叠 Tab 内容更新
    // ============================================
    let draggedEdgeId = null;

    function updateFoldTabContent() {
      // 更新根面板提示
      const rootHint = document.getElementById('rootPanelHint');
      if (rootHint) {
        rootHint.style.display = rootPanelId ? 'none' : 'block';
      }

      // 构建带动关系
      buildDrivenTree();

      // 更新PS图层形式的折叠顺序
      updateFoldLayerTree();

      // 更新父子面板下拉选项
      updateDrivenSelects();

      // 更新带动关系树显示
      updateDrivenTreeSection();
    }

    // PS图层形式的折叠顺序
    let draggedLayerId = null;

    function updateFoldLayerTree() {
      const container = document.getElementById('foldLayerTree');
      if (!container) return;

      // 获取已排序的折叠边
      const orderedEdges = foldEdges
        .filter(e => foldEdgeOrderMap[e.id])
        .sort((a, b) => foldEdgeOrderMap[a.id] - foldEdgeOrderMap[b.id]);

      // 如果没有折叠边，显示提示
      if (orderedEdges.length === 0) {
        container.innerHTML = '<div class="fold-layer-empty">点击折叠边设置顺序</div>';
        return;
      }

      // 渲染折叠边列表（支持拖拽排序）
      let html = '';
      orderedEdges.forEach((edge, idx) => {
        const num = foldEdgeOrderMap[edge.id];
        const typeClass = edge.type === 'horizontal' ? 'horizontal' : 'vertical';
        const typeIcon = edge.type === 'horizontal' ? 'H' : 'V';

        html += `<div class="fold-layer-item" draggable="true" data-edge-id="${edge.id}"
                     ondragstart="onFoldLayerDragStart(event, '${edge.id}')"
                     ondragover="onFoldLayerDragOver(event)"
                     ondragleave="onFoldLayerDragLeave(event)"
                     ondrop="onFoldLayerDrop(event, '${edge.id}')">
          <span class="fold-layer-num" style="background: ${edge.type === 'horizontal' ? '#ec4899' : '#10b981'};">${num}</span>
          <span style="font-size: 9px; color: ${edge.type === 'horizontal' ? '#ec4899' : '#10b981'}; margin-right: 2px;">${typeIcon}</span>
          <span class="fold-layer-name">${edge.panel1}</span>
          <span class="fold-layer-arrow">↔</span>
          <span class="fold-layer-name">${edge.panel2}</span>
          <button onclick="event.stopPropagation(); removeFoldEdge('${edge.id}')" style="margin-left: auto; background: none; border: none; color: var(--color-neutral-500); cursor: pointer; font-size: 12px; padding: 2px 4px;" title="删除">×</button>
        </div>`;
      });

      // 添加重置按钮
      if (Object.keys(manualDrivenRelations).length > 0) {
        html += `<button onclick="resetToAutoDetect()" style="margin-top: 8px; padding: 4px 8px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 4px; color: #f87171; font-size: 10px; cursor: pointer; width: 100%;">
          ⟲ 重置为自动检测
        </button>`;
      }

      container.innerHTML = html;
    }

    // 折叠顺序列表拖拽排序
    let draggedFoldLayerId = null;

    function onFoldLayerDragStart(e, edgeId) {
      draggedFoldLayerId = edgeId;
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function onFoldLayerDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('drag-over');
    }

    function onFoldLayerDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function onFoldLayerDrop(e, targetId) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      if (!draggedFoldLayerId || draggedFoldLayerId === targetId) {
        draggedFoldLayerId = null;
        return;
      }

      // 重新排序
      const orderedEdges = foldEdges
        .filter(edge => foldEdgeOrderMap[edge.id])
        .sort((a, b) => foldEdgeOrderMap[a.id] - foldEdgeOrderMap[b.id]);

      const fromIdx = orderedEdges.findIndex(e => e.id === draggedFoldLayerId);
      const toIdx = orderedEdges.findIndex(e => e.id === targetId);

      if (fromIdx !== -1 && toIdx !== -1) {
        const [moved] = orderedEdges.splice(fromIdx, 1);
        orderedEdges.splice(toIdx, 0, moved);

        // 重新分配序号
        foldEdgeOrderMap = {};
        orderedEdges.forEach((edge, i) => {
          foldEdgeOrderMap[edge.id] = i + 1;
        });
      }

      draggedFoldLayerId = null;
      updateFoldLayerTree();
      renderFoldEdges();
      updateOrderPreview();
    }

    function renderLayerNode(panelId, depth) {
      const isRoot = depth === 0;
      const children = drivenRelations[panelId] || [];
      const indent = depth > 0 ? '│  '.repeat(depth - 1) + '├─ ' : '';

      let html = `<div class="fold-layer-item ${isRoot ? 'root' : ''}"
                       draggable="${!isRoot}"
                       data-panel="${panelId}"
                       ondragstart="onLayerDragStart(event, '${panelId}')"
                       ondragover="onLayerDragOver(event, '${panelId}')"
                       ondragleave="onLayerDragLeave(event)"
                       ondrop="onLayerDrop(event, '${panelId}')">
        <span class="fold-layer-indent">${indent}</span>
        <span class="fold-layer-icon">${isRoot ? '◆' : ''}</span>
        <span class="fold-layer-name ${isRoot ? 'root' : ''}">${panelId}</span>
        ${isRoot ? '<span class="fold-layer-badge">(根)</span>' : ''}
      </div>`;

      children.forEach(child => {
        html += renderLayerNode(child, depth + 1);
      });

      return html;
    }

    function onLayerDragStart(e, panelId) {
      draggedLayerId = panelId;
      e.target.classList.add('dragging');
    }

    function onLayerDragOver(e, targetId) {
      e.preventDefault();
      if (draggedLayerId && draggedLayerId !== targetId) {
        e.currentTarget.classList.add('drag-over');
      }
    }

    function onLayerDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function onLayerDrop(e, targetId) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      if (!draggedLayerId || draggedLayerId === targetId) {
        draggedLayerId = null;
        return;
      }

      // 初始化手动关系
      if (Object.keys(manualDrivenRelations).length === 0) {
        manualDrivenRelations = JSON.parse(JSON.stringify(drivenRelations));
      }

      // 从原父节点移除
      for (const pid in manualDrivenRelations) {
        manualDrivenRelations[pid] = manualDrivenRelations[pid].filter(c => c !== draggedLayerId);
      }

      // 添加到新父节点
      if (!manualDrivenRelations[targetId]) {
        manualDrivenRelations[targetId] = [];
      }
      manualDrivenRelations[targetId].push(draggedLayerId);

      draggedLayerId = null;
      updateFoldTabContent();
    }

    function updateDrivenTreeSection() {
      const section = document.getElementById('drivenTreeSection');
      const content = document.getElementById('drivenTreeContent');
      if (!section || !content) return;

      // 获取所有带动关系（优先手动设置）
      const relations = Object.keys(manualDrivenRelations).length > 0
        ? manualDrivenRelations
        : drivenRelations;

      // 过滤出有子面板的关系
      const activeRelations = Object.entries(relations)
        .filter(([parent, children]) => children && children.length > 0);

      if (activeRelations.length === 0) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';

      // 渲染带动关系列表
      let html = '';
      activeRelations.forEach(([parentId, children]) => {
        html += `<div style="display: flex; align-items: center; gap: 6px; padding: 6px 8px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-bottom: 4px;">
          <span style="font-size: 11px; color: var(--color-primary-400); font-weight: 500;">${parentId}</span>
          <span style="font-size: 10px; color: var(--color-neutral-500);">→</span>
          <div style="display: flex; flex-wrap: wrap; gap: 4px; flex: 1;">`;
        children.forEach(child => {
          html += `<span style="font-size: 10px; padding: 2px 6px; background: rgba(6,182,212,0.15); border-radius: 3px; color: var(--color-neutral-300);">${child}</span>`;
        });
        html += `</div>
          <button onclick="clearDrivenRelation('${parentId}')" style="background: none; border: none; color: var(--color-neutral-500); cursor: pointer; font-size: 12px;" title="清除">×</button>
        </div>`;
      });

      // 添加重置按钮（如果有手动设置）
      if (Object.keys(manualDrivenRelations).length > 0) {
        html += `<button onclick="resetToAutoDetect()" style="margin-top: 8px; padding: 4px 8px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 4px; color: #f87171; font-size: 10px; cursor: pointer; width: 100%;">
          ⟲ 重置为自动检测
        </button>`;
      }

      content.innerHTML = html;
    }

    // 清除某个父面板的带动关系
    function clearDrivenRelation(parentId) {
      if (Object.keys(manualDrivenRelations).length === 0) {
        manualDrivenRelations = JSON.parse(JSON.stringify(drivenRelations));
      }
      delete manualDrivenRelations[parentId];
      updateFoldTabContent();
      scheduleSaveDrivenRelations();
    }

    // 渲染可编辑的带动关系节点
    function renderEditableDrivenNode(panelId, parentId, depth) {
      const isRoot = depth === 0;
      const children = drivenRelations[panelId] || [];
      const indent = depth * 16;

      let html = `<div class="driven-tree-node-editable ${isRoot ? 'root' : ''}" style="padding-left: ${indent}px;">
        <span class="driven-node-name" style="color: ${isRoot ? 'var(--color-primary-400)' : 'var(--color-neutral-300)'};">
          ${isRoot ? '◆ ' : '├─ '}${panelId}${isRoot ? ' (根)' : ''}
        </span>
        ${!isRoot ? `<button class="driven-node-delete" onclick="removeDrivenRelation('${parentId}', '${panelId}')" title="移除此关系">×</button>` : ''}
      </div>`;

      children.forEach(child => {
        html += renderEditableDrivenNode(child, panelId, depth + 1);
      });

      return html;
    }

    // 更新折叠顺序列表（基于折叠边顺序，显示父面板和带动的子面板）
    function updateFoldSequenceList() {
      const container = document.getElementById('foldSequenceList');
      if (!container) return;

      // 获取已排序的折叠边
      const orderedEdges = foldEdges
        .filter(e => foldEdgeOrderMap[e.id])
        .sort((a, b) => foldEdgeOrderMap[a.id] - foldEdgeOrderMap[b.id]);

      if (orderedEdges.length === 0) {
        container.innerHTML = '<div class="fold-sequence-empty">点击折叠边设置顺序</div>';
        return;
      }

      let html = '';
      orderedEdges.forEach((edge, idx) => {
        const num = foldEdgeOrderMap[edge.id];
        // 获取这条边连接的两个面板
        const panel1 = edge.panel1;
        const panel2 = edge.panel2;
        // 获取带动关系
        const children1 = drivenRelations[panel1] || [];
        const children2 = drivenRelations[panel2] || [];

        html += `<div class="fold-sequence-item" draggable="true" data-edge-id="${edge.id}"
                     ondragstart="onSeqDragStart(event, '${edge.id}')"
                     ondragover="onSeqDragOver(event)"
                     ondragleave="onSeqDragLeave(event)"
                     ondrop="onSeqDrop(event, '${edge.id}')">
          <span class="fold-seq-num">${num}</span>
          <span class="fold-seq-parent">${panel1}</span>
          <span class="fold-seq-arrow">↔</span>
          <span class="fold-seq-parent">${panel2}</span>`;

        // 显示带动的子面板
        const allChildren = [...new Set([...children1, ...children2])].filter(c => c !== panel1 && c !== panel2);
        if (allChildren.length > 0) {
          html += `<span class="fold-seq-arrow">→</span>
            <div class="fold-seq-children">`;
          allChildren.forEach(child => {
            html += `<span class="fold-seq-child">${child}</span>`;
          });
          html += `</div>`;
        }

        html += `</div>`;
      });

      container.innerHTML = html;
    }

    // 折叠顺序拖拽
    let draggedSeqId = null;

    function onSeqDragStart(e, edgeId) {
      draggedSeqId = edgeId;
      e.target.classList.add('dragging');
    }

    function onSeqDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('drag-over');
    }

    function onSeqDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function onSeqDrop(e, targetId) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      if (!draggedSeqId || draggedSeqId === targetId) {
        draggedSeqId = null;
        return;
      }

      // 重新排序折叠边
      const orderedEdges = foldEdges
        .filter(edge => foldEdgeOrderMap[edge.id])
        .sort((a, b) => foldEdgeOrderMap[a.id] - foldEdgeOrderMap[b.id]);

      const fromIdx = orderedEdges.findIndex(e => e.id === draggedSeqId);
      const toIdx = orderedEdges.findIndex(e => e.id === targetId);

      if (fromIdx !== -1 && toIdx !== -1) {
        const [moved] = orderedEdges.splice(fromIdx, 1);
        orderedEdges.splice(toIdx, 0, moved);

        // 重新分配序号
        foldEdgeOrderMap = {};
        orderedEdges.forEach((edge, i) => {
          foldEdgeOrderMap[edge.id] = i + 1;
        });
      }

      draggedSeqId = null;
      updateFoldSequenceList();
      renderFoldEdges();
      updateOrderPreview();
    }

    function updateFoldEdgeList() {
      const container = document.getElementById('foldEdgeListInTab');
      if (!container) return;

      // 获取所有折叠边（包括已排序和未排序的）
      const allEdges = [...foldEdges];

      // 按序号排序，未排序的放最后
      allEdges.sort((a, b) => {
        const orderA = foldEdgeOrderMap[a.id] || 999;
        const orderB = foldEdgeOrderMap[b.id] || 999;
        return orderA - orderB;
      });

      if (allEdges.length === 0) {
        container.innerHTML = `<div class="fold-edge-empty">
          暂无折叠边<br>
          <span style="font-size: 9px; color: var(--color-neutral-600);">选择面板后自动检测</span>
        </div>`;
        return;
      }

      let html = '';
      allEdges.forEach((edge, idx) => {
        const orderNum = foldEdgeOrderMap[edge.id];
        const typeClass = edge.type === 'horizontal' ? 'horizontal' : 'vertical';

        html += `<div class="fold-edge-list-item"
                     draggable="true"
                     data-edge-id="${edge.id}"
                     ondragstart="onEdgeDragStart(event, '${edge.id}')"
                     ondragover="onEdgeDragOver(event)"
                     ondragleave="onEdgeDragLeave(event)"
                     ondrop="onEdgeDrop(event, '${edge.id}')">
          <div class="fold-edge-order ${typeClass}">${orderNum || '?'}</div>
          <div class="fold-edge-panels">
            <span>${edge.panel1}</span>
            <span class="fold-edge-arrow">↔</span>
            <span>${edge.panel2}</span>
          </div>
          <button class="fold-edge-delete" onclick="removeFoldEdgeFromTab('${edge.id}')" title="删除">×</button>
        </div>`;
      });

      container.innerHTML = html;
    }

    // 折叠边拖拽排序
    function onEdgeDragStart(e, edgeId) {
      draggedEdgeId = edgeId;
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function onEdgeDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('drag-over');
    }

    function onEdgeDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function onEdgeDrop(e, targetId) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      if (!draggedEdgeId || draggedEdgeId === targetId) {
        draggedEdgeId = null;
        return;
      }

      // 重新排序
      const orderedEdges = foldEdges
        .filter(edge => foldEdgeOrderMap[edge.id])
        .sort((a, b) => foldEdgeOrderMap[a.id] - foldEdgeOrderMap[b.id]);

      const fromIdx = orderedEdges.findIndex(e => e.id === draggedEdgeId);
      const toIdx = orderedEdges.findIndex(e => e.id === targetId);

      if (fromIdx !== -1 && toIdx !== -1) {
        const [moved] = orderedEdges.splice(fromIdx, 1);
        orderedEdges.splice(toIdx, 0, moved);

        // 重新分配序号
        foldEdgeOrderMap = {};
        orderedEdges.forEach((edge, i) => {
          foldEdgeOrderMap[edge.id] = i + 1;
        });
      }

      draggedEdgeId = null;
      updateFoldEdgeList();
      renderFoldEdges();
      updateOrderPreview();
    }

    function removeFoldEdgeFromTab(edgeId) {
      removeFoldEdge(edgeId);
      updateFoldTabContent();
    }

    // ============================================
    // 手动编辑带动关系
    // ============================================

    // 更新下拉选择框选项（双列表形式）
    function updateDrivenSelects() {
      const parentValue = document.getElementById('drivenParentSelect')?.value || '';
      const childValue = document.getElementById('drivenChildSelect')?.value || '';

      // 获取所有已选择的面板名称
      const selectedIds = Object.keys(vectorOrderMap);
      const panels = allVectors
        .filter(v => selectedIds.includes(v.id))
        .map(v => getPanelDisplayName(v.id, v.name));

      setDrivenDropdownOptions('parent', panels, '选择父面板...');
      setDrivenDropdownOptions('child', panels, '选择子面板...');

      // 恢复选中值（无效值会被清空）
      setDrivenDropdownValue('parent', panels.includes(parentValue) ? parentValue : '');
      setDrivenDropdownValue('child', panels.includes(childValue) ? childValue : '');

      // 更新组列表
      updateDrivenGroupList();
    }

    function closeDrivenDropdowns() {
      const parentMenu = document.getElementById('drivenParentMenu');
      const childMenu = document.getElementById('drivenChildMenu');
      const parentTrigger = document.querySelector('#drivenParentDropdown .driven-dropdown-trigger');
      const childTrigger = document.querySelector('#drivenChildDropdown .driven-dropdown-trigger');

      if (parentMenu) parentMenu.classList.remove('open');
      if (childMenu) childMenu.classList.remove('open');
      if (parentTrigger) parentTrigger.setAttribute('aria-expanded', 'false');
      if (childTrigger) childTrigger.setAttribute('aria-expanded', 'false');
    }

    function toggleDrivenDropdown(event, kind) {
      stopEvent(event);
      const menu = document.getElementById(kind === 'parent' ? 'drivenParentMenu' : 'drivenChildMenu');
      const trigger = document.querySelector(`#driven${kind === 'parent' ? 'Parent' : 'Child'}Dropdown .driven-dropdown-trigger`);
      if (!menu || !trigger) return;
      const isOpen = menu.classList.contains('open');
      closeDrivenDropdowns();
      if (!isOpen) {
        menu.classList.add('open');
        trigger.setAttribute('aria-expanded', 'true');
      }
    }

    function setDrivenDropdownOptions(kind, options, placeholder) {
      const menu = document.getElementById(kind === 'parent' ? 'drivenParentMenu' : 'drivenChildMenu');
      if (!menu) return;
      const safeOptions = Array.isArray(options) ? options : [];
      let html = '';
      html += `<div class="driven-dropdown-item" data-kind="${kind}" data-value="">${placeholder}</div>`;
      safeOptions.forEach((name) => {
        html += `<div class="driven-dropdown-item" data-kind="${kind}" data-value="${name}">${name}</div>`;
      });
      menu.innerHTML = html;
    }

    function setDrivenDropdownValue(kind, value) {
      const hidden = document.getElementById(kind === 'parent' ? 'drivenParentSelect' : 'drivenChildSelect');
      const label = document.getElementById(kind === 'parent' ? 'drivenParentLabel' : 'drivenChildLabel');
      const menu = document.getElementById(kind === 'parent' ? 'drivenParentMenu' : 'drivenChildMenu');
      const placeholder = kind === 'parent' ? '选择父面板...' : '选择子面板...';

      if (hidden) hidden.value = value || '';
      if (label) {
        if (value) {
          label.textContent = value;
          label.classList.remove('placeholder');
        } else {
          label.textContent = placeholder;
          label.classList.add('placeholder');
        }
      }

      if (menu) {
        const items = menu.querySelectorAll('.driven-dropdown-item');
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          const itemValue = item.getAttribute('data-value') || '';
          item.classList.toggle('selected', itemValue === (value || ''));
        }
      }
    }

    // 添加子面板到组
    function addChildToGroup() {
      const parentId = document.getElementById('drivenParentSelect')?.value;
      const childId = document.getElementById('drivenChildSelect')?.value;

      if (!parentId) {
        setStatus('请选择父面板', 'error');
        return;
      }
      if (!childId) {
        setStatus('请选择子面板', 'error');
        return;
      }
      if (parentId === childId) {
        setStatus('父面板和子面板不能相同', 'error');
        return;
      }

      // 初始化手动关系
      if (Object.keys(manualDrivenRelations).length === 0) {
        manualDrivenRelations = JSON.parse(JSON.stringify(drivenRelations));
      }

      // 从其他组移除该子面板
      for (const pid in manualDrivenRelations) {
        manualDrivenRelations[pid] = manualDrivenRelations[pid].filter(c => c !== childId);
      }

      // 添加到新组
      if (!manualDrivenRelations[parentId]) {
        manualDrivenRelations[parentId] = [];
      }
      if (!manualDrivenRelations[parentId].includes(childId)) {
        manualDrivenRelations[parentId].push(childId);
      }

      // 清空子面板选择
      setDrivenDropdownValue('child', '');

      updateDrivenGroupList();
      setStatus(`已添加: ${childId} → ${parentId}`, 'success');
      scheduleSaveDrivenRelations();
    }

    // 组展开状态
    let groupExpandState = {};

    // 组拖拽排序
    let draggedDrivenGroupId = null;

    // 更新 PS 风格的组列表
    function updateDrivenGroupList() {
      const container = document.getElementById('drivenGroupList');
      if (!container) return;

      const relations = Object.keys(manualDrivenRelations).length > 0
        ? manualDrivenRelations
        : drivenRelations;

      // 找出顶层父面板（不是任何其他面板的子面板）
      const allChildren = new Set();
      Object.values(relations).forEach(children => {
        children.forEach(c => allChildren.add(c));
      });

      const topLevelParents = Object.keys(relations)
        .filter(parent => !allChildren.has(parent) && relations[parent]?.length > 0);

      // 初始化或修复 group order（只对顶层生效）
      if (!Array.isArray(drivenGroupOrder) || drivenGroupOrder.length === 0) {
        drivenGroupOrder = [...topLevelParents];
      } else {
        const set = new Set(topLevelParents);
        const next = drivenGroupOrder.filter(id => set.has(id));
        topLevelParents.forEach((id) => {
          if (!next.includes(id)) next.push(id);
        });
        drivenGroupOrder = next;
      }

      if (topLevelParents.length === 0) {
        container.innerHTML = '<div class="fold-layer-empty">暂无带动关系</div>';
        return;
      }

      let html = '';
      drivenGroupOrder.forEach(parentId => {
        html += renderGroupTree(parentId, relations, 0);
      });

      container.innerHTML = html;
    }

    // 递归渲染组树
    function renderGroupTree(parentId, relations, depth) {
      const children = relations[parentId] || [];
      if (children.length === 0 && depth > 0) return '';

      const isExpanded = groupExpandState[parentId] !== false;
      const indent = depth * 12;

      const isTopLevel = depth === 0;
      const dragAttrs = isTopLevel
        ? `draggable="true"
             ondragstart="onDrivenGroupDragStart(event, '${parentId}')"
             ondragover="onDrivenGroupDragOver(event)"
             ondrop="onDrivenGroupDrop(event, '${parentId}')"
             ondragend="onDrivenGroupDragEnd(event)"`
        : '';

      let html = `<div class="driven-group" data-group="${parentId}" style="margin-left: ${indent}px;">
        <div class="driven-group-header" ${dragAttrs} onclick="selectAsParent('${parentId}')" style="${depth > 0 ? 'padding: 4px 6px;' : ''}">
          <button class="driven-group-arrow ${children.length > 0 && isExpanded ? 'expanded' : ''}" onclick="onDrivenGroupArrowClick(event, '${parentId}')">${children.length > 0 ? '›' : ' '}</button>
          <span class="driven-group-icon">${children.length > 0 ? '📁' : '📄'}</span>
          <span class="driven-group-name" style="${depth > 0 ? 'font-size: 10px;' : ''}">${parentId}</span>
          ${children.length > 0 ? `<span class="driven-group-count">${children.length}</span>` : ''}
          ${depth === 0 ? `<button onclick="event.stopPropagation(); removeGroup('${parentId}')" class="driven-group-delete">×</button>` : ''}
        </div>`;

      if (isExpanded && children.length > 0) {
        html += `<div class="driven-group-content"><div class="driven-group-content-glass">`;
        children.forEach((child, idx) => {
          const grandChildren = relations[child] || [];

          if (grandChildren.length > 0) {
            // 子面板也有子面板，递归渲染
            html += renderGroupTree(child, relations, depth + 1);
          } else {
            // 叶子节点
            html += `<div class="driven-child-item" draggable="true"
                         data-parent="${parentId}" data-child="${child}"
                         style="margin-left: ${(depth + 1) * 12}px;"
                         ondragstart="onChildDragStart(event, '${parentId}', '${child}')"
                         ondragover="onChildDragOver(event)"
                         ondragleave="onChildDragLeave(event)"
                         ondrop="onChildDrop(event, '${parentId}', ${idx})"
                         onclick="event.stopPropagation(); selectAsParent('${child}')">
              <span class="driven-child-indent">└─</span>
              <span class="driven-child-name">${child}</span>
              <button onclick="event.stopPropagation(); removeChildFromGroup('${parentId}', '${child}')" class="driven-child-delete">×</button>
            </div>`;
          }
        });
        html += `</div></div>`;
      }
      html += `</div>`;
      return html;
    }

    // 点击子面板，将其设为父面板（方便继续添加子面板）
    function selectAsParent(panelName) {
      setDrivenDropdownValue('parent', panelName);
      setStatus(`已选择 ${panelName} 为父面板`, 'success');
    }

    // 点击组头，同时设置父面板和切换展开状态
    function selectAsParentAndToggle(panelName) {
      selectAsParent(panelName);
      toggleDrivenGroupExpand(panelName);
    }

    // 切换组展开/折叠
    function toggleDrivenGroupExpand(parentId) {
      groupExpandState[parentId] = groupExpandState[parentId] === false ? true : false;
      updateDrivenGroupList();
    }

    function stopEvent(event) {
      if (!event) return;
      event.preventDefault();
      event.stopPropagation();
    }

    function stopPropagationOnly(event) {
      if (!event) return;
      event.stopPropagation();
    }

    function onDrivenGroupArrowClick(event, parentId) {
      stopEvent(event);
      toggleDrivenGroupExpand(parentId);
    }

    function onDrivenGroupDragStart(event, parentId) {
      stopPropagationOnly(event);
      draggedDrivenGroupId = parentId;
      try {
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', parentId);
      } catch (e) {}
      if (event.currentTarget) {
        event.currentTarget.classList.add('dragging');
      }
    }

    function onDrivenGroupDragEnd(event) {
      stopPropagationOnly(event);
      draggedDrivenGroupId = null;
      const headers = document.querySelectorAll('.driven-group-header.dragging, .driven-group-header.drag-over');
      for (let i = 0; i < headers.length; i++) {
        headers[i].classList.remove('dragging');
        headers[i].classList.remove('drag-over');
      }
    }

    function onDrivenGroupDragOver(event) {
      event.preventDefault();
      event.stopPropagation();
      if (event.currentTarget) {
        event.currentTarget.classList.add('drag-over');
      }
    }

    function onDrivenGroupDrop(event, targetParentId) {
      event.preventDefault();
      event.stopPropagation();
      if (event.currentTarget) {
        event.currentTarget.classList.remove('drag-over');
        event.currentTarget.classList.remove('dragging');
      }

      const fromId = draggedDrivenGroupId;
      draggedDrivenGroupId = null;
      if (!fromId || fromId === targetParentId) return;

      const fromIdx = drivenGroupOrder.indexOf(fromId);
      const toIdx = drivenGroupOrder.indexOf(targetParentId);
      if (fromIdx === -1 || toIdx === -1) return;

      const next = [...drivenGroupOrder];
      next.splice(fromIdx, 1);
      next.splice(toIdx, 0, fromId);
      drivenGroupOrder = next;

      updateDrivenGroupList();
      scheduleSaveDrivenRelations();
    }

    // 删除整个组
    function removeGroup(parentId) {
      if (Object.keys(manualDrivenRelations).length === 0) {
        manualDrivenRelations = JSON.parse(JSON.stringify(drivenRelations));
      }
      delete manualDrivenRelations[parentId];
      drivenGroupOrder = drivenGroupOrder.filter(id => id !== parentId);
      updateDrivenGroupList();
      scheduleSaveDrivenRelations();
    }

    // 从组中移除子面板
    function removeChildFromGroup(parentId, childId) {
      if (Object.keys(manualDrivenRelations).length === 0) {
        manualDrivenRelations = JSON.parse(JSON.stringify(drivenRelations));
      }
      if (manualDrivenRelations[parentId]) {
        manualDrivenRelations[parentId] = manualDrivenRelations[parentId].filter(c => c !== childId);
        if (manualDrivenRelations[parentId].length === 0) {
          delete manualDrivenRelations[parentId];
        }
      }
      updateDrivenGroupList();
      scheduleSaveDrivenRelations();
    }

    // 子面板拖拽排序
    let draggedChild = null;
    let draggedFromParent = null;

    function onChildDragStart(e, parentId, childId) {
      draggedChild = childId;
      draggedFromParent = parentId;
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function onChildDragOver(e) {
      e.preventDefault();
      e.currentTarget.classList.add('drag-over');
    }

    function onChildDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function onChildDrop(e, targetParent, targetIdx) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      if (!draggedChild) return;

      if (Object.keys(manualDrivenRelations).length === 0) {
        manualDrivenRelations = JSON.parse(JSON.stringify(drivenRelations));
      }

      // 从原组移除
      if (manualDrivenRelations[draggedFromParent]) {
        manualDrivenRelations[draggedFromParent] = manualDrivenRelations[draggedFromParent].filter(c => c !== draggedChild);
      }

      // 添加到目标位置
      if (!manualDrivenRelations[targetParent]) {
        manualDrivenRelations[targetParent] = [];
      }
      manualDrivenRelations[targetParent].splice(targetIdx, 0, draggedChild);

      draggedChild = null;
      draggedFromParent = null;
      updateDrivenGroupList();
      scheduleSaveDrivenRelations();
    }

    // 确认带动关系设置（支持多选）
    function confirmDrivenRelation() {
      const parentSelect = document.getElementById('drivenParentSelect');
      const parentId = parentSelect?.value;
      const selectedChildren = getSelectedChildren();

      if (!parentId) {
        setStatus('请选择父面板', 'error');
        return;
      }
      if (selectedChildren.length === 0) {
        setStatus('请至少选择一个子面板', 'error');
        return;
      }
      if (selectedChildren.includes(parentId)) {
        setStatus('子面板不能包含父面板自身', 'error');
        return;
      }

      // 初始化手动关系
      if (Object.keys(manualDrivenRelations).length === 0 && rootPanelId) {
        buildDrivenTree();
        manualDrivenRelations = JSON.parse(JSON.stringify(drivenRelations));
      }

      // 从其他父节点移除这些子节点
      selectedChildren.forEach(childId => {
        for (const pid in manualDrivenRelations) {
          manualDrivenRelations[pid] = manualDrivenRelations[pid].filter(c => c !== childId);
        }
      });

      // 添加到新的父节点
      if (!manualDrivenRelations[parentId]) {
        manualDrivenRelations[parentId] = [];
      }
      selectedChildren.forEach(childId => {
        if (!manualDrivenRelations[parentId].includes(childId)) {
          manualDrivenRelations[parentId].push(childId);
        }
      });

      // 重置选择
      parentSelect.value = '';
      selectedChildPanels = [];

      // 更新显示
      updateFoldTabContent();
      setStatus(`已设置: ${parentId} → ${selectedChildren.join(', ')}`, 'success');
      scheduleSaveDrivenRelations();
    }

    // 保留旧函数兼容性
    function addManualDrivenRelation() {
      confirmDrivenRelation();
    }

    // 删除带动关系
    function removeDrivenRelation(parentId, childId) {
      if (manualDrivenRelations[parentId]) {
        manualDrivenRelations[parentId] = manualDrivenRelations[parentId].filter(c => c !== childId);
      }
      updateFoldTabContent();
      scheduleSaveDrivenRelations();
    }

    // 重置为自动检测
    function resetToAutoDetect() {
      manualDrivenRelations = {};
      drivenGroupOrder = [];
      updateFoldTabContent();
      setStatus('已重置为自动检测', 'success');
      scheduleSaveDrivenRelations();
    }

    // ============================================
    // Vector 点选排序逻辑
    // ============================================

    // 计算下一个最小可用序号
    function getNextAvailableNumber() {
      const usedNumbers = Object.values(vectorOrderMap);
      let num = 1;
      while (usedNumbers.includes(num)) {
        num++;
      }
      return num;
    }

    // 点击 vector 卡片切换选中状态
    function toggleVectorSelection(vectorId) {
      if (vectorOrderMap[vectorId] !== undefined) {
        // 已选中 -> 取消选中
        delete vectorOrderMap[vectorId];
      } else {
        // 未选中 -> 分配下一个最小序号
        vectorOrderMap[vectorId] = getNextAvailableNumber();

        // 自动设置为父面板
        const vector = allVectors.find(v => v.id === vectorId);
        if (vector) {
          const panelName = getPanelDisplayName(vector.id, vector.name);
          const parentSelect = document.getElementById('drivenParentSelect');
          if (parentSelect) {
            parentSelect.value = panelName;
          }
        }
      }
      updateVectorGridUI();
      updateOrderPreview();
      updateSelectedVectors();
    }

    // 更新 selectedVectors 数组（按顺序）并保存到 Figma
    function updateSelectedVectors() {
      const ordered = Object.entries(vectorOrderMap)
        .sort((a, b) => a[1] - b[1])
        .map(([id]) => id);
      selectedVectors = ordered;

      // 自动保存到 Figma pluginData
      if (sourceFrameId) {
        parent.postMessage({
          pluginMessage: {
            type: 'saveSelectedVectors',
            frameId: sourceFrameId,
            vectorIds: ordered
          }
        }, '*');
      }
    }

    // Gray Value
    function updateGrayValue(value) {
      document.getElementById('grayValueDisplay').textContent = value;
    }

    // Craft Marking
    function markCraftWithGray(craftType) {
      const grayValue = parseInt(document.getElementById('graySlider').value);
      const sameColor = document.getElementById('markSameColor').checked;
      const inClipMask = document.getElementById('markInClipMask').checked;

      // 🔥 切换到对应的工艺面板和缩略图
      const craftTypeMap = {
        '烫金': 'hot-stamping-gold',
        '烫银': 'hot-stamping-silver',
        'UV': 'uv',
        '凹凸': 'emboss',
        '压纹': 'deboss',
        '法线': 'normal',
        '置换': 'displacement'
      };
      const mappedCraftType = craftTypeMap[craftType];
      if (mappedCraftType) {
        // 切换到对应的缩略图
        const thumbnails = document.querySelectorAll('.craft-thumbnail');
        thumbnails.forEach(thumb => {
          if (thumb.dataset.craft === mappedCraftType) {
            thumb.click(); // 触发缩略图点击事件
          }
        });
      }

      setStatus('Marking as ' + craftType + '...', '');

      // 如果勾选了批量标记相同颜色，先选中再标记
      if (sameColor) {
        parent.postMessage({
          pluginMessage: {
            type: 'selectAndMarkByColor',
            craftType: craftType,
            grayValue: grayValue,
            inClipMask: inClipMask
          }
        }, '*');
        return;
      }

      // 原有的单独标记逻辑
      if (selectedLayerId) {
        parent.postMessage({ pluginMessage: { type: 'markCraftWithGrayById', nodeId: selectedLayerId, craftType, grayValue } }, '*');
        return;
      }
      parent.postMessage({ pluginMessage: { type: 'markCraftWithGray', craftType, grayValue } }, '*');
    }

    function selectByColor() {
      const inClipMask = document.getElementById('markInClipMask').checked;
      setStatus('Selecting same color...', '');
      parent.postMessage({ pluginMessage: { type: 'selectByColor', inClipMask: inClipMask } }, '*');
    }

    function removeMark(nodeId) {
      parent.postMessage({ pluginMessage: { type: 'removeMarkById', nodeId } }, '*');
    }

    function clearAllMarks() {
      if (confirm('Clear all craft marks?')) {
        parent.postMessage({ pluginMessage: { type: 'clearAllMarks' } }, '*');
      }
    }

    function regenerateAllIndicators() {
      parent.postMessage({ pluginMessage: { type: 'regenerateAllIndicators' } }, '*');
    }

    // 渲染空间布局 UI（刀版图影分身）
    function updateVectorGridUI() {
      const canvas = document.getElementById('spatialCanvas');
      const viewport = document.getElementById('spatialViewport');
      if (!canvas || !viewport || allVectors.length === 0) return;

      // 计算边界框
      const bounds = calculateBounds(allVectors);
      if (bounds.width === 0 || bounds.height === 0) return;

      // 获取画布尺寸，如果为0则使用默认值
      let canvasW = canvas.clientWidth || 400;
      let canvasH = canvas.clientHeight || 300;

      // 计算缩放比例，留出边距
      const padding = 16;
      const availW = canvasW - padding * 2;
      const availH = canvasH - padding * 2;
      const scale = Math.min(availW / bounds.width, availH / bounds.height);

      // 设置 viewport 尺寸和位置
      const scaledW = bounds.width * scale;
      const scaledH = bounds.height * scale;
      viewport.style.width = scaledW + 'px';
      viewport.style.height = scaledH + 'px';
      applyCanvasTransform();

      // 渲染 vectors
      const nextNum = getNextAvailableNumber();
      let html = '';

      allVectors.forEach(v => {
        const isSelected = vectorOrderMap[v.id] !== undefined;
        const orderNum = vectorOrderMap[v.id];

        // 相对位置和尺寸
        const left = (v.x - bounds.minX) * scale;
        const top = (v.y - bounds.minY) * scale;
        const width = Math.max(v.width * scale, 20);
        const height = Math.max(v.height * scale, 20);

        const displayName = getPanelDisplayName(v.id, v.name);
        const isHPanel = hPanelId === v.id;

        // 生成 SVG 预览内容（如果有）
        let svgContent = '';
        if (v.svgPreview) {
          // 将 SVG 字符串转换为 data URL
          const svgDataUrl = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(v.svgPreview)));
          svgContent = `<div class="vector-svg-preview" style="background-image: url('${svgDataUrl}');"></div>`;
        }

        html += `<div class="vector-card ${isSelected ? 'selected' : ''} ${rootPanelId === v.name ? 'root-panel' : ''} ${isHPanel ? 'h-panel' : ''}"
             style="left:${left}px;top:${top}px;width:${width}px;height:${height}px;"
             onclick="toggleVectorSelection('${v.id}')"
             ondblclick="setHPanel('${v.id}')"
             oncontextmenu="setRootPanel('${v.name}'); return false;"
             title="单击选择 | 双击设为H面 | 右键设为Root">
          ${svgContent}
          ${isHPanel ? '<div class="h-badge">H</div>' : ''}
          ${rootPanelId === v.name && !isHPanel ? '<div class="root-badge">R</div>' : ''}
          ${isSelected ? `<div class="vector-order-badge">${orderNum}</div>` : `<div class="vector-ghost-badge">${nextNum}</div>`}
          <span class="vector-card-name">${displayName}</span>
        </div>`;
      });

      viewport.innerHTML = html;

      // 如果在折叠边模式，渲染所有可能的 ghost 边
      if (foldEdgeMode) {
        renderAllGhostEdges(bounds, scale);
      }

      // 检测并渲染折叠边
      detectFoldEdges();
    }

    // 渲染所有可能的 ghost 折叠边（尚未创建的接缝）
    function renderAllGhostEdges(bounds, scale) {
      // 保存用于鼠标检测
      cachedBounds = bounds;
      cachedScale = scale;
      // 不再预渲染所有 ghost，改为鼠标移动时动态检测
    }

    // 检测鼠标位置是否在接缝附近
    function detectSeamAtPosition(mouseX, mouseY) {
      if (!cachedBounds || !foldEdgeMode) return null;

      const tolerance = 15; // 接缝检测范围（像素）

      for (let i = 0; i < allVectors.length; i++) {
        for (let j = i + 1; j < allVectors.length; j++) {
          const v1 = allVectors[i];
          const v2 = allVectors[j];

          // 检查是否已存在折叠边
          const exists = foldEdges.find(e =>
            (e.panel1 === v1.name && e.panel2 === v2.name) ||
            (e.panel1 === v2.name && e.panel2 === v1.name)
          );
          if (exists) continue;

          // 计算接缝位置（两个面板中心连线的中点）
          const c1x = (v1.x + v1.width / 2 - cachedBounds.minX) * cachedScale;
          const c1y = (v1.y + v1.height / 2 - cachedBounds.minY) * cachedScale;
          const c2x = (v2.x + v2.width / 2 - cachedBounds.minX) * cachedScale;
          const c2y = (v2.y + v2.height / 2 - cachedBounds.minY) * cachedScale;

          const midX = (c1x + c2x) / 2;
          const midY = (c1y + c2y) / 2;

          // 检测鼠标是否在接缝中点附近
          const dist = Math.sqrt((mouseX - midX) ** 2 + (mouseY - midY) ** 2);
          if (dist < tolerance) {
            return { v1, v2, c1x, c1y, c2x, c2y };
          }
        }
      }
      return null;
    }

    // 渲染单个 ghost 边（不影响已有折叠边）
    function renderGhostEdge(seam) {
      const viewport = document.getElementById('spatialViewport');
      if (!viewport) return;

      // 只移除 ghost 边，不影响 .fold-edge
      const oldGhost = viewport.querySelector('.fold-edge-ghost');
      if (oldGhost) oldGhost.remove();

      if (!seam) return;

      const div = document.createElement('div');
      div.className = 'fold-edge-ghost';

      const dx = seam.c2x - seam.c1x;
      const dy = seam.c2y - seam.c1y;
      const length = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;

      div.style.left = seam.c1x + 'px';
      div.style.top = seam.c1y + 'px';
      div.style.width = length + 'px';
      div.style.height = '0';
      div.style.transformOrigin = '0 50%';
      div.style.transform = `rotate(${angle}deg)`;

      div.onclick = (e) => {
        e.stopPropagation();
        createEdgeFromGhost(seam.v1.name, seam.v2.name, seam.v1.id, seam.v2.id);
      };

      viewport.appendChild(div);
    }

    // 处理画布鼠标移动
    function handleCanvasMouseMove(e) {
      if (!foldEdgeMode) return;

      const canvas = document.getElementById('spatialCanvas');
      const viewport = document.getElementById('spatialViewport');
      if (!canvas || !viewport) return;

      const rect = viewport.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const seam = detectSeamAtPosition(mouseX, mouseY);
      if (seam !== currentGhostEdge) {
        currentGhostEdge = seam;
        renderGhostEdge(seam);
      }
    }

    // 计算所有 vectors 的边界框
    function calculateBounds(vectors) {
      let minX = Infinity, minY = Infinity;
      let maxX = -Infinity, maxY = -Infinity;

      vectors.forEach(v => {
        minX = Math.min(minX, v.x);
        minY = Math.min(minY, v.y);
        maxX = Math.max(maxX, v.x + v.width);
        maxY = Math.max(maxY, v.y + v.height);
      });

      return {
        minX, minY, maxX, maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    }

    // 更新排序预览条
    function updateOrderPreview() {
      const container = document.getElementById('orderItems');
      const ordered = Object.entries(vectorOrderMap)
        .sort((a, b) => a[1] - b[1]);

      if (ordered.length === 0) {
        container.innerHTML = '<span style="color: var(--color-neutral-600); font-size: 10px;">未选择</span>';
        return;
      }

      let html = '';
      ordered.forEach(([id, num], i) => {
        const v = allVectors.find(x => x.id === id);
        const name = getPanelDisplayName(id, v ? v.name : id);
        html += `<span class="order-preview-item">
          <span class="order-preview-num">${num}</span>
          <span>${name}</span>
        </span>`;
        if (i < ordered.length - 1) {
          html += '<span class="order-preview-arrow">→</span>';
        }
      });
      container.innerHTML = html;
    }

    // 显示/隐藏预览区域
    function showVectorPreview(show) {
      const emptyState = document.getElementById('emptyState');
      const vectorPreview = document.getElementById('vectorPreview');

      if (emptyState) emptyState.style.display = show ? 'none' : 'flex';
      if (vectorPreview) vectorPreview.style.display = show ? 'flex' : 'none';

      // 延迟渲染，等待 DOM 更新
      if (show) {
        setTimeout(() => {
          updateVectorGridUI();
        }, 50);
      }
    }

    function refreshMarkedLayers() {
      parent.postMessage({ pluginMessage: { type: 'getMarkedLayers' } }, '*');
    }

    // Vector Functions
    function refreshVectors() {
      setStatus('Scanning vectors...', '');
      parent.postMessage({ pluginMessage: { type: 'getVectors' } }, '*');
    }

    // 添加 Figma 中选中的 vectors 到当前 Frame
    function addSelectedVectors() {
      setStatus('Adding selected vectors...', '');
      parent.postMessage({ pluginMessage: { type: 'addVectors' } }, '*');
    }

    // 清除所有已保存的 vectors
    function clearAllVectors() {
      setStatus('Clearing vectors...', '');
      parent.postMessage({ pluginMessage: { type: 'clearSavedVectors' } }, '*');
    }

    // Export
    function doUnifiedExport() {
      if (!sourceFrameId) {
        setStatus('Please select a Frame first', 'error');
        return;
      }
      const btn = document.getElementById('exportBtn');
      btn.disabled = true;
      setStatus('Exporting...', '');

      // 收集法线设置
      const normalSettings = {
        global: { ...normalMapSettings },
        layerSettings: { ...layerNormalSettings },
        mode: normalSettingsMode
      };

      // 收集所有工艺设置
      const craftSettings = {
        version: '1.0.0',
        normal: normalSettings,
        emboss: { ...embossSettings },
        metal: { ...metalSettings },
        uv: { ...uvSettings }
      };

      parent.postMessage({
        pluginMessage: {
          type: 'exportUnified',
          payload: {
            frameId: sourceFrameId,
            vectorIds: selectedVectors,
            scale: 2,
            format: 'PNG',
            exportCraftVector: craftVectorEnabled,
            normalSettings: normalSettings,
            craftSettings: craftSettings
          }
        }
      }, '*');
    }

    // Status
    function setStatus(text, className) {
      const status = document.getElementById('status');
      const indicator = document.getElementById('statusIndicator');
      if (status) {
        status.textContent = text;
        status.className = className;
      }
      if (indicator) {
        indicator.className = 'status-indicator ' + className;
      }
    }

    // Craft class helper
    function getCraftClass(craftType) {
      const map = { '烫金': 'gold', '烫银': 'silver', 'UV': 'uv', '凹凸': 'emboss', '法线': 'normal', '置换': 'displacement' };
      return map[craftType] || '';
    }

    // Update marked layers UI - 按工艺类型分组显示
    function updateMarkedLayersUI(layers) {
      console.log(`🎨 updateMarkedLayersUI called with ${layers.length} layers:`, layers);
      markedLayers = layers;
      const container = document.getElementById('markedLayers');
      const section = document.getElementById('markedSection');

      if (layers.length === 0) {
        console.log('✨ No marked layers, hiding panel');
        section.style.display = 'none';
        // 🔧 同时隐藏右侧缩略图面板
        const thumbnails = document.getElementById('craftThumbnails');
        if (thumbnails) {
          thumbnails.style.display = 'none';
          console.log('✨ Also hiding craft thumbnails panel');
        }
        return;
      }

      console.log(`📊 Showing panel with ${layers.length} marked layers`);
      section.style.display = 'block';

      // 按工艺类型分组
      const craftGroups = {};
      layers.forEach(layer => {
        const crafts = layer.crafts || [layer.craftType];
        // 使用第一个工艺类型作为分组依据
        const primaryCraft = crafts[0];
        if (!craftGroups[primaryCraft]) {
          craftGroups[primaryCraft] = [];
        }
        craftGroups[primaryCraft].push(layer);
      });

      let html = '';

      // 按工艺类型渲染分组
      Object.keys(craftGroups).forEach(craftType => {
        const groupLayers = craftGroups[craftType];
        const cls = getCraftClass(craftType);

        html += `<div class="craft-group" id="craft-group-${cls}">
          <div class="craft-group-header ${cls}" onclick="toggleCraftGroup('${cls}')">
            <div class="craft-group-header-left">
              <span class="craft-group-arrow">▼</span>
              <span class="craft-group-title">${craftType}</span>
            </div>
            <span class="craft-group-count">${groupLayers.length}</span>
          </div>
          <div class="craft-group-items">`;

        groupLayers.forEach(layer => {
          const crafts = layer.crafts || [layer.craftType];
          const isMulti = crafts.length > 1;

          let tagsHtml = '';
          let expandHtml = '';

          if (isMulti) {
            // 小圆点标记（类似微信未读消息）
            const dotsHtml = crafts.map(c =>
              `<span class="craft-mini-dot ${getCraftClass(c)}"></span>`
            ).join('');
            tagsHtml = `<span class="multi-badge">${crafts.length}</span>`;

            // 展开的工艺列表
            expandHtml = `<div class="craft-expand-panel" id="expand-${layer.id}" style="display:none;">`;
            crafts.forEach(c => {
              const cls = getCraftClass(c);
              expandHtml += `
                <div class="craft-expand-item">
                  <span class="craft-expand-dot ${cls}"></span>
                  <span class="craft-expand-name">${c}</span>
                  <button class="craft-expand-delete" onclick="event.stopPropagation();removeSingleCraft('${layer.id}','${c}')">×</button>
                </div>`;
            });
            expandHtml += `</div>`;
          }

          html += `
            <div class="marked-item ${isMulti ? 'has-expand' : ''}" onclick="selectLayer('${layer.id}')">
              <span class="marked-item-name">${layer.name}${tagsHtml}</span>
              ${isMulti ? `<span class="expand-arrow" id="arrow-${layer.id}" onclick="event.stopPropagation();toggleCraftExpand('${layer.id}')"><svg width="10" height="10" viewBox="0 0 10 10"><path d="M2.5 4L5 6.5L7.5 4" stroke="currentColor" stroke-width="1.5" fill="none" stroke-linecap="round"/></svg></span>` : ''}
              <button class="delete-btn" onclick="event.stopPropagation();removeMark('${layer.id}')">×</button>
            </div>
            ${expandHtml}
          `;
        });

        html += `</div></div>`;
      });

      container.innerHTML = html;

      // 同步更新法线图层选择器
      updateNormalLayerSelect();

      // ❌ 不要在这里更新缩略图！缩略图应该由 craftLayerSelected 消息更新
      // 动态更新工艺缩略图 - 只显示当前选中vector的工艺类型
      // 注意：页面加载时不自动显示缩略图，只有用户点击选择时才显示
      // updateCraftThumbnailsForSelection(layers, false);
    }

    // 动态更新工艺缩略图 - 根据选中vector的工艺类型
    function updateCraftThumbnailsForSelection(layers, autoShow = true) {
      const grid = document.getElementById('craftThumbnailsGrid');
      const container = document.getElementById('craftThumbnails');
      if (!grid || !container) return;

      // 如果没有选中的图层，隐藏缩略图面板
      if (!layers || layers.length === 0) {
        container.style.display = 'none';
        return;
      }

      // 收集所有选中图层的工艺类型
      const craftTypesSet = new Set();
      layers.forEach(layer => {
        if (layer.crafts && Array.isArray(layer.crafts)) {
          layer.crafts.forEach(craft => {
            // 将中文工艺名称映射到英文类型
            const craftMap = {
              '烫金': 'hot-stamping-gold',
              '烫银': 'hot-stamping-silver',
              'UV': 'uv',
              '凹凸': 'emboss',
              '法线': 'normal',
              '置换': 'displacement'
            };
            const craftType = craftMap[craft];
            if (craftType) {
              craftTypesSet.add(craftType);
            }
          });
        }
      });

      const craftTypes = Array.from(craftTypesSet);

      // 如果没有工艺类型，隐藏缩略图面板
      if (craftTypes.length === 0) {
        container.style.display = 'none';
        return;
      }

      // 工艺类型到标签的映射
      const craftLabels = {
        'hot-stamping-gold': '烫金',
        'hot-stamping-silver': '烫银',
        'uv': 'UV',
        'emboss': '凹凸',
        'normal': '法线',
        'displacement': '置换'
      };

      // 生成缩略图 HTML
      let html = '';
      craftTypes.forEach(craftType => {
        const label = craftLabels[craftType] || craftType;
        html += `
          <div class="craft-thumbnail-card" data-craft-type="${craftType}" onclick="selectCraftThumbnail('${craftType}')">
            <div class="craft-thumbnail-preview">
              <canvas class="craft-thumbnail-canvas" data-craft-type="${craftType}" width="50" height="50"></canvas>
            </div>
            <div class="craft-thumbnail-label">${label}</div>
          </div>
        `;
      });

      grid.innerHTML = html;

      // 始终显示缩略图面板（如果有工艺类型）
      container.style.display = 'block';

      // 渲染缩略图预览
      updateAllCraftThumbnails();
    }

    function selectLayer(id) {
      selectedLayerId = id;

      // 更新隐藏的图层选择器（用于参数存储）
      const layerSelect = document.getElementById('normalLayerSelect');
      if (layerSelect) layerSelect.value = id;

      // 加载该图层的独立参数
      loadCurrentLayerSettings();

      parent.postMessage({ pluginMessage: { type: 'selectNode', nodeId: id } }, '*');

      // 同步更新工艺按钮和缩略图
      const layer = markedLayers.find(l => l.id === id);
      if (layer) {
        // 调用 updateCraftTypeButtons 会自动更新缩略图
        updateCraftTypeButtons(id);
      }
    }

    // 展开/收起多层工艺面板
    function toggleCraftExpand(layerId) {
      const panel = document.getElementById('expand-' + layerId);
      const arrow = document.getElementById('arrow-' + layerId);
      if (panel) {
        const isHidden = panel.style.display === 'none';
        panel.style.display = isHidden ? 'block' : 'none';
        if (arrow) {
          arrow.classList.toggle('expanded', isHidden);
        }
      }
    }

    // 折叠/展开工艺分组
    function toggleCraftGroup(cls) {
      const group = document.getElementById('craft-group-' + cls);
      if (group) {
        group.classList.toggle('collapsed');
      }
    }

    // 删除单个工艺
    function removeSingleCraft(layerId, craftType) {
      console.log(`🗑️ UI: Removing craft ${craftType} from layer ${layerId}`);
      parent.postMessage({
        pluginMessage: {
          type: 'removeSingleCraft',
          nodeId: layerId,
          craftType: craftType
        }
      }, '*');
    }

    // ============================================================================
    // 存储管理器 - 替代 localStorage
    // ============================================================================

    console.log('✅ 存储管理器已加载 - localStorage 已被替换');

    const storageCallbacks = {};

    function requestSettings(key, callback) {
      console.log('📤 请求设置:', key);
      storageCallbacks[key] = callback;
      parent.postMessage({
        pluginMessage: {
          type: 'request-settings',
          key: key
        }
      }, '*');
    }

    function saveSettings(key, data) {
      console.log('💾 保存设置:', key);
      parent.postMessage({
        pluginMessage: {
          type: 'save-settings',
          key: key,
          data: data
        }
      }, '*');
    }

    function handleStorageResponse(key, data) {
      console.log('📥 收到设置响应:', key, data);
      if (storageCallbacks[key]) {
        storageCallbacks[key](data);
        delete storageCallbacks[key];
      }
    }

    // Download JSON
    function downloadJSON(data) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = (data.name || 'export').replace(/[^a-zA-Z0-9]/g, '_') + '.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    function downloadDataUrl(dataUrl, filename) {
      const a = document.createElement('a');
      a.href = dataUrl;
      a.download = filename;
      a.click();
    }

    // Message Handler
    window.onmessage = (e) => {
      const msg = e.data.pluginMessage;
      const exportBtn = document.getElementById('exportBtn');
      if (exportBtn) exportBtn.disabled = false;

      if (!msg) return;

      switch (msg.type) {
        case 'vectorsFound':
          allVectors = msg.vectors;
          sourceFrameId = msg.frameId;
          // 重置排序状态
          vectorOrderMap = {};
          // 更新预览 UI
          if (allVectors.length > 0) {
            showVectorPreview(true);
            updateVectorGridUI();
            updateOrderPreview();
          }
          setStatus('Found ' + msg.vectors.length + ' vectors', 'success');
          break;

        case 'result':
          // downloadJSON(msg.data); // Moved to processAndDownloadJSON
          processAndDownloadJSON(msg.data).then(() => {
              const clips = msg.data.clips?.length || 0;
              const masks = msg.data.masks?.length || 0;
              setStatus('Exported: ' + clips + ' clips, ' + masks + ' masks', 'success');
          });
          break;

        case 'normalPreviewData':
          // 接收高度图预览数据 (PNG 格式)
          if (msg.imageData && msg.isPNG) {
            decodePNGAndShowPreview(new Uint8Array(msg.imageData), msg.isImageNode || false);
          }
          break;

        case 'error':
          setStatus('Error: ' + msg.data, 'error');
          break;

        case 'success':
          setStatus(msg.data, 'success');
          refreshMarkedLayers();
          break;

        case 'markedLayers':
          updateMarkedLayersUI(msg.layers);
          if (msg.frameId) sourceFrameId = msg.frameId;
          break;

        case 'craftLayerSelected':
          // 用户在Figma画布点击选择了带有工艺标记的vector
          // 自动显示缩略图面板
          console.log('📥 Received craftLayerSelected with', msg.layers.length, 'layers:', msg.layers);
          updateCraftThumbnailsForSelection(msg.layers, true);
          break;

        case 'savedVectors':
          console.log('📦 Received savedVectors message:', msg);
          // 切换 Frame 时完全重置状态
          const newFrameId = msg.frameId;
          const hasData = msg.vectors && msg.vectors.length > 0;
          console.log('📊 hasData:', hasData, 'vectors count:', msg.vectors?.length);

          // 如果切换到不同的 Frame，重置所有状态
          if (newFrameId !== sourceFrameId) {
            // 重置所有状态
            vectorOrderMap = {};
            panelNameMap = {};
            foldEdges = [];
            foldEdgeOrderMap = {};
            deletedEdgeIds = [];
            hPanelId = null;
            rootPanelId = null;
          }

          sourceFrameId = newFrameId;

          if (hasData) {
            allVectors = msg.vectors;
            // 加载带动关系
            if (msg.drivenRelations && Object.keys(msg.drivenRelations).length > 0) {
              const payload = msg.drivenRelations;
              if (payload && payload.relations && typeof payload.relations === 'object') {
                manualDrivenRelations = JSON.parse(JSON.stringify(payload.relations));
                drivenGroupOrder = Array.isArray(payload.order) ? [...payload.order] : [];
              } else {
                manualDrivenRelations = JSON.parse(JSON.stringify(payload));
                drivenGroupOrder = [];
              }
            } else {
              manualDrivenRelations = {};
              drivenGroupOrder = [];
            }
            // 恢复时默认全选，按原顺序
            vectorOrderMap = {};
            msg.vectors.forEach((v, i) => {
              vectorOrderMap[v.id] = i + 1;
            });
            updateSelectedVectors();
            // 显示预览
            showVectorPreview(true);
            updateVectorGridUI();
            updateOrderPreview();
            updateFoldTabContent();
            // 更新 UI 状态
            clipModeEnabled = true;
            document.getElementById('clipModeRow').classList.add('active');
            document.getElementById('clipModeSwitch').classList.add('active');
            setStatus('Frame: ' + (msg.vectors.length) + ' vectors', 'success');
          } else {
            // 没有数据时清空显示
            allVectors = [];
            vectorOrderMap = {};
            selectedVectors = [];
            manualDrivenRelations = {};
            drivenGroupOrder = [];
            showVectorPreview(false);
            updateVectorGridUI();
            updateOrderPreview();
            // 不再强制关闭 Clip Mode，允许用户手动控制
            console.log('⚠️ No saved vectors found, but keeping Clip Mode state');
          }
          break;

        case 'response-settings':
          // 接收存储数据
          handleStorageResponse(msg.key, msg.data);
          break;

        case 'save-settings-success':
          console.log('✅ 设置已保存:', msg.key);
          break;

        case 'save-settings-error':
          console.error('❌ 保存设置失败:', msg.key, msg.error);
          break;
      }
    };

    // Init
    refreshMarkedLayers();
    parent.postMessage({ pluginMessage: { type: 'getSavedVectors' } }, '*');

    // 默认显示法线面板，避免首次点击卡顿
    setTimeout(() => {
      const defaultPanel = document.getElementById('panelNormal');
      if (defaultPanel) {
        defaultPanel.style.display = 'block';
      }
      // 默认激活法线按钮
      const normalBtn = document.querySelector('[onclick*="normal"]');
      if (normalBtn) {
        normalBtn.classList.add('active');
      }
    }, 100);

    console.log('✅ Init complete, waiting for savedVectors message...');

    // 画布滚轮缩放
    document.getElementById('spatialCanvas')?.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      canvasZoom = Math.max(0.25, Math.min(4, canvasZoom * delta));
      applyCanvasTransform();
    }, { passive: false });

    // 画布鼠标拖拽平移
    document.getElementById('spatialCanvas')?.addEventListener('mousedown', (e) => {
      if (e.button === 1 || (e.button === 0 && e.altKey)) {
        isPanning = true;
        panStartX = e.clientX - canvasPanX;
        panStartY = e.clientY - canvasPanY;
        e.preventDefault();
        return;
      }

      if (e.button === 0 && isPointerOutsidePreviewBounds(e)) {
        isPanning = true;
        panStartX = e.clientX - canvasPanX;
        panStartY = e.clientY - canvasPanY;
        e.preventDefault();
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (isPanning) {
        canvasPanX = e.clientX - panStartX;
        canvasPanY = e.clientY - panStartY;
        applyCanvasTransform();
      }
    });

    document.addEventListener('mouseup', () => { isPanning = false; });

    // 页面加载时默认最小化折叠顺序预览栏
    window.addEventListener('DOMContentLoaded', () => {
      console.log('🚀 DOMContentLoaded fired!');

      const orderPreview = document.getElementById('orderPreview');
      if (orderPreview) {
        orderPreview.classList.add('minimized');
      }

      // 加载默认设置 - 包裹在 try-catch 中确保不会阻止后续代码
      try {
        loadDefaultSettings();
      } catch (e) {
        console.warn('⚠️ loadDefaultSettings failed:', e);
      }

      const drivenParentMenu = document.getElementById('drivenParentMenu');
      if (drivenParentMenu) {
        drivenParentMenu.addEventListener('click', (event) => {
          const target = event.target;
          const item = target instanceof Element ? target.closest('.driven-dropdown-item') : null;
          if (!item) return;
          stopEvent(event);
          const value = item.getAttribute('data-value') || '';
          setDrivenDropdownValue('parent', value);
          closeDrivenDropdowns();
        });
      }

      const drivenChildMenu = document.getElementById('drivenChildMenu');
      if (drivenChildMenu) {
        drivenChildMenu.addEventListener('click', (event) => {
          const target = event.target;
          const item = target instanceof Element ? target.closest('.driven-dropdown-item') : null;
          if (!item) return;
          stopEvent(event);
          const value = item.getAttribute('data-value') || '';
          setDrivenDropdownValue('child', value);
          closeDrivenDropdowns();
        });
      }

      document.addEventListener('click', (event) => {
        const t = event.target;
        const el = t instanceof Element ? t : null;
        if (!el) return;
        const inParent = el.closest('#drivenParentDropdown');
        const inChild = el.closest('#drivenChildDropdown');
        const inNormal = el.closest('#normalLayerDropdown');
        if (inParent || inChild || inNormal) return;
        closeDrivenDropdowns();
        closeNormalLayerDropdown();
      });

      // 选择工艺缩略图
      window.selectCraftThumbnail = function(craftType) {
        const allCards = document.querySelectorAll('.craft-thumbnail-card');
        allCards.forEach(card => card.classList.remove('active'));

        const selectedCard = document.querySelector(`[data-craft-type="${craftType}"]`);
        if (selectedCard) {
          selectedCard.classList.add('active');
        }

        switchCraftPanel(craftType);
        window.showCraftLargePreview(craftType);
      };

      // 初始化工艺预览缩略图
      function initCraftThumbnails() {
        // 生成6个工艺缩略图
        const grid = document.getElementById('craftThumbnailsGrid');
        if (!grid) return;

        const crafts = [
          { type: 'hot-stamping-gold', label: '烫金', icon: '🥇' },
          { type: 'hot-stamping-silver', label: '烫银', icon: '🥈' },
          { type: 'uv', label: 'UV', icon: '✨' },
          { type: 'emboss', label: '凹凸', icon: '🔺' },
          { type: 'normal', label: '法线', icon: '🗺️' },
          { type: 'displacement', label: '置换', icon: '🏔️' }
        ];

        let html = '';
        crafts.forEach(craft => {
          html += `
            <div class="craft-thumbnail-card" data-craft-type="${craft.type}" onclick="selectCraftThumbnail('${craft.type}')">
              <div class="craft-thumbnail-preview">
                <canvas class="craft-thumbnail-canvas" data-craft-type="${craft.type}" width="80" height="80"></canvas>
              </div>
              <div class="craft-thumbnail-label">${craft.label}</div>
            </div>
          `;
        });

        grid.innerHTML = html;
      }

      // 切换工艺参数面板
      function switchCraftPanel(craftType) {
        console.log('🔄 switchCraftPanel called with:', craftType);
        // 工艺类型到面板 ID 的映射
        const panelMap = {
          'hot-stamping-gold': 'panelHotfoilGold',
          'hot-stamping-silver': 'panelHotfoilSilver',
          'displacement': 'panelDisplacement',
          'uv': 'panelUV',
          'emboss': 'panelEmboss',
          'deboss': 'panelEmboss', // 凹凸和压纹使用同一个面板
          'normal': 'panelNormal' // 法线面板
        };

        // 工艺类型到预览画布 ID 的映射
        const previewMap = {
          'hot-stamping-gold': 'hotfoilGoldPreview',
          'hot-stamping-silver': 'hotfoilSilverPreview',
          'uv': 'normalPreview', // UV 使用法线预览
          'emboss': 'embossPreview',
          'deboss': 'embossPreview', // 凹凸和压纹使用同一个预览
          'normal': 'normalPreview', // 法线预览
          'displacement': 'normalPreview' // 置换使用法线预览
        };

        const targetPanelId = panelMap[craftType];
        const targetPreviewId = previewMap[craftType];

        if (!targetPanelId) {
          console.warn('Unknown craft type:', craftType);
          return;
        }

        // 隐藏所有工艺参数面板
        const allPanels = document.querySelectorAll('.craft-param-panel');
        allPanels.forEach(panel => {
          panel.style.display = 'none';
        });

        // 隐藏所有预览画布
        const allPreviews = [
          'normalPreview',
          'embossPreview',
          'metalPreview',
          'hotfoilGoldPreview',
          'hotfoilSilverPreview'
        ];
        allPreviews.forEach(previewId => {
          const preview = document.getElementById(previewId);
          if (preview) preview.style.display = 'none';
        });

        // 显示目标面板
        const targetPanel = document.getElementById(targetPanelId);
        if (targetPanel) {
          targetPanel.style.display = 'block';
          console.log('Switched to panel:', targetPanelId);
        }

        // 显示对应的预览画布
        const targetPreview = document.getElementById(targetPreviewId);
        if (targetPreview) {
          targetPreview.style.display = 'block';
          console.log('Switched to preview:', targetPreviewId);
        }

        // 更新工艺类型按钮的激活状态
        const typeMapping = {
          'hot-stamping-gold': 'hotfoil-gold',
          'hot-stamping-silver': 'hotfoil-silver',
          'normal': 'normal',
          'emboss': 'emboss',
          'uv': 'uv',
          'metal': 'metal',
          'displacement': 'displacement'
        };

        const mappedType = typeMapping[craftType] || craftType;
        const buttons = document.querySelectorAll('.craft-type-btn');
        buttons.forEach(btn => {
          const btnOnclick = btn.getAttribute('onclick');
          if (btnOnclick) {
            const match = btnOnclick.match(/'([^']+)'/);
            if (match) {
              const btnType = match[1];
              btn.classList.toggle('active', btnType === mappedType);
            }
          }
        });

        // 自动触发预览生成（修复"等待数据"问题）
        if (craftType === 'emboss' || craftType === 'deboss') {
          // 延迟执行，确保 DOM 已更新
          setTimeout(() => {
            if (typeof updateEmbossPreview === 'function') {
              updateEmbossPreview();
            }
          }, 50);
        } else if (craftType === 'displacement') {
          // 置换贴图自动触发预览
          setTimeout(() => {
            renderCache.invalidate('displacement');
            scheduleThumbnailUpdate('displacement');
          }, 50);
        }
      }

      // 点击预览画布循环切换工艺面板
      let currentCraftIndex = 0;
      const craftTypes = ['normal', 'emboss', 'hotfoil-gold', 'hotfoil-silver'];

      function cycleCraftPanel() {
        // 循环到下一个工艺类型
        currentCraftIndex = (currentCraftIndex + 1) % craftTypes.length;
        const nextType = craftTypes[currentCraftIndex];

        // 切换到对应的工艺类型
        switchCraftType(nextType);

        console.log('Cycled to craft type:', nextType);
      }

      // 切换缩略图区域显示/隐藏
      function toggleCraftThumbnails() {
        const container = document.getElementById('craftThumbnails');
        if (!container) return;

        container.classList.toggle('collapsed');

        // 保存状态
        const isCollapsed = container.classList.contains('collapsed');
        saveSettings('craftThumbnailsCollapsed', isCollapsed);
      }

      // 页面加载时不初始化缩略图，等待用户选择工艺图层后动态生成
      // initCraftThumbnails(); // 已禁用，改为动态生成

      // 默认隐藏缩略图面板，等待用户选择工艺图层
      const craftThumbnailsContainer = document.getElementById('craftThumbnails');
      if (craftThumbnailsContainer) {
        craftThumbnailsContainer.style.display = 'none';
      }

      // 恢复缩略图折叠状态
      requestSettings('craftThumbnailsCollapsed', (data) => {
        if (data === true) {
          const container = document.getElementById('craftThumbnails');
          if (container) {
            container.classList.add('collapsed');
          }
        }
      });

      // 实时刷新工艺图层列表
      setInterval(() => {
        const craftTab = document.getElementById('craftTab');
        if (craftTab && craftTab.classList.contains('active')) {
          refreshNormalLayers();
        }
      }, 2000); // 每2秒刷新一次
    });

    // ============================================================================
    // 🚀 WebGPU Path Tracer Implementation (Cycles-like)
    // ============================================================================
    let gpuDevice = null;
    let renderPipeline = null;
    let bindGroup = null;
    let accumulationTexture = null;
    let frameCount = 0;
    let isRendering = false;
    let animationFrameId = null;

    async function startWebGPURender() {
      if (!navigator.gpu) {
        alert("WebGPU not supported in this browser.");
        return;
      }

      const canvas = document.getElementById('webgpuCanvas');
      canvas.style.display = 'block';
      // 简单的全屏适配
      canvas.width = canvas.clientWidth * window.devicePixelRatio;
      canvas.height = canvas.clientHeight * window.devicePixelRatio;

      if (!gpuDevice) {
        const adapter = await navigator.gpu.requestAdapter();
        gpuDevice = await adapter.requestDevice();
      }

      const context = canvas.getContext('webgpu');
      const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device: gpuDevice,
        format: presentationFormat,
        alphaMode: 'premultiplied',
      });

      // WGSL Shader: 简单的路径追踪器
      const shaderModule = gpuDevice.createShaderModule({
        code: `
          struct Uniforms {
            resolution: vec2f,
            frame: f32,
          };

          @group(0) @binding(0) var<uniform> uniforms: Uniforms;
          @group(0) @binding(1) var outputTex: texture_storage_2d<rgba8unorm, write>;
          // 实际项目中这里应该还有一个 storage texture 用于读取上一帧进行累积
          // 为了简化演示，这里只做单帧渲染，实际 Cycles 效果需要 Read-Write Texture 或 Ping-Pong Buffer

          struct Ray {
            origin: vec3f,
            dir: vec3f,
          };

          fn hit_sphere(center: vec3f, radius: f32, r: Ray) -> f32 {
            let oc = r.origin - center;
            let a = dot(r.dir, r.dir);
            let b = 2.0 * dot(oc, r.dir);
            let c = dot(oc, oc) - radius * radius;
            let discriminant = b*b - 4.0*a*c;
            if (discriminant < 0.0) { return -1.0; }
            return (-b - sqrt(discriminant)) / (2.0*a);
          }

          // 简单的随机数生成
          fn rand(co: vec2f) -> f32 {
            return fract(sin(dot(co, vec2f(12.9898, 78.233))) * 43758.5453);
          }

          fn random_in_unit_sphere(seed: vec2f) -> vec3f {
            let phi = 2.0 * 3.14159 * rand(seed);
            let costheta = 2.0 * rand(seed + 1.0) - 1.0;
            let u = rand(seed + 2.0);
            let theta = acos(costheta);
            let r = pow(u, 1.0/3.0);
            return vec3f(
              r * sin(theta) * cos(phi),
              r * sin(theta) * sin(phi),
              r * cos(theta)
            );
          }

          @compute @workgroup_size(8, 8)
          fn main(@builtin(global_invocation_id) id: vec3u) {
            let width = u32(uniforms.resolution.x);
            let height = u32(uniforms.resolution.y);
            
            if (id.x >= width || id.y >= height) { return; }

            let uv = vec2f(f32(id.x) / f32(width), f32(id.y) / f32(height));
            let aspect = f32(width) / f32(height);
            
            // 相机设置
            let cam_origin = vec3f(0.0, 1.0, 3.0);
            let cam_target = vec3f(0.0, 0.5, 0.0);
            let up = vec3f(0.0, 1.0, 0.0);
            let fov = 1.0; // tan(45deg/2)
            
            let w = normalize(cam_origin - cam_target);
            let u = normalize(cross(up, w));
            let v = cross(w, u);
            
            let screen_pos = cam_origin - w + (uv.x * 2.0 - 1.0) * u * aspect * fov - (uv.y * 2.0 - 1.0) * v * fov;
            
            var ray = Ray(cam_origin, normalize(screen_pos - cam_origin));
            var col = vec3f(0.0);
            var throughput = vec3f(1.0);

            // 路径追踪循环 (Bounces)
            for (var i = 0; i < 4; i++) {
              var t_min = 10000.0;
              var hit_idx = -1;
              var normal = vec3f(0.0);
              var hit_pos = vec3f(0.0);

              // 场景：地面球体
              let t1 = hit_sphere(vec3f(0.0, -100.5, -1.0), 100.0, ray);
              if (t1 > 0.001 && t1 < t_min) { t_min = t1; hit_idx = 1; }

              // 场景：包装盒球体 (模拟)
              let t2 = hit_sphere(vec3f(0.0, 0.5, 0.0), 0.5, ray);
              if (t2 > 0.001 && t2 < t_min) { t_min = t2; hit_idx = 2; }

              if (hit_idx == -1) {
                // 天空光 (IBL 简化)
                let t = 0.5 * (ray.dir.y + 1.0);
                col += throughput * mix(vec3f(1.0), vec3f(0.5, 0.7, 1.0), t);
                break;
              }

              // 计算法线和交点
              hit_pos = ray.origin + t_min * ray.dir;
              if (hit_idx == 1) { normal = normalize(hit_pos - vec3f(0.0, -100.5, -1.0)); }
              else { normal = normalize(hit_pos - vec3f(0.0, 0.5, 0.0)); }

              // 漫反射材质
              let target = hit_pos + normal + random_in_unit_sphere(vec2f(f32(id.x), f32(id.y) + uniforms.frame * 10.0 + f32(i)));
              ray.origin = hit_pos;
              ray.dir = normalize(target - hit_pos);
              
              if (hit_idx == 2) { throughput *= vec3f(0.9, 0.6, 0.2); } // 盒子颜色
              else { throughput *= vec3f(0.5); } // 地面颜色
            }

            // Gamma 校正
            col = pow(col, vec3f(1.0/2.2));
            textureStore(outputTex, vec2u(id.x, height - 1u - id.y), vec4f(col, 1.0));
          }
        `
      });

      renderPipeline = gpuDevice.createComputePipeline({
        layout: 'auto',
        compute: { module: shaderModule, entryPoint: 'main' },
      });

      const uniformBufferSize = 12; // vec2f + f32
      const uniformBuffer = gpuDevice.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });

      function render() {
        frameCount++;
        const uniforms = new Float32Array([canvas.width, canvas.height, frameCount]);
        gpuDevice.queue.writeBuffer(uniformBuffer, 0, uniforms);

        bindGroup = gpuDevice.createBindGroup({
          layout: renderPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: uniformBuffer } },
            { binding: 1, resource: context.getCurrentTexture().createView() },
          ],
        });

        const commandEncoder = gpuDevice.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(renderPipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.dispatchWorkgroups(Math.ceil(canvas.width / 8), Math.ceil(canvas.height / 8));
        passEncoder.end();
        gpuDevice.queue.submit([commandEncoder.finish()]);

        animationFrameId = requestAnimationFrame(render);
      }

      render();
    }
  </script>
</body>
</html>